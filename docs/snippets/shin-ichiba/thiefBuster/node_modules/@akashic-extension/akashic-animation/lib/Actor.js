"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Skeleton = require("./Skeleton");
var Attachment = require("./Attachment");
var CellAttachment = require("./CellAttachment");
var FinalizedCell = require("./FinalizedCell");
var BoneCellCollider = require("./BoneCellCollider");
var CircleCollider = require("./CircleCollider");
var BoxVolume = require("./BoxVolume");
var CircleVolume = require("./CircleVolume");
var AttrId = require("./AttrId");
var vfx = require("./vfx");
// `x`, `y` は左上端を基準に、拡大・縮小・回転の基点は中央を基準とするため、anchorX, anchorY に null 指定。
var g_flipHMatrix = new g.PlainMatrix(0, 0, -1, 1, 0, null, null);
var g_flipVMatrix = new g.PlainMatrix(0, 0, 1, -1, 0, null, null);
/*
 * アニメーションフレームカウンタを適切な範囲に調整する。
 *
 * loop===falseの時:
 * cntrが０より小さければ0を、frameCount-1以上であればframeCount-1を返す。
 *
 * loop===trueの時:
 * cntrが時計の針のように[0,frameCount]で一周し循環するように調整されたものを返す。
 *
 * @param cntr アニメーションフレームカウンタ
 * @param frameCount アニメーションのフレーム数
 * @param loop ループ再生するアニメーションならtrueを与える
 */
function adjustCounter(cntr, frameCount, loop) {
    if (loop) {
        while (cntr >= frameCount) {
            cntr -= frameCount;
        }
        while (cntr < 0) {
            cntr += frameCount;
        }
    }
    else {
        if (cntr < 0) {
            cntr = 0;
        }
        else if (cntr > frameCount - 1) {
            cntr = frameCount - 1;
        }
    }
    return cntr;
}
function setupColliderForCell(info, bone) {
    var collider;
    switch (info.boundType) {
        case "aabb":
        case "box":
            collider = new BoneCellCollider(bone.name, info.boundType === "aabb");
            break;
        default:
            console.warn("Invalid type combination: " + info.geometryType + ", " + info.boundType);
            break;
    }
    return collider;
}
function setupColliderForCircle(info, bone) {
    var collider;
    switch (info.boundType) {
        case "aabb":
        case "circle":
            collider = new CircleCollider(bone.name, info.boundType === "aabb", info.scaleOption);
            break;
        default:
            console.warn("Invalid type combination: " + info.geometryType + ", " + info.boundType);
            break;
    }
    return collider;
}
// 全てのgeometoryTypeと boundtypeの組み合わせが利用可能 というわけ**ではない**
function setupCollider(bones, actor) {
    bones.forEach(function (bone) {
        if (!bone.colliderInfos) {
            return;
        }
        bone.colliderInfos.forEach(function (info) {
            var collider;
            switch (info.geometryType) {
                case "cell":
                    collider = setupColliderForCell(info, bone);
                    break;
                case "circle":
                    collider = setupColliderForCircle(info, bone);
                    break;
                case "box":
                    console.warn("Not implemented geometory type " + info.geometryType);
                    break;
                default:
                    console.warn("Unknown geometory type " + info.geometryType);
                    break;
            }
            if (collider) {
                actor.addCollider(collider);
            }
        });
    });
}
/**
 * ボーンベースのアニメーションを描画するエンティティ。
 */
var Actor = /** @class */ (function (_super) {
    __extends(Actor, _super);
    /**
     * 各種パラメータを指定して `Actor` のインスタンスを生成する。
     */
    function Actor(param) {
        var _this = _super.call(this, param) || this;
        // resource
        _this.resource = param.resource;
        // skeleton
        var boneSet = _this.resource.getBoneSetByName(param.boneSetName);
        _this.skeleton = new Skeleton(boneSet.bones, function () {
            return _this.getMatrix();
        });
        // collider
        _this.colliders = [];
        setupCollider(boneSet.bones, _this);
        // skin
        _this.skins = {};
        for (var i = 0; i < param.skinNames.length; i = (i + 1) | 0) {
            var name = param.skinNames[i];
            _this.skins[name] = _this.resource.getSkinByName(name);
        }
        // animation
        _this.animation = _this.resource.getAnimationByName(param.animationName);
        // effect
        for (var i = 0, len = _this.skeleton.bones.length; i < len; i++) {
            var bone = _this.skeleton.bones[i];
            if (!bone.effectName)
                continue;
            var param_1 = _this.resource.getEffectParameterByName(bone.effectName);
            if (!param_1)
                continue;
            var effect = vfx.createEffect(param_1);
            _this.skeleton.getPostureByName(bone.name).effects.push(effect);
            // DEBUG
            effect._name = bone.name;
        }
        // debug
        // this.skeleton._startEffect();
        // TODO: アニメーションリソースから大きさを導き出す方法を考える
        _this.width = param.width;
        _this.height = param.height;
        // and others
        _this._cntr = 0;
        _this._nextCntr = 0;
        _this._elapse = 0;
        _this._inv = new g.PlainMatrix();
        _this.pause = false;
        _this.loop = true;
        _this.playSpeed = param.playSpeed !== undefined && param.playSpeed !== null ? param.playSpeed : 1.0;
        _this.nullVisible = false;
        _this.boneCoordsVisible = false;
        _this.colliderVisible = false;
        return _this;
    }
    /**
     * コライダーを追加する。
     *
     * @param 追加されるコライダー
     */
    Actor.prototype.addCollider = function (collider) {
        // TODO: アタッチの成否を扱うべきか検討
        collider.onAttached(this);
        this.colliders.push(collider);
    };
    /**
     * コライダーを削除する。
     *
     * @param collider 削除されるコライダー
     */
    Actor.prototype.removeCollider = function (collider) {
        var index = this.colliders.indexOf(collider);
        if (index !== -1) {
            this.colliders.splice(index, 1);
        }
    };
    /**
     * スキンを追加する。
     *
     * 同じ名前を持つスキンがすでにActor内にあるとき、上書きされる。
     *
     * @param skins Actorに追加されるスキンの配列
     */
    Actor.prototype.setSkins = function (skins) {
        for (var i = 0; i < skins.length; i = (i + 1) | 0) {
            var skin = skins[i];
            this.skins[skin.name] = skin;
        }
    };
    /**
     * アニメーションの計算を行う。
     *
     * フレームカウンタがインクリメントされ、アニメーションカーブに基づいた各種プロパティの計算を行います。
     */
    Actor.prototype.calc = function () {
        if (this.pause) {
            return;
        }
        var anime = this.animation;
        if (anime === undefined) {
            return;
        }
        if (this._elapse !== 0) {
            this.skeleton._handleUserEvent(this._cntr, this._elapse, anime);
        }
        // Set current frame counter
        this._cntr = this._nextCntr;
        // Update posture with animation
        this.skeleton.update(this._cntr, anime, this._elapse / this.scene.game.fps);
        if (!this.loop && ((this._cntr === this.animation.frameCount - 1 && this.playSpeed >= 0) ||
            (this._cntr === 0 && this.playSpeed <= 0))) {
            this.ended.fire();
            this.pause = true;
        }
        // Update additional information around posture
        for (var i = 0; i < this.skeleton.composedCaches.length; i = (i + 1) | 0) {
            var cc = this.skeleton.composedCaches[i];
            cc.finalizedCell = createFinalizedCell(cc, this.skins);
        }
        // Set dirty flag for colliders
        for (var i = 0; i < this.colliders.length; i = (i + 1) | 0) {
            this.colliders[i].dirty = true;
        }
        this._elapse = (anime.fps / this.scene.game.fps) * this.playSpeed;
        var nextCntr = this._cntr + this._elapse;
        if (this.loop && (nextCntr >= anime.frameCount || nextCntr < 0)) {
            // 再生がループして先頭に戻った時点でエフェクトをリセットにする
            // リセットの詳細は実装を確認すること
            this.skeleton.resetEffect();
        }
        this._nextCntr = adjustCounter(nextCntr, anime.frameCount, this.loop);
    };
    /**
     * アニメーションを再生する。
     *
     * @param animationName アニメーション名
     * @param startFrame 再生開始フレーム
     * @param loopFlag 再生をループするか指定するフラグ。真の時ループ再生
     * @param playSpeed 再生速度。1.0で通常の再生速度
     */
    Actor.prototype.play = function (animationName, startFrame, loopFlag, playSpeed) {
        this.pause = false;
        this.animation = this.resource.getAnimationByName(animationName);
        this.loop = loopFlag;
        this.playSpeed = playSpeed;
        this._nextCntr = adjustCounter(startFrame, this.animation.frameCount, this.loop);
        this._cntr = this._nextCntr;
        this._elapse = 0;
    };
    Object.defineProperty(Actor.prototype, "currentFrame", {
        get: function () {
            return this._cntr;
        },
        /**
         * 現在のアニメーション再生位置。
         */
        set: function (frame) {
            this._nextCntr = adjustCounter(frame, this.animation.frameCount, this.loop);
            this._cntr = this._nextCntr;
            this._elapse = 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Actor.prototype, "ended", {
        /**
         * アニメーション再生終了イベント。
         */
        get: function () {
            if (!this._ended) {
                this._ended = new g.Trigger();
            }
            return this._ended;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * アニメーション計算ハンドラを扱うg.Triggerを取得する。
     *
     * @param boneName ボーン名
     * @param createIfNotExists? g.Triggerが存在しない時、生成するなら true を与える。省略した時 undefined
     */
    Actor.prototype.calculated = function (boneName, createIfNotExists) {
        return this.skeleton._getTrigger(boneName, createIfNotExists);
    };
    /**
     * アタッチメントを追加する。
     *
     * 返り値は追加されたアタッチメントである。
     * 第一引数に文字列を指定した時、同名のセルをスキン中から探索、それをboneNameで指定したボーンにアタッチする。
     *
     * @param attachable アタッチメントインスタンスまたは装着済みのスキン中のセルを指定する文字列(セル名)
     * @param boneName アタッチ先のボーン名
     * @param matrix? アタッチ位置を調節するマトリクス
     */
    Actor.prototype.attach = function (attachable, boneName, matrix) {
        var _this = this;
        var attachment = undefined;
        if (typeof attachable === "string") {
            var cellName_1 = attachable;
            Object.keys(this.skins).some(function (key) {
                var skin = _this.skins[key];
                var cell = skin.cells[cellName_1];
                if (cell) {
                    attachment = new CellAttachment(cellName_1, skin, matrix);
                }
                return !!cell; // trueを返すとsome()を終了する
            });
        }
        else if (attachable instanceof Attachment) {
            attachment = attachable;
        }
        if (attachment) {
            this.skeleton.attach(attachment, boneName);
        }
        return attachment;
    };
    /**
     * アタッチメントを削除する。
     *
     * @param attachment 削除するアタッチメント。
     */
    Actor.prototype.removeAttachment = function (attachment) {
        this.skeleton.removeAttachment(attachment);
    };
    /**
     * ボーンの行列を取得する。
     *
     * @param boneName ボーン名。
     */
    Actor.prototype.getBoneMatrix = function (boneName) {
        var bones = this.skeleton.bones;
        for (var i = 0, len = bones.length; i < len; i++) {
            if (bones[i].name === boneName) {
                return this.skeleton.composedCaches[bones[i].arrayIndex].m;
            }
        }
        return undefined;
    };
    Actor.prototype.renderSelf = function (renderer, camera) {
        // E#render()から呼ばれる
        // すでに E#x, E#y で translate されている
        // # compoedCachesのソートをやめる
        //
        // ソートは最後の最後なのでなんの影響も残さないと考えていたが間違いだった
        // 例えばクリックイベントでActorの機能を使用し、それがcompsosedCachesにアクセスするとする
        // それはゲームループ(大抵はScene#update())以外のタイミングで実行される
        // そのため期待した並び(ソート済み)では *ない* データへのアクセスとなる
        //
        // ソートされた後もcomposedCachesは再利用され、その時の並びでBone#arrayIndexに応じたボーン情報を持つ
        // つまりActor#calc()の時点でcomposedCachesの各Postureは担当するボーンが変化している
        //
        // そのことでわかりにくいバグが生まれた。BoneCellColliderの参照するセルが変化した
        //
        // 単純のためここで配列を複製し、それをソートする
        var sortedComposedCaches = [].concat(this.skeleton.composedCaches);
        sortedComposedCaches.sort(function (a, b) {
            if (a.attrs[AttrId.prio] === b.attrs[AttrId.prio]) {
                // Array.prototype.sort()は不安定。安定にするために一手間加える
                // DCCツールで優先順位の指定がないとき（全て等しい時）
                // postureの配列の順に描画することを保証したい
                // そのため、prioが等しい時は配列の添字で比較する
                return a.index - b.index;
            }
            else {
                return a.attrs[AttrId.prio] - b.attrs[AttrId.prio];
            }
        });
        renderer.save();
        {
            // E#render()が乗算したActor#getMatrix()をキャンセルする。Postureはこのマトリクスを含んでいる
            this._inv.updateByInverse(this.width, this.height, this.scaleX, this.scaleY, this.angle, this.x, this.y, this.anchorX, this.anchorY);
            renderer.transform(this._inv._matrix);
            // render myself
            this.renderPostures(sortedComposedCaches, renderer, camera);
            // render bone local coordinates
            if (this.boneCoordsVisible) {
                this.renderAxes(renderer);
            }
            // render colliders
            if (this.colliderVisible) {
                this.renderColliders(renderer);
            }
        }
        renderer.restore();
        return true;
    };
    Actor.prototype.renderAxes = function (renderer) {
        this.skeleton.composedCaches.forEach(function (cc) {
            renderer.save();
            {
                renderer.transform(cc.m._matrix);
                renderer.fillRect(0, 0, 16, 1, "#ff0000");
                renderer.fillRect(0, 0, 1, 16, "#00ff00");
            }
            renderer.restore();
        });
    };
    Actor.prototype.renderColliders = function (renderer) {
        renderer.save();
        {
            renderer.opacity(0.25);
            this.colliders.forEach(function (c) {
                var v = c.getVolume();
                if (!v)
                    return;
                // Draw AABB
                var aabb = v.aabb();
                renderer.fillRect(aabb.origin.x - aabb.extent.width, aabb.origin.y - aabb.extent.height, // position
                aabb.extent.width * 2, aabb.extent.height * 2, // width, height
                "#ff0000");
                // Draw Box
                if (v instanceof BoxVolume) {
                    var box = v;
                    renderer.save();
                    {
                        renderer.transform(box.matrix._matrix);
                        renderer.fillRect(box.origin.x, box.origin.y, box.size.width, box.size.height, // width, height
                        "#00ff00");
                    }
                    renderer.restore();
                }
                else if (v instanceof CircleVolume) {
                    var circle = v;
                    renderer.save();
                    {
                        var div = 128;
                        for (var i = 0; i < div; i++) {
                            renderer.fillRect(circle.pos.x + Math.cos(2 * Math.PI / div * i) * circle.r, circle.pos.y + Math.sin(2 * Math.PI / div * i) * circle.r, 4, 4, "#0000ff");
                        }
                    }
                    renderer.restore();
                }
            });
        }
        renderer.restore();
    };
    Actor.prototype.renderEffect = function (effect, renderer, camera) {
        var _this = this;
        effect.particleSystem.traverse(function (e) {
            var skin = _this.resource.getSkinByName(e.userData.skinName);
            var surface = skin.surface;
            var cell = skin.cells[e.userData.cellName];
            var left = cell.pos.x;
            var top = cell.pos.y;
            var width = cell.size.width;
            var height = cell.size.height;
            var particles = e.particles;
            renderer.setCompositeOperation(getCompositeOperation(e.userData.alphaBlendMode));
            for (var i = 0, len = particles.length; i < len; i += 1) {
                var p = particles[i];
                var sx = p.sx * p.sxy;
                var sy = p.sy * p.sxy;
                var cos = Math.cos(p.rz);
                var sin = Math.sin(p.rz);
                var a = cos * sx;
                var b = sin * sx;
                var c = sin * sy;
                var d = cos * sy;
                var px = width * (0.5 + cell.pivot.x);
                var py = height * (0.5 + cell.pivot.y);
                renderer.save();
                renderer.opacity(p.alpha);
                renderer.transform([a, b, -c, d, p.tx, p.ty]);
                renderer.transform([1, 0, 0, 1, -px, -py]);
                renderer.drawImage(surface, left, top, width, height, 0, 0);
                renderer.restore();
            }
        });
    };
    Actor.prototype.renderPostures = function (sortedComposedCaches, renderer, camera) {
        var length = sortedComposedCaches.length;
        for (var i = 0; i < length; i = (i + 1) | 0) {
            var cc = sortedComposedCaches[i];
            if (!cc.attrs[AttrId.visibility]) {
                continue;
            }
            renderer.save();
            {
                renderer.opacity(this.opacity * cc.attrs[AttrId.alpha]);
                renderer.transform(cc.m._matrix); // ボーンのマトリクスを乗算
                renderer.save();
                {
                    for (var j = 0; j < cc.effects.length; j++) {
                        this.renderEffect(cc.effects[j], renderer, camera);
                    }
                    if (cc.finalizedCell) {
                        renderer.transform(cc.finalizedCell.matrix._matrix);
                    }
                    this.renderSelfCore(renderer, camera, cc.finalizedCell);
                }
                renderer.restore();
                cc.attachments.forEach(function (attachment) {
                    attachment.render(renderer);
                });
            }
            renderer.restore();
        }
    };
    Actor.prototype.renderSelfCore = function (renderer, camera, finalizedCell) {
        // 原点に描画する。CANVAS座標系
        // +----------> x
        // |   /\
        // |  /__\
        // | /    \
        // |
        // v
        if (finalizedCell) {
            // ミックスはデフォルト値なので、αブレンドがミックスの場合はcomposite-operation指定処理を省略する
            if (finalizedCell.alphaBlendMode !== undefined && finalizedCell.alphaBlendMode !== "normal") {
                renderer.setCompositeOperation(getCompositeOperation(finalizedCell.alphaBlendMode));
            }
            renderer.drawImage(finalizedCell.surface, finalizedCell.cell.pos.x + (finalizedCell.u * finalizedCell.surface.width), finalizedCell.cell.pos.y + (finalizedCell.v * finalizedCell.surface.height), finalizedCell.cell.size.width, finalizedCell.cell.size.height, 0, 0 // 転送先座標
            );
        }
        else if (this.nullVisible) {
            renderer.fillRect(0, 0, 16, 16, "#ff00ff");
        }
    };
    return Actor;
}(g.E));
function createFinalizedCell(posture, skins) {
    if (posture === undefined || posture.attrs[AttrId.cv] === undefined) {
        return undefined;
    }
    var attrs = posture.attrs;
    var skin = skins[attrs[AttrId.cv].skinName];
    if (!skin) {
        return undefined;
    }
    var cell = skin.cells[attrs[AttrId.cv].cellName];
    if (!cell) {
        return undefined;
    }
    // セル中心位置にアニメーションを反映
    var sgnX = attrs[AttrId.iflh] ? -1 : 1;
    var sgnY = attrs[AttrId.iflv] ? -1 : 1;
    var pvtx = sgnX * (cell.pivot.x + attrs[AttrId.pvtx]);
    var pvty = sgnY * (cell.pivot.y + attrs[AttrId.pvty]);
    // 正規化された値からピクセル座標系へ
    pvtx = cell.size.width * pvtx;
    pvty = cell.size.height * pvty;
    // セルのボーンに対する姿勢を表す行列を求める
    var m = new g.PlainMatrix();
    if (cell.rz === 0) {
        // pivot(セル中心)がセンターに来るようにマトリクスを操作
        // m = [pivot平行移動] x [センタリング]
        m._matrix[4] = -pvtx - cell.size.width / 2;
        m._matrix[5] = -pvty - cell.size.height / 2;
    }
    else {
        // NOTE: `Cell#rz`のアニメーションをサポートするならキャッシュを諦めることになる
        if (!cell.m) { // lazy construction.
            // m = [回転] x [センタリング]
            var m_1 = new g.PlainMatrix();
            var th = Math.PI * (cell.rz / 180);
            var c = Math.cos(th);
            var s = Math.sin(th);
            var tx = -(cell.size.width / 2);
            var ty = -(cell.size.height / 2);
            m_1._matrix[0] = c;
            m_1._matrix[1] = s;
            m_1._matrix[2] = -s;
            m_1._matrix[3] = c;
            m_1._matrix[4] = c * tx - s * ty;
            m_1._matrix[5] = s * tx + c * ty;
            cell.m = m_1;
        }
        // pivot(セル中心)がセンターに来るようにマトリクスを操作
        // m = [pivot平行移動] x [回転] x [センタリング]
        m._matrix[4] = -pvtx;
        m._matrix[5] = -pvty;
        m.multiply(cell.m);
    }
    // セルの水平(垂直)フリップとセル画像の左右(上下)反転の両方が指定されていると二重に反転して元に戻るので、どちらか片方が指定されている時のみ反転させる
    if (attrs[AttrId.flipH] !== attrs[AttrId.iflh]) {
        m = g_flipHMatrix.multiplyNew(m);
    }
    if (attrs[AttrId.flipV] !== attrs[AttrId.iflv]) {
        m = g_flipVMatrix.multiplyNew(m);
    }
    var finalizedCell = new FinalizedCell();
    finalizedCell.surface = skin.surface;
    finalizedCell.cell = cell;
    finalizedCell.u = attrs[AttrId.tu];
    finalizedCell.v = attrs[AttrId.tv];
    finalizedCell.matrix = m;
    finalizedCell.alphaBlendMode = posture.alphaBlendMode;
    return finalizedCell;
}
function getCompositeOperation(alphaBlendMode) {
    switch (alphaBlendMode) {
        case "add":
            return "lighter";
        default:
            return "source-over";
    }
}
module.exports = Actor;
