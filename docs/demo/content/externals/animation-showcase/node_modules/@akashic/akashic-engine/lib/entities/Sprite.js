"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Matrix_1 = require("../Matrix");
var SurfaceUtil_1 = require("../SurfaceUtil");
var E_1 = require("./E");
/**
 * 画像を描画するエンティティ。
 */
var Sprite = /** @class */ (function (_super) {
    __extends(Sprite, _super);
    /**
     * 各種パラメータを指定して `Sprite` のインスタンスを生成する。
     * @param param `Sprite` に設定するパラメータ
     */
    function Sprite(param) {
        var _this = _super.call(this, param) || this;
        _this.src = param.src;
        if ("_drawable" in param.src) {
            _this._surface = param.src;
        }
        else {
            // @ts-ignore
            _this._surface = SurfaceUtil_1.SurfaceUtil.asSurface(param.src);
        }
        if (param.width == null)
            _this.width = _this._surface.width;
        if (param.height == null)
            _this.height = _this._surface.height;
        _this.srcWidth = param.srcWidth != null ? param.srcWidth : _this.width;
        _this.srcHeight = param.srcHeight != null ? param.srcHeight : _this.height;
        _this.srcX = param.srcX || 0;
        _this.srcY = param.srcY || 0;
        _this._stretchMatrix = undefined;
        _this._beforeSrc = _this.src;
        _this._beforeSurface = _this._surface;
        SurfaceUtil_1.SurfaceUtil.setupAnimatingHandler(_this, _this._surface);
        _this._invalidateSelf();
        return _this;
    }
    /**
     * @private
     */
    Sprite.prototype._handleUpdate = function () {
        this.modified();
    };
    /**
     * @private
     */
    Sprite.prototype._handleAnimationStart = function () {
        if (!this.onUpdate.contains(this._handleUpdate, this)) {
            this.onUpdate.add(this._handleUpdate, this);
        }
    };
    /**
     * @private
     */
    Sprite.prototype._handleAnimationStop = function () {
        if (!this.destroyed()) {
            this.onUpdate.remove(this._handleUpdate, this);
        }
    };
    /**
     * このエンティティ自身の描画を行う。
     * このメソッドはエンジンから暗黙に呼び出され、ゲーム開発者が呼び出す必要はない。
     */
    Sprite.prototype.renderSelf = function (renderer, _camera) {
        if (this.srcWidth <= 0 || this.srcHeight <= 0) {
            return true;
        }
        if (this._stretchMatrix) {
            renderer.save();
            renderer.transform(this._stretchMatrix._matrix);
        }
        renderer.drawImage(this._surface, this.srcX, this.srcY, this.srcWidth, this.srcHeight, 0, 0);
        if (this._stretchMatrix)
            renderer.restore();
        return true;
    };
    /**
     * このエンティティの描画キャッシュ無効化をエンジンに通知する。
     * このメソッドを呼び出し後、描画キャッシュの再構築が行われ、各 `Renderer` に描画内容の変更が反映される。
     */
    Sprite.prototype.invalidate = function () {
        this._invalidateSelf();
        this.modified();
    };
    /**
     * このエンティティを破棄する。
     * デフォルトでは利用している `Surface` の破棄は行わない点に注意。
     * @param destroySurface trueを指定した場合、このエンティティが抱える `Surface` も合わせて破棄する
     */
    Sprite.prototype.destroy = function (destroySurface) {
        if (this._surface && !this._surface.destroyed() && destroySurface) {
            this._surface.destroy();
        }
        this.src = undefined;
        this._beforeSrc = undefined;
        this._surface = undefined;
        _super.prototype.destroy.call(this);
    };
    Sprite.prototype._invalidateSelf = function () {
        if (this.width === this.srcWidth && this.height === this.srcHeight) {
            this._stretchMatrix = undefined;
        }
        else {
            this._stretchMatrix = new Matrix_1.PlainMatrix();
            this._stretchMatrix.scale(this.width / this.srcWidth, this.height / this.srcHeight);
        }
        if (this.src !== this._beforeSrc) {
            this._beforeSrc = this.src;
            if ("_drawable" in this.src) {
                this._surface = this.src;
            }
            else {
                // @ts-ignore
                this._surface = SurfaceUtil_1.SurfaceUtil.asSurface(this.src);
            }
        }
        if (this._surface !== this._beforeSurface) {
            SurfaceUtil_1.SurfaceUtil.migrateAnimatingHandler(this, this._beforeSurface, this._surface);
            this._beforeSurface = this._surface;
        }
    };
    return Sprite;
}(E_1.E));
exports.Sprite = Sprite;
