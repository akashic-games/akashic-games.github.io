"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextBoxE = void 0;
var collision_js_1 = require("@akashic-extension/collision-js");
// import { Placer } from "../Placer";
var colors_1 = require("./colors");
var ScrollBar_1 = require("./ScrollBar");
var sizes_1 = require("./sizes");
var WidgetE_1 = require("./WidgetE");
/**
 * 文字列描画。
 *
 * 与えられた文字列、フォント、描画領域などに従って文字列を描画する。
 * この関数は各文字の描画位置を求める、実際の描画をユーザ関数に移譲する。
 *
 * @param text テキスト。
 * @param font フォント。
 * @param lineHeight 行の高さ。
 * @param cursor 初期カーソル位置。
 * @param rightBorder 右境界座標。これをまたぐ文字は次の行へ送られる。
 * @param bottomBorder 下境界座標。カーソルのY座標がこれ以上になる時、描画は打ち切られる。
 * @param callback 描画を行う関数。省略時、何も行わない。
 * @returns 文字列描画後のカーソル位置。
 */
function typeWrite(text, font, lineHeight, cursor, rightBorder, bottomBorder, callback) {
    var newline = 10;
    var x = cursor.x;
    var y = cursor.y;
    for (var i = 0; i < text.length; ++i) {
        if (bottomBorder != null && y >= bottomBorder) {
            break;
        }
        var code = g.Util.charCodeAt(text, i);
        if (!code) {
            continue;
        }
        if (code === newline) {
            y += lineHeight;
            x = cursor.x;
            continue;
        }
        var glyph = font.glyphForCharacter(code);
        if (!glyph) {
            continue;
        }
        // 描画位置が右端に達していれば折り返す。
        if (rightBorder != null && x >= rightBorder) {
            y += lineHeight;
            x = cursor.x;
        }
        // 文字が右からはみ出すなら折り返す。
        if (rightBorder != null && x + glyph.offsetX + glyph.width >= rightBorder) {
            y += lineHeight;
            x = cursor.x;
        }
        if (callback) {
            callback({ x: x, y: y }, glyph);
        }
        // 次の描画位置へ進む。
        x += glyph.advanceWidth;
    }
    return { x: x, y: y };
}
/**
 * テキストの高さを求める。
 *
 * @param text テキスト。
 * @param width 表示幅。テキストはこの幅に従って右端で折り返される。
 * @param font フォント。
 * @returns 高さ。
 */
function getTextLinesHeight(text, width, font) {
    var cursorPos = typeWrite(text, font, font.size, { x: 0, y: 0 }, width, null);
    return cursorPos.y + font.size;
}
/**
 * 文字列を領域内に描画する。
 *
 * @param renderer レンダラー。
 * @param text テキスト。
 * @param position 描画位置。
 * @param bounds 描画領域。この領域内に描画する。
 * @param font フォント。
 */
function drawTextClipped(renderer, text, position, bounds, font) {
    typeWrite(text, font, font.size, position, bounds.max.x, bounds.max.y, function (pos, glyph) {
        if (!glyph.surface) {
            return;
        }
        var minX = pos.x + glyph.offsetX;
        if (minX >= bounds.max.x) {
            return;
        }
        var maxX = minX + glyph.width;
        if (maxX <= bounds.min.x) {
            return;
        }
        var minY = pos.y + glyph.offsetY;
        if (minY >= bounds.max.y) {
            return;
        }
        var maxY = minY + glyph.height;
        if (maxY <= bounds.min.y) {
            return;
        }
        var boundsMinX = Math.max(minX, bounds.min.x);
        var boundsMinY = Math.max(minY, bounds.min.y);
        var boundsMaxX = Math.min(maxX, bounds.max.x);
        var boundsMaxY = Math.min(maxY, bounds.max.y);
        var dx1 = boundsMinX - minX;
        var dy1 = boundsMinY - minY;
        var dx2 = boundsMaxX - maxX;
        var dy2 = boundsMaxY - maxY;
        renderer.drawImage(glyph.surface, glyph.x + dx1, glyph.y + dy1, glyph.width - dx1 + dx2, glyph.height - dy1 + dy2, minX, minY);
    });
}
/**
 * TextBox E。
 *
 * テキストを複数行にわたって表示するE。
 *
 * 子に widget を持つことはできない。子 widget を与えた時の動作は未定義。
 */
var TextBoxE = /** @class */ (function (_super) {
    __extends(TextBoxE, _super);
    function TextBoxE(param) {
        var _this = _super.call(this, param) || this;
        _this.text = param.text;
        _this.font = param.font;
        _this.textCursorPosition = new collision_js_1.Vec2();
        _this.padding = 4;
        _this.tracking = "none";
        _this.prevText = _this.text;
        _this.textBounds = {
            min: { x: 0, y: 0 },
            max: { x: 0, y: 0 }
        };
        var memory = _this.getMemory();
        _this.scrollBar = new ScrollBar_1.ScrollBar();
        _this.scrollBar.scroll = memory.scroll;
        _this.onPointDown.add(_this.handlePointDown, _this);
        _this.onPointMove.add(_this.handlePointMove, _this);
        _this.onPointUp.add(_this.handlePointUp, _this);
        return _this;
    }
    Object.defineProperty(TextBoxE.prototype, "contentArea", {
        get: function () {
            return {
                min: { x: 0, y: 0 },
                max: { x: this.width - sizes_1.sizes.scrollBarW, y: this.height }
            };
        },
        enumerable: false,
        configurable: true
    });
    TextBoxE.prototype.place = function (ui) {
        this.prepare(ui);
        _super.prototype.place.call(this, ui);
    };
    TextBoxE.prototype.postRun = function () {
        this.scrollBar.scrollBy(this.getScrollArea(), 0);
        this.getMemory().scroll = this.scrollBar.scroll;
        _super.prototype.postRun.call(this);
    };
    TextBoxE.prototype.renderSelf = function (renderer, _camera) {
        var contentArea = this.contentArea;
        // 背景。
        renderer.fillRect(contentArea.min.x, contentArea.min.y, contentArea.max.x - contentArea.min.x, contentArea.max.y - contentArea.min.x, colors_1.colors.textBoxBg);
        drawTextClipped(renderer, this.text, this.textCursorPosition, {
            min: {
                x: contentArea.min.x + this.padding,
                y: contentArea.min.y + this.padding
            },
            max: {
                x: contentArea.max.x - this.padding,
                y: contentArea.max.y - this.padding
            },
        }, this.font);
        if (this.scrollBar.inspectArea(this.getScrollArea()) ||
            this.tracking === "thumb") {
            this.scrollBar.draw(renderer, this.getScrollArea());
        }
        // DEBUG: レイアウトに関する領域を描画する。
        // this.drawLayout(renderer);
        return false;
    };
    TextBoxE.prototype.shouldFindChildrenByPoint = function (point) {
        var insideWindow = 0 < point.x && point.x < this.width &&
            0 < point.y && point.y < this.height;
        var insideResizeThumb = this.width - 16 < point.x && point.x < this.width &&
            this.height - 16 < point.y && point.y < this.height;
        var insideScrollBar = this.scrollBar.intersectBar(this.getScrollArea(), point);
        return insideWindow && !insideResizeThumb && !insideScrollBar;
    };
    TextBoxE.prototype.scrollToBottom = function () {
        this.scrollBar.scrollToBottom(this.getScrollArea());
    };
    TextBoxE.prototype.prepare = function (ui) {
        // 期待するサイズの設定。
        var parentPlacer = ui.currentPlacer;
        this.desiredWidth = parentPlacer.availableWidth();
        this.desiredHeight = this.height;
        // テキスト描画開始位置の初期化。
        this.textCursorPosition.copy({
            x: this.padding,
            y: this.padding - this.scrollBar.scroll
        });
        var contentArea = this.contentArea;
        var contentAreaWidth = contentArea.max.x - contentArea.min.x;
        var maxTextLineWidth = contentAreaWidth - this.padding * 2;
        // テキスト全体の高さ[px] の算出。
        var textLinesHeight = getTextLinesHeight(this.text, maxTextLineWidth, this.font);
        // テキスト領域の算出。
        var textBoundsMin = this.textCursorPosition.clone();
        var textBoundsMax = textBoundsMin.clone().add({ x: maxTextLineWidth, y: textLinesHeight });
        if (this.prevText !== this.text ||
            !collision_js_1.Vec2.equal(this.textBounds.min, textBoundsMin) ||
            !collision_js_1.Vec2.equal(this.textBounds.max, textBoundsMax)) {
            collision_js_1.Vec2.copy(this.textBounds.min, textBoundsMin);
            collision_js_1.Vec2.copy(this.textBounds.max, textBoundsMax);
            this.prevText = this.text;
            this.modified();
        }
    };
    TextBoxE.prototype.getMemory = function () {
        var memory = _super.prototype.getMemory.call(this) || { scroll: 0 };
        _super.prototype.setMemory.call(this, memory);
        return memory;
    };
    TextBoxE.prototype.drawLayout = function (renderer) {
        _super.prototype.drawLayout.call(this, renderer);
        this.drawAABB(renderer, this.textBounds, "red");
    };
    TextBoxE.prototype.getScrollArea = function () {
        return {
            visibleArea: this.contentArea,
            // textBounds は contentArea よりやや小さくなるように
            // 計算される。その分拡張することでスクロール範囲が正しくなる。
            contentBounds: {
                min: {
                    x: this.textBounds.min.x - this.padding,
                    y: this.textBounds.min.y - this.padding
                },
                max: {
                    x: this.textBounds.max.x + this.padding,
                    y: this.textBounds.max.y + this.padding
                }
            }
        };
    };
    TextBoxE.prototype.handlePointDown = function (ev) {
        if (this.scrollBar.intersectThumb(this.getScrollArea(), ev.point)) {
            this.tracking = "thumb";
        }
        else {
            this.tracking = "none";
        }
    };
    TextBoxE.prototype.handlePointMove = function (ev) {
        if (this.tracking === "thumb") {
            this.handleThumbMove(ev);
        }
    };
    TextBoxE.prototype.handlePointUp = function (_ev) {
        this.tracking = "none";
    };
    TextBoxE.prototype.handleThumbMove = function (ev) {
        this.scrollBar.scrollBy(this.getScrollArea(), ev.prevDelta.y);
        this.modified();
    };
    return TextBoxE;
}(WidgetE_1.WidgetE));
exports.TextBoxE = TextBoxE;
