"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gui = exports.WindowCreator = void 0;
var Placer_1 = require("./Placer");
var widget_1 = require("./widget");
var WindowManager_1 = require("./WindowManager");
/**
 * ウィジェットのフォントサイズからウィジェットの高さを求める。
 *
 * @param font ウィジェットの用いるフォント。
 * @returns ウィジェットの高さ。
 */
function widgetHeightByFont(font) {
    return Math.round(font.size * 1.5);
}
/**
 * 使用されなかったウィジェットの破棄。
 *
 * @param e ウィジェット。
 * @param alives 使用中ウィジェットリスト。
 */
function destroyDeadWidget(e, alives) {
    if (alives.indexOf(e) === -1) {
        // 親の破棄ですでに破棄されているケースに備え、念の為確認する。
        if (!e.destroyed()) {
            e.destroy();
        }
        return;
    }
}
/**
 * g.E のツリー縦走し WidgetE インスタンスについて callback を実行する。
 *
 * @param e 縦走の起点となる E インスタンス。
 * @param callback コールバック関数。
 */
function traverse(e, callback) {
    var _a;
    if (e instanceof widget_1.WidgetE) {
        callback(e);
    }
    (_a = e.children) === null || _a === void 0 ? void 0 : _a.forEach(function (c) { return traverse(c, callback); });
}
/**
 * Eツリーから WidgetID と型（コンストラクタ）で widget を検索する。
 * @param e 検索対象のE。
 * @param gwid WidgetID。
 * @param ctor WidgetE のコンストラクタ
 * @returns ウィジェット。見つからなかった時 null 。
 */
function findWidgetByGwidAndType(e, gwid, ctor) {
    if (!e) {
        return null;
    }
    if (e instanceof ctor && e.gwid === gwid) {
        return e;
    }
    if (e.children) {
        for (var i = 0; i < e.children.length; i++) {
            var c = e.children[i];
            var w = findWidgetByGwidAndType(c, gwid, ctor);
            if (w) {
                return w;
            }
        }
    }
    return null;
}
function button(ui, title) {
    var gwid = ui.titleToGwid(title);
    var button = ui.findWidgetByGwidAndType(gwid, widget_1.ButtonE) ||
        new widget_1.ButtonE({
            scene: ui.scene,
            height: widgetHeightByFont(ui.font),
            title: title,
            font: ui.font,
            gwid: gwid,
            memory: ui.memory
        });
    button.place(ui);
    return button.isClicked;
}
function buttonUi(title) {
    return function (ui) { return button(ui, title); };
}
function checkbox(ui, title, valueObject, key) {
    var gwid = ui.titleToGwid(title);
    var checkbox = ui.findWidgetByGwidAndType(gwid, widget_1.CheckboxE) ||
        new widget_1.CheckboxE({
            scene: ui.scene,
            height: widgetHeightByFont(ui.font),
            title: title,
            font: ui.font,
            valueObject: valueObject,
            key: key,
            gwid: gwid,
            memory: ui.memory
        });
    // 対象が変更になることがあるので。
    checkbox.valueObject = valueObject;
    checkbox.key = key;
    checkbox.place(ui);
    return checkbox.pressed;
}
function checkboxUi(title, valueObject, key) {
    return function (ui) { return checkbox(ui, title, valueObject, key); };
}
function radioButton(ui, title, valueObject, key, buttonValue) {
    var gwid = ui.titleToGwid(title);
    var radioButton = ui.findWidgetByGwidAndType(gwid, widget_1.RadioButtonE) ||
        new widget_1.RadioButtonE({
            scene: ui.scene,
            height: widgetHeightByFont(ui.font),
            title: title,
            font: ui.font,
            valueObject: valueObject,
            key: key,
            buttonValue: buttonValue,
            gwid: gwid,
            memory: ui.memory
        });
    // 対象が変更になることがあるので。
    radioButton.valueObject = valueObject;
    radioButton.key = key;
    radioButton.place(ui);
    return radioButton.pressed;
}
function radioButtonUi(title, valueObject, key, buttonValue) {
    return function (ui) { return radioButton(ui, title, valueObject, key, buttonValue); };
}
function slider(ui, title, valueObject, key, min, max) {
    var gwid = ui.titleToGwid(title);
    var slider = ui.findWidgetByGwidAndType(gwid, widget_1.SliderE) ||
        new widget_1.SliderE({
            scene: ui.scene,
            height: widgetHeightByFont(ui.font),
            title: title,
            valueObject: valueObject,
            key: key,
            min: min,
            max: max,
            font: ui.font,
            gwid: gwid,
            memory: ui.memory
        });
    // 対象が変更になることがあるので。
    slider.valueObject = valueObject;
    slider.key = key;
    slider.place(ui);
    return slider.changed;
}
function sliderUi(title, valueObject, key, min, max) {
    return function (ui) { return slider(ui, title, valueObject, key, min, max); };
}
function label(ui, title) {
    var gwid = ui.titleToGwid(title);
    var label = ui.findWidgetByGwidAndType(gwid, widget_1.LabelE) ||
        new widget_1.LabelE({
            scene: ui.scene,
            height: widgetHeightByFont(ui.font),
            font: ui.font,
            title: title,
            gwid: gwid,
            memory: ui.memory
        });
    label.title = title;
    label.place(ui);
}
function labelUi(_ui, title) {
    return function (ui) {
        label(ui, title);
        return false;
    };
}
function textBox(ui, title, height, text) {
    var gwid = ui.titleToGwid(title);
    var textBox = ui.findWidgetByGwidAndType(gwid, widget_1.TextBoxE) ||
        new widget_1.TextBoxE({
            scene: ui.scene,
            width: 256,
            height: height,
            title: title,
            text: text,
            font: ui.font,
            gwid: gwid,
            memory: ui.memory
        });
    textBox.text = text;
    textBox.place(ui);
}
function textBoxUi(_ui, title, height, text) {
    return function (ui) {
        textBox(ui, title, height, text);
        return false;
    };
}
function margin(ui, title) {
    var gwid = ui.titleToGwid(title);
    var margin = ui.findWidgetByGwidAndType(gwid, widget_1.MarginE) ||
        new widget_1.MarginE({
            scene: ui.scene,
            width: 100,
            height: widgetHeightByFont(ui.font),
            title: title,
            gwid: gwid,
            memory: ui.memory
        });
    margin.place(ui);
}
function marginUi(_ui, title) {
    return function (ui) {
        margin(ui, title);
        return false;
    };
}
function collapsing(ui, title, addContents) {
    var gwid = ui.titleToGwid(title);
    var collapsing = ui.findWidgetByGwidAndType(gwid, widget_1.CollapsingE) ||
        new widget_1.CollapsingE({
            scene: ui.scene,
            width: 128,
            height: widgetHeightByFont(ui.font),
            title: title,
            font: ui.font,
            gwid: gwid,
            memory: ui.memory
        });
    collapsing.place(ui, addContents);
    return collapsing.isOpen;
}
function collapsingUi(_ui, title, addContents) {
    return function (ui) {
        return collapsing(ui, title, addContents);
    };
}
function horizon(ui, title, addContents) {
    var gwid = ui.titleToGwid(title);
    var horizon = ui.findWidgetByGwidAndType(gwid, widget_1.HorizonE) ||
        new widget_1.HorizonE({
            scene: ui.scene,
            width: 128,
            height: widgetHeightByFont(ui.font),
            title: title,
            gwid: gwid,
            memory: ui.memory
        });
    horizon.place(ui, addContents);
}
function horizonUi(_ui, title, addContents) {
    return function (ui) {
        horizon(ui, title, addContents);
        return false;
    };
}
/**
 * WindowCreator
 *
 * ウインドウスタイルを設定し、ウインドウを生成する役。
 */
var WindowCreator = /** @class */ (function () {
    function WindowCreator(create) {
        this.create = create;
        this.style = {};
    }
    /**
     * ウインドウを表示する。
     *
     * @param addContents ウインドウにウィジェットを追加する関数。
     */
    WindowCreator.prototype.show = function (addContents) {
        this.create(addContents, this.style);
    };
    /**
     * タイトルバーの表示・非表示を設定する。
     *
     * @param v 真の時、表示する。
     * @returns this
     */
    WindowCreator.prototype.titleBar = function (v) {
        this.style.titleBar = v;
        return this;
    };
    /**
     * リサイズの可否を設定する。
     *
     * @param v 真の時、リサイズ可能になる。
     * @returns this
     */
    WindowCreator.prototype.resizable = function (v) {
        this.style.resizable = v;
        return this;
    };
    /**
     * スクロールバーの利用可否を設定する。
     *
     * @param v 真の時、スクロールバーを利用可能にする。
     * @returns this
     */
    WindowCreator.prototype.scrollable = function (v) {
        this.style.scrollable = v;
        return this;
    };
    /**
     * ウインドウの位置を設定する。
     *
     * @param x X座標。
     * @param y Y座標。
     * @returns this
     */
    WindowCreator.prototype.position = function (x, y) {
        this.style.position = { x: x, y: y };
        return this;
    };
    /**
     * ウインドウの大きさを設定する。
     *
     * @param width 横幅[px]。
     * @param height 縦幅[px]。
     * @returns this
     */
    WindowCreator.prototype.size = function (width, height) {
        this.style.size = { x: width, y: height };
        return this;
    };
    return WindowCreator;
}());
exports.WindowCreator = WindowCreator;
/**
 * GUI。
 */
var Gui = /** @class */ (function () {
    /**
     * コンストラクタ。
     *
     * @param scene シーン。
     * @param root ウインドウを接続する E 。画面の原点（左上隅）に配置する。
     * @param font ウィジェットの利用するフォント。
     * @param memory ウィジェットの状態を保存するメモリ。
     */
    function Gui(scene, root, font, memory) {
        this.scene = scene;
        this.root = root;
        this.font = font;
        this.aliveWidgets = [];
        this.coverE = new g.E({
            scene: scene,
            width: g.game.width,
            height: g.game.height
        });
        this.windowManager = new WindowManager_1.WindowManager(scene);
        this.modalWindowManager = new WindowManager_1.WindowManager(scene);
        this.widgetStack = [];
        this.idStack = [];
        this.placerStack = [];
        this.memory = memory;
        this.setupLayer();
    }
    Object.defineProperty(Gui.prototype, "currentWidget", {
        /**
         * 現在のウィジェット。
         *
         * ウィジェットの追加はこのウィジェットに対して行う。
         */
        get: function () {
            if (this.widgetStack.length === 0) {
                return null;
            }
            else {
                return this.widgetStack[this.widgetStack.length - 1];
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Gui.prototype, "currentPlacer", {
        /**
         * 現在のプレイサー。
         *
         * ウィジェットの追加はこのプレイサーと交渉して位置と場所を決める。
         */
        get: function () {
            if (this.placerStack.length === 0) {
                return null;
            }
            else {
                return this.placerStack[this.placerStack.length - 1];
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * ウィジェット ID をスタックにプッシュする。
     *
     * 通常、ウィジェットのタイトルをウィジェット ID に用いる。
     *
     * @param wid ウィジェット ID 。
     */
    Gui.prototype.pushWid = function (wid) {
        this.idStack.push(wid + "");
    };
    /**
     * ウィジェット ID をスタックからポップする。
     */
    Gui.prototype.popWid = function () {
        this.idStack.pop();
    };
    /**
     * ウィジェットタイトル(ID)からグローバルウィジェット ID を得る。
     *
     * @param title ウィジェットのタイトル。
     * @returns グローバルウィジェット ID 。
     */
    Gui.prototype.titleToGwid = function (title) {
        var separator = "::";
        var gwid = this.idStack.length > 0 ?
            this.idStack.join(separator) + separator + title :
            title;
        return gwid;
    };
    /**
     * グローバルウィジェットIDとウィジェットの型に一致するウィジェットを返す。
     *
     * @param gwid グローバルウィジェット ID 。
     * @param ctor ウィジェットのコンストラクタ。
     * @returns ウィジェット。見つからなかった時 null 。
     */
    Gui.prototype.findWidgetByGwidAndType = function (gwid, ctor) {
        return findWidgetByGwidAndType(this.root, gwid, ctor);
    };
    /**
     * run() 実行前に実行するメソッド。
     */
    Gui.prototype.preRun = function () {
        this.aliveWidgets = [];
    };
    /**
     * run() 実行後に実行するメソッド。
     */
    Gui.prototype.postRun = function () {
        var _this = this;
        traverse(this.root, function (w) { return w.postRun(); });
        traverse(this.root, function (w) { return destroyDeadWidget(w, _this.aliveWidgets); });
        this.windowManager.sortWindows();
        this.modalWindowManager.sortWindows();
        this.coverE.touchable = !!(this.modalWindowManager.root.children &&
            this.modalWindowManager.root.children.length);
    };
    /**
     * ウインドウを準備する。
     *
     * @param title ウインドウのタイトル。
     * @param addContents ウインドウにウィジェットを配置する関数。
     * @returns ウインドウクリエータ。これに対して show() を呼ぶことでウインドウが表示される。
     */
    Gui.prototype.window = function (title) {
        var _this = this;
        var creator = new WindowCreator(function (addContents, style) {
            var gwid = _this.titleToGwid(title);
            if (!_this.memory.data[gwid]) {
                _this.memory.data[gwid] = style;
            }
            var found = _this.findWidgetByGwidAndType(gwid, widget_1.WindowE);
            var window = found !== null && found !== void 0 ? found : new widget_1.WindowE({
                scene: _this.scene,
                font: _this.font,
                title: title,
                gwid: gwid,
                memory: _this.memory
            });
            if (!found) {
                _this.windowManager.addNewWindow(window);
                window.onPointDown.add(function (_ev) {
                    _this.windowManager.moveFront(window);
                });
            }
            _this.aliveWidgets.push(window);
            var placer = new Placer_1.Placer(window.cursorPosition, window.contentArea);
            _this.pushWidget(window);
            _this.pushPlacer(placer);
            _this.pushWid(title);
            addContents(_this);
            _this.popWid();
            _this.popPlacer();
            _this.popWidget();
            window.bounds = placer.bounds;
        });
        return creator;
    };
    /**
     * モーダルウインドウを準備する。
     *
     * @param title モーダルウインドウのタイトル。
     * @param addContents モーダルウインドウにウィジェットを配置する関数。
     * @returns ウインドウクリエータ。これに対して show() を呼ぶことでウインドウが表示される。
     */
    Gui.prototype.modalWindow = function (title) {
        var _this = this;
        var creator = new WindowCreator(function (addContents, style) {
            var _a;
            var windowSize = (_a = style.size) !== null && _a !== void 0 ? _a : { x: 320, y: 320 };
            // ウインドウの位置を画面中央にする。
            style.position = {
                x: Math.round((g.game.width - windowSize.x) / 2),
                y: Math.round((g.game.height - windowSize.y) / 2)
            };
            var gwid = _this.titleToGwid(title);
            if (!_this.memory.data[gwid]) {
                _this.memory.data[gwid] = style;
            }
            var found = _this.findWidgetByGwidAndType(gwid, widget_1.WindowE);
            var window = found !== null && found !== void 0 ? found : new widget_1.WindowE({
                scene: _this.scene,
                font: _this.font,
                title: title,
                gwid: gwid,
                scrollable: false,
                memory: _this.memory
            });
            if (!found) {
                _this.modalWindowManager.addNewWindow(window);
                window.onPointDown.add(function (_ev) {
                    _this.modalWindowManager.moveFront(window);
                });
            }
            _this.aliveWidgets.push(window);
            var placer = new Placer_1.Placer(window.cursorPosition, window.contentArea);
            _this.pushWidget(window);
            _this.pushPlacer(placer);
            _this.pushWid(title);
            addContents(_this);
            _this.popWid();
            _this.popPlacer();
            _this.popWidget();
            window.bounds = placer.bounds;
        });
        creator.resizable(false);
        return creator;
    };
    /**
     * 現在の親ウィジェットにウィジェットを配置する。
     *
     * @param widgetE ウィジェット。
     */
    Gui.prototype.attach = function (widgetE) {
        var _a;
        (_a = this.currentWidget) === null || _a === void 0 ? void 0 : _a.append(widgetE);
        this.aliveWidgets.push(widgetE);
    };
    /**
     * ウィジェットの取得。
     *
     * @param title ウィジェットのタイトル。
     * @returns ウィジェット。
     */
    Gui.prototype.getWidget = function (title) {
        var gwid = this.titleToGwid(title);
        return this.findWidgetByGwidAndType(gwid, widget_1.WidgetE);
    };
    /**
     * ウィジェットをスタックにプッシュする。
     *
     * プッシュされたウィジェットは、以降アタッチされるウィジェットの親になる。
     *
     * @param widgetE プッシュされるウィジェット。
     */
    Gui.prototype.pushWidget = function (widgetE) {
        this.widgetStack.push(widgetE);
    };
    /**
     * ウィジェットをスタックからポップする。
     *
     * @returns ポップされたウィジェット。
     */
    Gui.prototype.popWidget = function () {
        return this.widgetStack.pop();
    };
    /**
     * プレイサーをスタックにプッシュする。
     *
     * @param placer プレイサー。
     */
    Gui.prototype.pushPlacer = function (placer) {
        this.placerStack.push(placer);
    };
    /**
     * プレイサーをスタックからポップする。
     *
     * @returns ポップされたプレイサー。
     */
    Gui.prototype.popPlacer = function () {
        return this.placerStack.pop();
    };
    /**
     * ファクトリでウィジェットを生成し配置する。
     *
     * @param factory ウィジェット生成するファクトリ。
     * @returns ウィジェットが操作された時、真。
     */
    Gui.prototype.add = function (factory) {
        return factory(this);
    };
    /**
     * ラベルを配置する。
     *
     * @param title タイトル。
     */
    Gui.prototype.label = function (title) {
        this.add(labelUi(this, title));
    };
    /**
     * マージンを配置する。
     *
     * 何も描画しないウィジェットを配置します。
     *
     * @param title マージンのタイトル。
     */
    Gui.prototype.margin = function (title) {
        this.add(marginUi(this, title));
    };
    /**
     * ボタンを配置する。
     *
     * @param title のタイトル。
     * @returns ボタンが押下された時、真。
     */
    Gui.prototype.button = function (title) {
        return this.add(buttonUi(title));
    };
    /**
     * チェックボックスを配置する。
     *
     * @param title チェックボックスのタイトル。
     * @param valueObject チェックボックスのオン・オフの真偽値を持つオブジェクト。
     * @param key チェックボックスのオン・オフの真偽値のプロパティ名。
     * @returns チェックボックスが押下された時、真。
     */
    Gui.prototype.checkbox = function (title, valueObject, key) {
        return this.add(checkboxUi(title, valueObject, key));
    };
    /**
     * ラジオボタンを配置する。
     *
     * @param title ラジオボタンのタイトル。
     * @param valueObject ラジオボタンのオン・オフの真偽値を持つオブジェクト。
     * @param key ラジオボタンのオン・オフの真偽値のプロパティ名。
     * @returns ラジオボタンが押下された時、真。
     */
    Gui.prototype.radioButton = function (title, valueObject, key, buttonValue) {
        return this.add(radioButtonUi(title, valueObject, key, buttonValue));
    };
    /**
     * スライダーを配置する。
     *
     * @param title
     * @param valueObject スライダーの値を持つオブジェクト。
     * @param key スライダーのオン・オフの値のプロパティ名。
     * @param min 最小値。
     * @param max 最大値。
     * @returns スライダーによって値が変更された時、真。
     */
    Gui.prototype.slider = function (title, valueObject, key, min, max) {
        return this.add(sliderUi(title, valueObject, key, min, max));
    };
    /**
     * 折りたたみを配置する。
     *
     * @param title 折りたたみのタイトル。
     * @param addContents 折りたたみにウィジェットを配置する関数。
     * @returns 折りたたみを開閉した時、真。
     */
    Gui.prototype.collapsing = function (title, addContents) {
        return this.add(collapsingUi(this, title, addContents));
    };
    /**
     * テキストボックスを配置する。
     *
     * @param title テキストボックスのタイトル。
     * @param height 高さ。
     * @param text テキストボックスに表示する文字列。
     */
    Gui.prototype.textBox = function (title, height, text) {
        this.add(textBoxUi(this, title, height, text));
    };
    /**
     * 水平配置を開始する。
     *
     * @param title 水平配置のタイトル
     * @param addContents 水平に配置されるウィジェットを配置する関数。
     */
    Gui.prototype.horizontal = function (title, addContents) {
        this.add((horizonUi(this, title, addContents)));
    };
    Gui.prototype.setupLayer = function () {
        this.root.append(this.windowManager.root);
        this.root.append(this.coverE);
        this.root.append(this.modalWindowManager.root);
    };
    return Gui;
}());
exports.Gui = Gui;
