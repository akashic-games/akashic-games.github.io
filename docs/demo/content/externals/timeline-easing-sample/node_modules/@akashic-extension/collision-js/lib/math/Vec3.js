"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vec3 = void 0;
var sign_1 = require("../sign");
/**
 * 3次元ベクトル。
 */
var Vec3 = /** @class */ (function () {
    function Vec3(xOrVec3Like, y, z) {
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (typeof xOrVec3Like === "number") {
            this.x = xOrVec3Like;
            this.y = y;
            this.z = z;
        }
        else {
            var v = xOrVec3Like || Vec3.zero;
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
        }
    }
    /**
     * x, y, z 要素をコピーする。
     *
     * @param v1 コピー先ベクトル。
     * @param v2 コピー元ベクトル。
     */
    Vec3.copy = function (v1, v2) {
        v1.x = v2.x;
        v1.y = v2.y;
        v1.z = v2.z;
        return v1;
    };
    /**
     * 二つのベクトルを比較する。
     *
     * ベクトルが等しい時、真。
     *
     * @param v1 ベクトル。
     * @param v2 ベクトル。
     */
    Vec3.equal = function (v1, v2) {
        return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
    };
    /**
     * 二つのベクトルを加算する。
     *
     * @param v1 ベクトル。結果はこのベクトルに格納される。
     * @param v2 ベクトル。
     */
    Vec3.add = function (v1, v2) {
        v1.x += v2.x;
        v1.y += v2.y;
        v1.z += v2.z;
        return v1;
    };
    /**
     * 二つのベクトルを減算する。
     *
     * @param v1 ベクトル。結果はこのベクトルに格納される。
     * @param v2 ベクトル。
     */
    Vec3.sub = function (v1, v2) {
        v1.x -= v2.x;
        v1.y -= v2.y;
        v1.z -= v2.z;
        return v1;
    };
    /**
     * 内積を求める。
     *
     * @param v1 ベクトル。
     * @param v2 ベクトル。
     */
    Vec3.dot = function (v1, v2) {
        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    };
    /**
     * 外積を求める。
     *
     * @param v1 ベクトル。
     * @param v2 ベクトル。
     */
    Vec3.cross = function (v1, v2) {
        return {
            x: v1.y * v2.z - v1.z * v2.y,
            y: v1.z * v2.x - v1.x * v2.z,
            z: v1.x * v2.y - v1.y * v2.x
        };
    };
    /**
     * 二つの単位ベクトルが平行か調べる。
     *
     * 二つのベクトルの内積が閾値以上の時、真（平行）。
     *
     * @param v1 単位ベクトル。
     * @param v2 単位ベクトル。
     * @param threshold 閾値。省略時 1 。
     */
    Vec3.parallel = function (v1, v2, threshold) {
        if (threshold === void 0) { threshold = 1; }
        return Math.abs(Vec3.dot(v1, v2)) >= threshold;
    };
    /**
     * x, y, z 要素をこのベクトルにコピーする。
     *
     * @param v コピー元ベクトル。
     */
    Vec3.prototype.copy = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    };
    /**
     * 複製する。
     */
    Vec3.prototype.clone = function () {
        return new Vec3(this.x, this.y, this.z);
    };
    /**
     * 比較する。
     *
     * 等しい時、真。
     *
     * @param v ベクトル。
     */
    Vec3.prototype.equal = function (v) {
        return this.x === v.x && this.y === v.y && this.z === v.z;
    };
    /**
     * このベクトルと単位ベクトルが平行か調べる。
     *
     * このベクトル自身が単位ベクトルでなければならない。
     *
     * 二つのベクトルの内積が閾値以上の時、真（平行）。
     *
     * @param v 単位ベクトル。
     * @param threshold 閾値。省略時 1 。
     */
    Vec3.prototype.parallel = function (v, threshold) {
        if (threshold === void 0) { threshold = 1; }
        return Math.abs(this.dot(v)) >= threshold;
    };
    /**
     * 加算する。
     *
     * @param v ベクトル。
     */
    Vec3.prototype.add = function (v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    };
    /**
     * 減算する。
     *
     * @param v ベクトル。
     */
    Vec3.prototype.sub = function (v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    };
    /**
     * スケールする。
     *
     * @param v スケール。
     */
    Vec3.prototype.scale = function (v) {
        this.x *= v;
        this.y *= v;
        this.z *= v;
        return this;
    };
    /**
     * アダマール積を求める。
     *
     * @param v ベクトル。
     */
    Vec3.prototype.mul = function (v) {
        this.x = this.x * v.x;
        this.y = this.y * v.y;
        this.z = this.z * v.z;
        return this;
    };
    /**
     * 内積を求める。
     *
     * @param v ベクトル。
     */
    Vec3.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    };
    /**
     * 外積を求める。
     *
     * @param v ベクトル。
     */
    Vec3.prototype.cross = function (v) {
        return new Vec3(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
    };
    /**
     * 投影する。
     *
     * @param v 投影先のベクトル。
     */
    Vec3.prototype.project = function (v) {
        var d = v.x * v.x +
            v.y * v.y +
            v.z * v.z;
        if (d > 0) {
            var s = this.dot(v) / d;
            this.x = v.x * s;
            this.y = v.y * s;
            this.z = v.z * s;
        }
        return this;
    };
    /**
     * 投影したベクトルから自身へ向かうベクトルにする。
     *
     * @param v 投影先のベクトル。
     */
    Vec3.prototype.reject = function (v) {
        this.sub(this.clone().project(v));
        return this;
    };
    /**
     * 反射する。
     *
     * @param n 法線ベクトル。
     */
    Vec3.prototype.reflect = function (n) {
        var d2 = this.dot(n) * 2;
        this.sub({
            x: n.x * d2,
            y: n.y * d2,
            z: n.z * d2
        });
        return this;
    };
    /**
     * 長さの二乗を求める。
     */
    Vec3.prototype.squaredLength = function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    };
    /**
     * 長さを求める。
     */
    Vec3.prototype.length = function () {
        return Math.sqrt(this.squaredLength());
    };
    /**
     * 正規化する。
     */
    Vec3.prototype.normalize = function () {
        var len = this.length() || 1;
        this.x /= len;
        this.y /= len;
        this.z /= len;
        return this;
    };
    /**
     * 符号を反転する。
     */
    Vec3.prototype.negate = function () {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        return this;
    };
    /**
     * 四捨五入する。
     */
    Vec3.prototype.round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    };
    /**
     * 小数点以下を切り捨てる。
     */
    Vec3.prototype.floor = function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    };
    /**
     * 小数点以下を切り上げる。
     */
    Vec3.prototype.ceil = function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    };
    /**
     * 各要素を符号を表す +/- 1, +/- 0 にする。
     */
    Vec3.prototype.sign = function () {
        this.x = sign_1.sign(this.x);
        this.y = sign_1.sign(this.y);
        this.z = sign_1.sign(this.z);
        return this;
    };
    /**
     * X軸回転する。
     *
     * @param angle 回転の角度[radian]。
     */
    Vec3.prototype.rotateX = function (angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var y = c * this.y - s * this.z;
        var z = s * this.y + c * this.z;
        this.y = y;
        this.z = z;
        return this;
    };
    /**
     * Y軸回転する。
     *
     * @param angle 回転の角度[radian]。
     */
    Vec3.prototype.rotateY = function (angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var x = s * this.z + c * this.x;
        var z = c * this.z - s * this.x;
        this.x = x;
        this.z = z;
        return this;
    };
    /**
     * Z軸回転する。
     *
     * @param angle 回転の角度[radian]。
     */
    Vec3.prototype.rotateZ = function (angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var x = c * this.x - s * this.y;
        var y = s * this.x + c * this.y;
        this.x = x;
        this.y = y;
        return this;
    };
    /**
     * 零ベクトル。
     */
    Vec3.zero = Object.freeze({ x: 0, y: 0, z: 0 });
    return Vec3;
}());
exports.Vec3 = Vec3;
