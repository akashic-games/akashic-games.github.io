"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.polygonToLine = exports.polygonToAABB = exports.polygonToBox = exports.polygonToVec = exports.polygonToCircle = exports.polygonToSegment = exports.polygonToPolygon = exports.segmentToBox = exports.lineToBox = exports.lineToSegment = exports.vecToBox = exports.vecToSegment = exports.vecToLine = exports.aabbToBox = exports.aabbToSegment = exports.aabbToLine = exports.aabbToVec = exports.circleToBox = exports.circleToAABB = exports.circleToSegment = exports.circleToLine = exports.circleToVec = exports.boxToBox = exports.segmentToSegment = exports.lineToLine = exports.vecToVec = exports.circleToCircleContact = exports.circleToCircle = exports.aabbToAABB = exports.createAABBFromBox = exports.enlargeAABB = exports.overlapAABBAndSegment = exports.overlapBoxAndSegment = exports.getAABBCorner = exports.getBoxCorner = exports.getBoxEdge = exports.whichSide = void 0;
var math_1 = require("../math");
var sign_1 = require("../sign");
var gjk_1 = require("./gjk");
/**
 * 平行判定。
 *
 * ２つのベクトルが平行である時、真。
 *
 * Vec2 の parallel は閾値を扱う都合上、正規化されたベクトルのみ
 * サポートする。この関数は閾値を扱えないが、正規化されていないベクトルを
 * 扱える。
 *
 * @param v1 ベクトル。
 * @param v2 ベクトル。
 */
function parallel(v1, v2) {
    return v1.x * v2.y - v1.y * v2.x === 0;
}
/**
 * 点が直線によって分けられた２つの半空間のいずれに位置するか調べる。
 *
 * 点が直線上にある時、０。そうでない時、位置する半空間に応じて正または負の値を返す。
 *
 * @param line 直線。
 * @param p 点の位置。
 */
function whichSide(line, p) {
    var x = new math_1.Vec2(p).sub(line.position);
    var n = new math_1.Vec2(-line.direction.y, line.direction.x);
    return n.dot(x);
}
exports.whichSide = whichSide;
/**
 * 矩形の辺を得る。
 *
 * 各辺の番号は0から始まり、下辺から時計回りに配される。a~d はそれぞれ頂点である。
 *
 * 図はX軸が右を、Y軸が下を向いている。
 *
 * ```
 *       2
 *    c-----d
 *    |     |
 *  1 |     | 3
 *    |     |
 *    b-----a
 *       0
 * ```
 *
 *  各辺の (始点, 終点) は次のようになる。
 *
 *  - 辺番号0: (a, b)
 *  - 辺番号1: (b, c)
 *  - 辺番号2: (c, d)
 *  - 辺番号3: (d, a)
 *
 * 辺番号が不正な時 null を返す。
 *
 * @param box 矩形。
 * @param idx 辺の番号。 [0, 3] 。
 */
function getBoxEdge(box, idx) {
    if (idx < 0 || idx > 3) {
        return null;
    }
    var v1 = new math_1.Vec2(box.halfExtend);
    var v2 = new math_1.Vec2(box.halfExtend);
    if (idx === 0) {
        v2.x *= -1;
    }
    else if (idx === 1) {
        v1.x *= -1;
        v2.negate();
    }
    else if (idx === 2) {
        v1.negate();
        v2.y *= -1;
    }
    else {
        v1.y *= -1;
    }
    v1.rotate(box.angle).add(box.position);
    v2.rotate(box.angle).add(box.position);
    return {
        position: v1,
        endPosition: v2
    };
}
exports.getBoxEdge = getBoxEdge;
/**
 * 矩形の頂点の座標を得る。
 *
 * 図はX軸が右を、Y軸が下を向いている。a~bは頂点を表す。
 *
 * ```
 * c-----d
 * |     |
 * |     |
 * |     |
 * b-----a
 * ```
 *
 * - 頂点番号0: a
 * - 頂点番号1: b
 * - 頂点番号2: c
 * - 頂点番号3: d
 *
 * 頂点番号が不正な時 null を返す。
 *
 * @param b 矩形。
 * @param idx 頂点の番号 [0, 3] 。
 */
function getBoxCorner(b, idx) {
    if (idx < 0 || idx > 3) {
        return null;
    }
    var corner = new math_1.Vec2(b.halfExtend);
    if (idx === 1) {
        corner.x *= -1;
    }
    else if (idx === 2) {
        corner.negate();
    }
    else if (idx === 3) {
        corner.y *= -1;
    }
    return corner.rotate(b.angle).add(b.position);
}
exports.getBoxCorner = getBoxCorner;
/**
 * AABBの頂点の座標を得る。
 *
 * 図はX軸が右を、Y軸が下を向いている。a~bは頂点を表す。
 *
 * ```
 * c-----d
 * |     |
 * |     |
 * |     |
 * b-----a
 * ```
 *
 * - 頂点番号0: a
 * - 頂点番号1: b
 * - 頂点番号2: c
 * - 頂点番号3: d
 *
 * 頂点番号が不正な時 null を返す。
 *
 * @param aabb AABB 。
 * @param idx 頂点の番号 [0, 3] 。
 */
function getAABBCorner(aabb, idx) {
    var corner = null;
    if (idx === 0) {
        corner = {
            x: aabb.max.x,
            y: aabb.max.y
        };
    }
    else if (idx === 1) {
        corner = {
            x: aabb.min.x,
            y: aabb.max.y
        };
    }
    else if (idx === 2) {
        corner = {
            x: aabb.min.x,
            y: aabb.min.y
        };
    }
    else if (idx === 3) {
        corner = {
            x: aabb.max.x,
            y: aabb.min.y
        };
    }
    return corner;
}
exports.getAABBCorner = getAABBCorner;
/**
 * 線分と線分に重なる直線に投影した矩形の交差判定。
 *
 * @param box 矩形。
 * @param segment 線分。
 */
function overlapBoxAndSegment(box, segment) {
    var edge0 = getBoxEdge(box, 0);
    var edge2 = getBoxEdge(box, 2);
    var dir = new math_1.Vec2(segment.endPosition).sub(segment.position).normalize();
    var ts1 = dir.dot(segment.position);
    var ts2 = dir.dot(segment.endPosition);
    var te01 = dir.dot(edge0.position);
    var te02 = dir.dot(edge0.endPosition);
    var te21 = dir.dot(edge2.position);
    var te22 = dir.dot(edge2.endPosition);
    var tsMin = Math.min(ts1, ts2);
    var tsMax = Math.max(ts1, ts2);
    var teMin = Math.min(te01, te02, te21, te22);
    var teMax = Math.max(te01, te02, te21, te22);
    return math_1.overlap(tsMin, tsMax, teMin, teMax);
}
exports.overlapBoxAndSegment = overlapBoxAndSegment;
/**
 * 線分と線分に重なる直線に投影したAABBの交差判定。
 *
 * @param aabb AABB 。
 * @param segment 線分。
 */
function overlapAABBAndSegment(aabb, segment) {
    var edge0 = {
        position: getAABBCorner(aabb, 0),
        endPosition: getAABBCorner(aabb, 1)
    };
    var edge2 = {
        position: getAABBCorner(aabb, 2),
        endPosition: getAABBCorner(aabb, 3)
    };
    var dir = new math_1.Vec2(segment.endPosition).sub(segment.position).normalize();
    var ts1 = dir.dot(segment.position);
    var ts2 = dir.dot(segment.endPosition);
    var te01 = dir.dot(edge0.position);
    var te02 = dir.dot(edge0.endPosition);
    var te21 = dir.dot(edge2.position);
    var te22 = dir.dot(edge2.endPosition);
    var tsMin = Math.min(ts1, ts2);
    var tsMax = Math.max(ts1, ts2);
    var teMin = Math.min(te01, te02, te21, te22);
    var teMax = Math.max(te01, te02, te21, te22);
    return math_1.overlap(tsMin, tsMax, teMin, teMax);
}
exports.overlapAABBAndSegment = overlapAABBAndSegment;
/**
 * AABB が 点 p を含むように拡張する。
 *
 * @param aabb AABB 。
 * @param p 点の位置。
 */
function enlargeAABB(aabb, p) {
    aabb.min.x = Math.min(aabb.min.x, p.x);
    aabb.max.x = Math.max(aabb.max.x, p.x);
    aabb.min.y = Math.min(aabb.min.y, p.y);
    aabb.max.y = Math.max(aabb.max.y, p.y);
}
exports.enlargeAABB = enlargeAABB;
/**
 * 矩形に外接する AABB 生成する。
 *
 * @param b 矩形。
 */
function createAABBFromBox(b) {
    var aabb = {
        min: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY },
        max: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY }
    };
    for (var i = 0; i < 4; i++) {
        var p = getBoxCorner(b, i);
        enlargeAABB(aabb, p);
    }
    return aabb;
}
exports.createAABBFromBox = createAABBFromBox;
/**
 * AABB と AABB の交差テスト。
 *
 * @param a AABB A.
 * @param b AABB B.
 */
function aabbToAABB(a, b) {
    return math_1.overlap(a.min.x, a.max.x, b.min.x, b.max.x) &&
        math_1.overlap(a.min.y, a.max.y, b.min.y, b.max.y);
}
exports.aabbToAABB = aabbToAABB;
/**
 * 円と円の交差テスト。
 *
 * @param a 円A。
 * @param b 円B。
 */
function circleToCircle(a, b) {
    var d = new math_1.Vec2(b.position).sub(a.position);
    var d2 = d.squaredLength();
    var r = b.radius + a.radius;
    var r2 = r * r;
    return d2 <= r2;
}
exports.circleToCircle = circleToCircle;
/**
 * 円と円の交差テスト。
 *
 * 交差しない時 null を返す。
 *
 * @param a 円A。
 * @param b 円B。
 */
function circleToCircleContact(a, b) {
    var d = new math_1.Vec2(b.position).sub(a.position);
    var d2 = d.squaredLength();
    var r = a.radius + b.radius;
    var r2 = r * r;
    if (d2 <= r2) {
        var separation = Math.sqrt(d2) - r;
        var normal = d.normalize();
        var point = d.clone().scale(a.radius + separation).add(a.position);
        return {
            point: point,
            separation: separation,
            normal: normal
        };
    }
    else {
        return null;
    }
}
exports.circleToCircleContact = circleToCircleContact;
/**
 * 点と点の交差テスト。
 *
 * @param a 点の位置。
 * @param b 点の位置。
 */
function vecToVec(a, b) {
    return a.x === b.x && a.y === b.y;
}
exports.vecToVec = vecToVec;
/**
 * 直線と直線の交差テスト。
 *
 * @param a 直線A。
 * @param b 直線B。
 */
function lineToLine(a, b) {
    if (parallel(a.direction, b.direction)) {
        var d = new math_1.Vec2(a.position).sub(b.position);
        return parallel(d, b.direction);
    }
    else {
        return true;
    }
}
exports.lineToLine = lineToLine;
/**
 * 線分と線分の交差テスト。
 *
 * @param a 線分A。
 * @param b 線分B。
 */
function segmentToSegment(a, b) {
    var dirA = new math_1.Vec2(a.endPosition).sub(a.position);
    var axisA = {
        position: a.position,
        direction: dirA
    };
    if (whichSide(axisA, b.position) * whichSide(axisA, b.endPosition) > 0) {
        return false;
    }
    var dirB = new math_1.Vec2(b.endPosition).sub(b.position);
    var axisB = {
        position: b.position,
        direction: dirB
    };
    if (whichSide(axisB, a.position) * whichSide(axisB, a.endPosition) > 0) {
        return false;
    }
    if (parallel(axisA.direction, axisB.direction)) {
        dirA.normalize();
        var tA1 = dirA.dot(a.position);
        var tA2 = dirA.dot(a.endPosition);
        var tB1 = dirA.dot(b.position);
        var tB2 = dirA.dot(b.endPosition);
        var tAmin = void 0;
        var tAmax = void 0;
        var tBmin = void 0;
        var tBmax = void 0;
        if (tA1 < tA2) {
            tAmin = tA1;
            tAmax = tA2;
        }
        else {
            tAmin = tA2;
            tAmax = tA1;
        }
        if (tB1 < tB2) {
            tBmin = tB1;
            tBmax = tB2;
        }
        else {
            tBmin = tB2;
            tBmax = tB1;
        }
        return math_1.overlap(tAmin, tAmax, tBmin, tBmax);
    }
    else {
        return true;
    }
}
exports.segmentToSegment = segmentToSegment;
/**
 * 矩形と矩形の交差判定。
 *
 * @param a 矩形。
 * @param b 矩形。
 */
function boxToBox(a, b) {
    if (!overlapBoxAndSegment(a, getBoxEdge(b, 0))) {
        return false;
    }
    if (!overlapBoxAndSegment(a, getBoxEdge(b, 3))) {
        return false;
    }
    if (!overlapBoxAndSegment(b, getBoxEdge(a, 0))) {
        return false;
    }
    if (!overlapBoxAndSegment(b, getBoxEdge(a, 3))) {
        return false;
    }
    return true;
}
exports.boxToBox = boxToBox;
/**
 * 円と点の交差テスト。
 *
 * @param c 円。
 * @param v 点の位置。
 */
function circleToVec(c, v) {
    var dx = v.x - c.position.x;
    var dy = v.y - c.position.y;
    return dx * dx + dy * dy <= c.radius * c.radius;
}
exports.circleToVec = circleToVec;
/**
 * 円と直線の交差テスト。
 *
 * @param c 円。
 * @param l 直線。
 */
function circleToLine(c, l) {
    var lc = new math_1.Vec2(c.position).sub(l.position);
    var nearest = lc.project(l.direction).add(l.position);
    return circleToVec(c, nearest);
}
exports.circleToLine = circleToLine;
/**
 * 円と線分の交差判定。
 *
 * @param c 円。
 * @param s 線分。
 */
function circleToSegment(c, s) {
    if (circleToVec(c, s.position)) {
        return true;
    }
    if (circleToVec(c, s.endPosition)) {
        return true;
    }
    var dir = new math_1.Vec2(s.endPosition).sub(s.position);
    var projected = new math_1.Vec2(c.position).sub(s.position).project(dir);
    var nearest = projected.clone().add(s.position);
    return circleToVec(c, nearest) &&
        projected.squaredLength() <= dir.squaredLength() &&
        projected.dot(dir) >= 0;
}
exports.circleToSegment = circleToSegment;
/**
 * 円と AABB の交差判定。
 *
 * @param c 円。
 * @param aabb AABB。
 */
function circleToAABB(c, aabb) {
    var x = math_1.clamp(c.position.x, aabb.min.x, aabb.max.x);
    var y = math_1.clamp(c.position.y, aabb.min.y, aabb.max.y);
    return circleToVec(c, { x: x, y: y });
}
exports.circleToAABB = circleToAABB;
/**
 * 円と矩形の交差判定。
 *
 * @param c 円。
 * @param b 矩形。
 */
function circleToBox(c, b) {
    var localPos = new math_1.Vec2(c.position).sub(b.position).rotate(-b.angle);
    var min = new math_1.Vec2(b.halfExtend).scale(-1);
    var max = new math_1.Vec2(b.halfExtend);
    return circleToAABB({ position: localPos, radius: c.radius }, { min: min, max: max });
}
exports.circleToBox = circleToBox;
/**
 * AABBと点の交差判定。
 *
 * @param aabb AABB 。
 * @param v 点の位置。
 */
function aabbToVec(aabb, v) {
    return aabb.min.x <= v.x && v.x <= aabb.max.x &&
        aabb.min.y <= v.y && v.y <= aabb.max.y;
}
exports.aabbToVec = aabbToVec;
/**
 * AABBと直線の交差判定。
 *
 * @param aabb AABB 。
 * @param l 直線。
 */
function aabbToLine(aabb, l) {
    var n = new math_1.Vec2(l.direction).rotate270();
    var d = -n.dot(l.position);
    var d1 = n.dot(aabb.min) + d;
    var d2 = n.dot(aabb.max) + d;
    var d3 = n.dot({ x: aabb.max.x, y: aabb.min.y }) + d;
    var d4 = n.dot({ x: aabb.min.x, y: aabb.max.y }) + d;
    return d1 * d2 <= 0 || d1 * d3 <= 0 || d1 * d4 <= 0;
}
exports.aabbToLine = aabbToLine;
/**
 * AABBと線分の交差判定。
 *
 * @param aabb AABB 。
 * @param s 線分。
 */
function aabbToSegment(aabb, s) {
    var l = {
        position: s.position,
        direction: new math_1.Vec2(s.endPosition).sub(s.position)
    };
    if (!aabbToLine(aabb, l)) {
        return false;
    }
    var xRange = [s.position.x, s.endPosition.x].sort(function (a, b) { return a - b; });
    if (!math_1.overlap(aabb.min.x, aabb.max.x, xRange[0], xRange[1])) {
        return false;
    }
    var yRange = [s.position.y, s.endPosition.y].sort(function (a, b) { return a - b; });
    if (!math_1.overlap(aabb.min.y, aabb.max.y, yRange[0], yRange[1])) {
        return false;
    }
    return true;
}
exports.aabbToSegment = aabbToSegment;
/**
 * AABB と矩形の交差判定。
 *
 * @param aabb AABB 。
 * @param b 矩形。
 */
function aabbToBox(aabb, b) {
    var bAABB = createAABBFromBox(b);
    if (!aabbToAABB(aabb, bAABB)) {
        return false;
    }
    if (!overlapAABBAndSegment(aabb, getBoxEdge(b, 0))) {
        return false;
    }
    return overlapAABBAndSegment(aabb, getBoxEdge(b, 3));
}
exports.aabbToBox = aabbToBox;
/**
 * 点と直線の交差判定。
 *
 * @param v 点の位置。
 * @param l 直線。
 */
function vecToLine(v, l) {
    var n = new math_1.Vec2(l.direction).rotate270();
    var d = -n.dot(l.position);
    return n.dot(v) + d === 0;
}
exports.vecToLine = vecToLine;
/**
 * 点と線分の交差判定。
 *
 * @param v 点の位置。
 * @param s 線分。
 */
function vecToSegment(v, s) {
    var dir = new math_1.Vec2(s.endPosition).sub(s.position);
    var n = dir.clone().rotate270();
    var d = -n.dot(s.position);
    if (n.dot(v) + d !== 0) {
        return false;
    }
    var vl = new math_1.Vec2(v).sub(s.position);
    return vl.squaredLength() < dir.squaredLength() && vl.dot(dir) >= 0;
}
exports.vecToSegment = vecToSegment;
/**
 * 点と矩形の交差判定。
 *
 * @param v 点の位置。
 * @param b 矩形。
 */
function vecToBox(v, b) {
    var lv = new math_1.Vec2(v).sub(b.position).rotate(-b.angle);
    return -b.halfExtend.x <= lv.x && lv.x <= b.halfExtend.x &&
        -b.halfExtend.y <= lv.y && lv.y <= b.halfExtend.y;
}
exports.vecToBox = vecToBox;
/**
 * 直線と線分の交差判定。
 *
 * @param l 直線。
 * @param s 線分。
 */
function lineToSegment(l, s) {
    return whichSide(l, s.position) * whichSide(l, s.endPosition) < 0;
}
exports.lineToSegment = lineToSegment;
/**
 * 直線と矩形の交差判定。
 *
 * @param l 直線。
 * @param b 矩形。
 */
function lineToBox(l, b) {
    var aabb = {
        min: new math_1.Vec2(b.halfExtend).negate(),
        max: new math_1.Vec2(b.halfExtend)
    };
    var ll = {
        position: new math_1.Vec2(l.position).sub(b.position).rotate(-b.angle),
        direction: new math_1.Vec2(l.direction).rotate(-b.angle)
    };
    return aabbToLine(aabb, ll);
}
exports.lineToBox = lineToBox;
/**
 * 線分と矩形の交差判定。
 *
 * @param s 線分。
 * @param b 矩形。
 */
function segmentToBox(s, b) {
    var aabb = {
        min: new math_1.Vec2(b.halfExtend).negate(),
        max: new math_1.Vec2(b.halfExtend)
    };
    var sl = {
        position: new math_1.Vec2(s.position).sub(b.position).rotate(-b.angle),
        endPosition: new math_1.Vec2(s.endPosition).sub(b.position).rotate(-b.angle)
    };
    return aabbToSegment(aabb, sl);
}
exports.segmentToBox = segmentToBox;
/**
 * 多角形と多角形の交差判定。
 *
 * @param p1 多角形1。３頂点以上の凸多角形でなければならない。
 * @param p2 多角形2。３頂点以上の凸多角形でなければならない。
 */
function polygonToPolygon(p1, p2) {
    return gjk_1.gjkTest(p1, gjk_1.supportPolygon, p2, gjk_1.supportPolygon);
}
exports.polygonToPolygon = polygonToPolygon;
/**
 * 多角形と線分の交差判定。
 *
 * @param p 多角形。３頂点以上の凸多角形でなければならない。
 * @param s 線分。
 */
function polygonToSegment(p, s) {
    return gjk_1.gjkTest(p, gjk_1.supportPolygon, s, gjk_1.supportSegment);
}
exports.polygonToSegment = polygonToSegment;
/**
 * 多角形と円の交差判定。
 *
 * @param p 多角形。３頂点以上の凸多角形でなければならない。
 * @param c 円。
 */
function polygonToCircle(p, c) {
    return gjk_1.gjkTest(p, gjk_1.supportPolygon, c, gjk_1.supportCircle);
}
exports.polygonToCircle = polygonToCircle;
/**
 * 多角形と点の交差判定。
 *
 * @param p 多角形。３頂点以上の凸多角形でなければならない。
 * @param v 点の位置。
 */
function polygonToVec(p, v) {
    return gjk_1.gjkTest(p, gjk_1.supportPolygon, { position: v }, gjk_1.supportVec);
}
exports.polygonToVec = polygonToVec;
/**
 * 多角形と矩形の交差判定。
 *
 * @param p 多角形。３頂点以上の凸多角形でなければならない。
 * @param b 矩形s。
 */
function polygonToBox(p, b) {
    return gjk_1.gjkTest(p, gjk_1.supportPolygon, b, gjk_1.supportBox);
}
exports.polygonToBox = polygonToBox;
/**
 * 多角形とAABBの交差判定。
 *
 * @param p 多角形。３頂点以上の凸多角形でなければならない。
 * @param aabb AABB。
 */
function polygonToAABB(p, _aabb) {
    var aabb = {
        min: _aabb.min,
        max: _aabb.max,
        position: {
            x: (_aabb.max.x - _aabb.min.x) / 2,
            y: (_aabb.max.y - _aabb.min.y) / 2
        }
    };
    return gjk_1.gjkTest(p, gjk_1.supportPolygon, aabb, gjk_1.supportAABB);
}
exports.polygonToAABB = polygonToAABB;
/**
 * 多角形と直線の交差判定。
 *
 * @param p 多角形。３頂点以上の凸多角形でなければならない。
 * @param aabb AABB。
 */
function polygonToLine(p, line) {
    var n = new math_1.Vec2(line.direction).rotate90();
    var d = -n.dot(line.position);
    var vertices = p.vertices;
    var s0 = sign_1.sign(n.dot(vertices[0]) + d);
    if (s0 === 0) {
        return true;
    }
    for (var i = 1; i < vertices.length; i++) {
        var s = sign_1.sign(n.dot(vertices[i]) + d);
        if (s0 !== s) {
            return true;
        }
    }
    return false;
}
exports.polygonToLine = polygonToLine;
