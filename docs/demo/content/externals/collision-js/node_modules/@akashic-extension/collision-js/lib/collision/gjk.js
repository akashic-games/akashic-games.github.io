"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gjkTest = exports.supportAABB = exports.supportBox = exports.supportVec = exports.supportCircle = exports.supportSegment = exports.supportPolygon = void 0;
var math_1 = require("../math");
/**
 * 与えられた方向の最も遠い頂点を返す。
 *
 * @param vertices 頂点列。
 * @param dir 方向。
 * @returns 最も遠い頂点。
 */
function getFurthestVertex(vertices, dir) {
    var furthest = Number.NEGATIVE_INFINITY;
    var furthestVertex = { x: 0, y: 0 };
    for (var i = 0; i < vertices.length; i++) {
        var v = vertices[i];
        var distance = math_1.Vec2.dot(v, dir);
        if (distance > furthest) {
            furthest = distance;
            furthestVertex = v;
        }
    }
    return furthestVertex;
}
/**
 * ポリゴンのサポート関数。
 *
 * 頂点が無いポリゴンの時、原点を返す。
 *
 * @param p ポリゴン。
 * @param dir 方向ベクトル。
 * @returns dirの方向にある最も遠い頂点。
 */
function supportPolygon(p, dir) {
    return getFurthestVertex(p.vertices, dir);
}
exports.supportPolygon = supportPolygon;
/**
 * 線分のサポート関数。
 *
 * @param s: 線分。
 * @param dir 方向ベクトル。
 * @returns dirの方向にある最も遠い頂点。
 */
function supportSegment(s, dir) {
    return getFurthestVertex([s.position, s.endPosition], dir);
}
exports.supportSegment = supportSegment;
/**
 * 円のサポート関数。
 *
 * @param s: 線分。
 * @param dir 方向ベクトル。
 * @returns dirの方向にある最も遠い頂点。
 */
function supportCircle(c, _dir) {
    var dir = new math_1.Vec2(_dir).normalize();
    return getFurthestVertex([
        new math_1.Vec2(dir).scale(c.radius).add(c.position),
        new math_1.Vec2(dir).scale(-c.radius).add(c.position),
    ], dir);
}
exports.supportCircle = supportCircle;
/**
 * 点のサポート関数。
 *
 * @param v: 点の位置。
 * @param dir 方向ベクトル。
 * @returns dirの方向にある最も遠い頂点。
 */
function supportVec(v, dir) {
    return v.position;
}
exports.supportVec = supportVec;
/**
 * 矩形のサポート関数。
 *
 * @param b 矩形。
 * @param dir 方向ベクトル。
 * @returns dirの方向にある最も遠い頂点。
 */
function supportBox(b, dir) {
    var hx = b.halfExtend.x;
    var hy = b.halfExtend.y;
    var vertices = [
        { x: +hx, y: +hy },
        { x: -hx, y: +hy },
        { x: -hx, y: -hy },
        { x: +hx, y: -hy }
    ];
    var furthestVertex = getFurthestVertex(vertices, new math_1.Vec2(dir).rotate(-b.angle));
    return new math_1.Vec2(furthestVertex).rotate(b.angle).add(b.position);
}
exports.supportBox = supportBox;
/**
 * AABBのサポート関数。
 *
 * @param aabb AABB。
 * @param dir 方向ベクトル。
 * @returns dirの方向にある最も遠い頂点。
 */
function supportAABB(aabb, dir) {
    var minX = aabb.min.x;
    var minY = aabb.min.y;
    var maxX = aabb.max.x;
    var maxY = aabb.max.y;
    var vertices = [
        { x: maxX, y: maxY },
        { x: minX, y: maxY },
        { x: minX, y: minY },
        { x: maxX, y: minY },
    ];
    return getFurthestVertex(vertices, dir);
}
exports.supportAABB = supportAABB;
/**
 * ベクトル三重積。
 * 一般的な A x (B x C) でなく A x B x C であることに注意。
 *
 * @param a ベクトル。
 * @param b ベクトル。
 * @param c ベクトル。
 * @returns 三重積( a x b x c )。
 */
function tripleProduct(a, b, c) {
    var z = math_1.Vec2.cross(a, b);
    return {
        x: -z * c.y,
        y: z * c.x
    };
}
/**
 * サポートのミンコフスキー差を求め結果を頂点配列に加える。
 *
 * @param s1 シェイプ１。
 * @param sup1 シェイプ１のサポート関数。
 * @param s2 シェイプ２。
 * @param sup2 シェイプ２のサポート関数。
 * @param direction サポートを求める時の方向。
 * @param vertices 頂点配列。
 * @returns サポートの向きが direction と同じ時、真。
 */
function addSupport(s1, sup1, s2, sup2, direction, vertices) {
    var support = new math_1.Vec2(sup1(s1, direction))
        .sub(sup2(s2, new math_1.Vec2(direction).negate()));
    vertices.push(support);
    return math_1.Vec2.dot(direction, support) >= 0;
}
/**
 * シンプレックスを展開する。
 *
 * @param s1 シェイプ１。
 * @param sup1 シェイプ１のサポート関数。
 * @param s2 シェイプ２。
 * @param sup2 シェイプ２のサポート関数。
 * @param vertices 頂点配列。
 * @returns 展開状態。
 */
function evolveSimplex(s1, sup1, s2, sup2, vertices) {
    var direction;
    if (vertices.length === 0) {
        direction = new math_1.Vec2(s2.position).sub(s1.position);
    }
    else if (vertices.length === 1) {
        direction = new math_1.Vec2(s1.position).sub(s2.position);
    }
    else if (vertices.length === 2) {
        var b = vertices[1];
        var c = vertices[0];
        var cb = new math_1.Vec2(b).sub(c);
        var c0 = new math_1.Vec2(c).negate();
        direction = tripleProduct(cb, c0, cb);
    }
    else if (vertices.length === 3) {
        var a = vertices[2];
        var b = vertices[1];
        var c = vertices[0];
        var a0 = new math_1.Vec2(a).negate();
        var ab = new math_1.Vec2(b).sub(a);
        var ac = new math_1.Vec2(c).sub(a);
        var abPerp = new math_1.Vec2(tripleProduct(ac, ab, ab));
        if (abPerp.dot(a0) > 0) {
            vertices.splice(0, 1); // 頂点 c を削除。
            direction = abPerp;
        }
        else {
            var acPerp = new math_1.Vec2(tripleProduct(ab, ac, ac));
            if (acPerp.dot(a0) > 0) {
                vertices.splice(1, 1); // 頂点 b を削除。
                direction = acPerp;
            }
            else {
                return "found";
            }
        }
    }
    else {
        return "error";
    }
    return addSupport(s1, sup1, s2, sup2, direction, vertices) ?
        "evolving" :
        "no-intersection";
}
;
/**
 * GJKによる交差判定。
 *
 * @param s1 シェイプ1。
 * @param sup1 シェイプ1のサポート関数。
 * @param s2 シェイプ2。
 * @param sup2 シェイプ2のサポート関数。
 * @returns 交差している時、真。
 */
function gjkTest(s1, sup1, s2, sup2) {
    var vertices = [];
    var result;
    do {
        result = evolveSimplex(s1, sup1, s2, sup2, vertices);
    } while (result === "evolving");
    return result === "found";
}
exports.gjkTest = gjkTest;
