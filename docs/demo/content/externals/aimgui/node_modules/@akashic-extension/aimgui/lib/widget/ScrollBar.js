"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScrollBar = void 0;
var collision_js_1 = require("@akashic-extension/collision-js");
var colors_1 = require("./colors");
var sizes_1 = require("./sizes");
/**
 * スクロールバー。
 *
 * widget にスクロールバーのUIを提供するためのユーティティ。
 *
 * スクロールバーの形状（バーそのものやサムの大きさ、位置など）は widget のレイアウトから
 * 求められる。
 *
 * スクロールバー自体は widget ではない。
 *
 * 縦スクロールのみサポートする。
 */
var ScrollBar = /** @class */ (function () {
    function ScrollBar(param) {
        if (param === void 0) { param = {}; }
        this.scroll = 0;
        this.avoidsResizeThumb = !!param.avoidsResizeThumb;
    }
    /**
     * スクロール位置を変更する。
     *
     * @param layout レイアウト。
     * @param v スクロール量。
     */
    ScrollBar.prototype.scrollBy = function (scrollArea, v) {
        var shape = this.getShape(scrollArea);
        this.scroll = shape ? shape.addScroll(v) : 0;
    };
    ScrollBar.prototype.scrollTo = function (scrollArea, v) {
        var shape = this.getShape(scrollArea);
        if (shape) {
            this.scroll = Math.min(shape.max, Math.max(shape.min, v));
        }
    };
    ScrollBar.prototype.scrollToBottom = function (scrollArea) {
        var shape = this.getShape(scrollArea);
        if (shape) {
            this.scroll = shape.max;
        }
    };
    /**
     * スクロール操作が必要なレイアウトか調べる。
     *
     * @param layout レイアウト。
     * @returns スクロール操作が必要な時、真。
     */
    ScrollBar.prototype.inspectArea = function (scrollArea) {
        var bounds = scrollArea.contentBounds;
        var visibleArea = scrollArea.visibleArea;
        // コンテンツ表示領域内にコンテンツの境界が収まっているか。
        // 縦方向のみ判定。
        var inside = visibleArea.min.y <= bounds.min.y && bounds.max.y <= visibleArea.max.y;
        return !inside;
    };
    /**
     * サム(スクロール操作のためのつまみ)と点との交差判定。
     *
     * @param layout スクロールバーの形状を求めるためのレイアウト。
     * @param pos 点の座標。
     * @returns 交差している時、真。
     */
    ScrollBar.prototype.intersectThumb = function (scrollArea, pos) {
        var shape = this.getShape(scrollArea);
        return shape != null && collision_js_1.aabbToVec(shape.thumb, pos);
    };
    /**
     * スクロールバー(thumbを含む)と点との交差判定。
     *
     * @param layout スクロールバーの形状を求めるためのレイアウト。
     * @param pos 点の座標。
     * @returns 交差している時、真。
     */
    ScrollBar.prototype.intersectBar = function (scrollArea, pos) {
        var shape = this.getShape(scrollArea);
        return shape != null && collision_js_1.aabbToVec(shape.bar, pos);
    };
    /**
     * スクロールバーの形状の取得。
     *
     * @param layout 形状を決めるためのレイアウト。
     * @returns 形状。
     */
    ScrollBar.prototype.getShape = function (scrollArea) {
        var contentArea = scrollArea.contentBounds;
        var visibleArea = scrollArea.visibleArea;
        var visibleAreaH = visibleArea.max.y - visibleArea.min.y;
        var contentAreaH = contentArea.max.y - contentArea.min.y;
        if (visibleAreaH >= contentAreaH) {
            return null;
        }
        var scrollY = this.scroll;
        var resizeThumbH = this.avoidsResizeThumb ? sizes_1.sizes.resizeThumbH : 0;
        var maxScrollY = contentAreaH - visibleAreaH;
        var vScrollBarW = sizes_1.sizes.scrollBarW;
        // TODO: 計算方法を見直す
        // visibleArea のウインドウ内での位置(と大きさは)が必ずしも
        // ウインドウいっぱいに配置されたものでないので、単純にその高さから引き算
        // してもリサイズつまみを避けられるとは限らない。
        var vScrollBarH = visibleArea.max.y - visibleArea.min.y - resizeThumbH;
        var vScrollBarX = visibleArea.max.x;
        var vScrollBarY = visibleArea.min.y;
        if (vScrollBarH <= 0) {
            return null;
        }
        var thumbW = vScrollBarW - (3 * 2);
        var thumbH = visibleAreaH / contentAreaH * vScrollBarH; // 見えている範囲に比例した高さ。
        var thumbX = vScrollBarX + 3;
        var thumbY = vScrollBarY + scrollY / maxScrollY * (vScrollBarH - thumbH);
        return {
            min: 0,
            max: maxScrollY,
            bar: {
                min: { x: vScrollBarX, y: vScrollBarY },
                max: { x: vScrollBarX + vScrollBarW, y: vScrollBarY + vScrollBarH }
            },
            thumb: {
                min: { x: thumbX, y: thumbY },
                max: { x: thumbX + thumbW, y: thumbY + thumbH }
            },
            addScroll: function (dy) { return collision_js_1.clamp(dy / (vScrollBarH - thumbH) + (scrollY / maxScrollY), 0, 1) * maxScrollY; }
        };
    };
    /**
     * スクロールバーの描画。
     *
     * @param renderer レンダラー。
     * @param layout レイアウト。
     */
    ScrollBar.prototype.draw = function (renderer, scrollArea) {
        var shape = this.getShape(scrollArea);
        if (!shape) {
            return;
        }
        renderer.save();
        var bar = shape.bar;
        renderer.setOpacity(0.75);
        renderer.fillRect(bar.min.x, bar.min.y, bar.max.x - bar.min.x, bar.max.y - bar.min.y, colors_1.colors.scrollBarBg);
        renderer.restore();
        var thumb = shape.thumb;
        renderer.fillRect(thumb.min.x, thumb.min.y, thumb.max.x - thumb.min.x, thumb.max.y - thumb.min.y, colors_1.colors.scrollBarThumb);
    };
    return ScrollBar;
}());
exports.ScrollBar = ScrollBar;
