"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowE = void 0;
var collision_js_1 = require("@akashic-extension/collision-js");
var colors_1 = require("./colors");
var common_1 = require("./common");
var ScrollBar_1 = require("./ScrollBar");
var sizes_1 = require("./sizes");
var WidgetE_1 = require("./WidgetE");
var minWindowWidth = 64;
var maxWindowHeight = 64;
/**
 * Window E。
 */
var WindowE = /** @class */ (function (_super) {
    __extends(WindowE, _super);
    function WindowE(param) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        var _this = this;
        var style = (param.memory.data[param.gwid] || {});
        param.x = (_b = (_a = style.position) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : param.x;
        param.y = (_d = (_c = style.position) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : param.y;
        param.width = (_g = (_f = (_e = style.size) === null || _e === void 0 ? void 0 : _e.x) !== null && _f !== void 0 ? _f : param.width) !== null && _g !== void 0 ? _g : 320;
        param.height = (_k = (_j = (_h = style.size) === null || _h === void 0 ? void 0 : _h.y) !== null && _j !== void 0 ? _j : param.height) !== null && _k !== void 0 ? _k : 240;
        param.showTitleBar = (_l = style.titleBar) !== null && _l !== void 0 ? _l : param.showTitleBar;
        param.resizable = (_m = style.resizable) !== null && _m !== void 0 ? _m : param.resizable;
        param.scrollable = (_o = style.scrollable) !== null && _o !== void 0 ? _o : param.scrollable;
        _this = _super.call(this, param) || this;
        _this.font = param.font;
        _this.resizable = (_p = param.resizable) !== null && _p !== void 0 ? _p : true;
        _this.scrollable = (_q = param.scrollable) !== null && _q !== void 0 ? _q : true;
        _this.margin = (_r = param.margin) !== null && _r !== void 0 ? _r : 4;
        _this.titleBarHeight = ((_s = param.showTitleBar) !== null && _s !== void 0 ? _s : true) ? Math.round(_this.font.size * 1.25) : 0;
        _this.tracking = "none";
        _this.zOrder = 0;
        _this.cache = null;
        _this.startWidth = 0;
        _this.startHeight = 0;
        _this.scrollBar = new ScrollBar_1.ScrollBar({ avoidsResizeThumb: true });
        _this.bounds = {
            min: { x: 0, y: 0 },
            max: { x: 0, y: 0 }
        };
        _this.onPointDown.add(_this.handlePointDown, _this);
        _this.onPointMove.add(_this.handlePointMove, _this);
        _this.onPointUp.add(_this.handlePointUp, _this);
        return _this;
    }
    Object.defineProperty(WindowE.prototype, "cursorPosition", {
        get: function () {
            return {
                x: this.margin,
                y: this.titleBarHeight + this.margin - this.scrollBar.scroll
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WindowE.prototype, "contentArea", {
        get: function () {
            return {
                min: { x: this.margin, y: this.titleBarHeight + this.margin },
                max: {
                    x: this.width - (this.scrollable ? sizes_1.sizes.scrollBarW : this.margin),
                    y: this.height - this.margin
                }
            };
        },
        enumerable: false,
        configurable: true
    });
    WindowE.prototype.postRun = function () {
        this.scrollBar.scrollBy(this.getScrollArea(), 0);
        this.getStyle(this.getMemory());
        _super.prototype.postRun.call(this);
    };
    WindowE.prototype.renderSelf = function (renderer, _camera) {
        // タイトル。
        if (this.titleBarHeight > 0) {
            this.drawTitleBar(renderer);
        }
        // ウィンドウ背景。
        renderer.fillRect(0, this.titleBarHeight, this.width, this.height - this.titleBarHeight, colors_1.colors.windowBg);
        // ウィンドウ内の子要素をオフスクリーンに描画。
        this.renderChildren();
        // オフスクリーンをオンスクリーンへ描画。
        this.renderCache(renderer);
        if (this.scrollable) {
            if (this.scrollBar.inspectArea(this.getScrollArea()) || this.tracking === "thumb") {
                this.scrollBar.draw(renderer, this.getScrollArea());
            }
        }
        if (this.resizable) {
            this.drawResizeThumb(renderer);
        }
        // ウィンドウ枠。
        this.drawFrame(renderer, colors_1.colors.windowFrame);
        // DEBUG: レイアウトに関する領域を描画する。
        // this.drawLayout(renderer);
        // 子要素はオフスクリーンに描画したので、描画をここで止める。
        return false;
    };
    WindowE.prototype.shouldFindChildrenByPoint = function (point) {
        // 最前面にないウインドウの子要素のタッチを扱わない。
        // これによってウインドウ自体にタッチイベントが伝播し、
        // 背面のウインドウが全面に移動するようになる。
        if (this.zOrder !== 0) {
            return false;
        }
        var insideWindow = 0 < point.x && point.x < this.width &&
            this.titleBarHeight < point.y && point.y < this.height;
        var insideResizeThumb = this.width - 16 < point.x && point.x < this.width &&
            this.height - 16 < point.y && point.y < this.height;
        var insideScrollBar = this.scrollBar.intersectBar(this.getScrollArea(), point);
        return insideWindow && !insideResizeThumb && !insideScrollBar;
    };
    WindowE.prototype.getMemory = function () {
        var memory = _super.prototype.getMemory.call(this) || {};
        _super.prototype.setMemory.call(this, memory);
        return memory;
    };
    /**
     * 現在のウインドウのスタイルを取得する。
     *
     * @param style 現在のスタイルを反映されるオブジェクト。
     * @returns スタイル。 引数 style と同一のオブジェクト。
     */
    WindowE.prototype.getStyle = function (style) {
        var _a, _b;
        style.position = (_a = style.position) !== null && _a !== void 0 ? _a : { x: 0, y: 0 };
        collision_js_1.Vec2.copy(style.position, this);
        style.resizable = this.resizable;
        style.titleBar = this.titleBarHeight !== 0;
        style.size = (_b = style.size) !== null && _b !== void 0 ? _b : { x: 0, y: 0 };
        style.size.x = this.width;
        style.size.y = this.height;
        return style;
    };
    WindowE.prototype.getScrollArea = function () {
        return {
            visibleArea: this.contentArea,
            contentBounds: this.bounds
        };
    };
    WindowE.prototype.drawTitleBar = function (renderer) {
        // バー。
        renderer.fillRect(0, 0, this.width, this.titleBarHeight, colors_1.colors.windowTitleBarBg);
        // タイトル。
        common_1.drawText(renderer, this.font, common_1.limitText(this.font, this.title, this.width - this.margin * 2, ""), this.margin, 0);
    };
    WindowE.prototype.drawResizeThumb = function (renderer) {
        var aabb = this.getResizeAABB();
        var w = 3;
        var h = 3;
        var y = aabb.min.y + 1;
        for (var j = 0; j < 3; j++) {
            var x = aabb.min.x + 1;
            for (var i = 0; i < 3; i++) {
                renderer.fillRect(x, y, w, h, colors_1.colors.windowResizeThumb);
                x += w + 1;
            }
            y += h + 1;
        }
    };
    WindowE.prototype.renderChildren = function () {
        var _a;
        // クリッピングのためにサーフェスに描画する。
        // ここではウインドウ全体のうち、子要素が配置される領域を vrew area と呼ぶ。
        var viewAreaWidth = this.width;
        var viewAreaHeight = this.height - this.titleBarHeight;
        if (!this.cache ||
            this.cache.width !== viewAreaWidth ||
            this.cache.height !== viewAreaHeight) {
            (_a = this.cache) === null || _a === void 0 ? void 0 : _a.destroy();
            // widget 配置の目安となる領域は WindowE#contentArea だが、
            // そこからはみ出すことは許される。そのため、contentAreaではなく
            // window 自体の大きさに基づいてサーフェースの大きさを求める。
            this.cache = g.game.resourceFactory.createSurface(
            // 縦横幅は整数出なければならない。ウインドウリサイズで width,height を
            // 整数化しているが、念の為ここでもそうする。
            Math.round(viewAreaWidth), Math.round(viewAreaHeight));
        }
        var renderer = this.cache.renderer();
        renderer.begin();
        renderer.clear();
        if (this.children) {
            renderer.save();
            // 子要素はウインドウ左上を原点とする座標系に配置されている。
            // これから描画するサーフェスはタイトルバーの下にある view area に相当する
            // ので、原点がずれないようにタイトルバーの高さだけ高さだけ平行移動する。
            renderer.translate(0, -this.titleBarHeight);
            var children = this.children;
            for (var i = 0; i < children.length; i++) {
                children[i].render(renderer);
            }
            renderer.restore();
        }
        renderer.end();
    };
    WindowE.prototype.renderCache = function (renderer) {
        if (this.cache) {
            renderer.drawImage(this.cache, 0, 0, this.cache.width, this.cache.height, 0, this.titleBarHeight);
        }
    };
    WindowE.prototype.getResizeAABB = function () {
        return {
            min: {
                x: this.width - sizes_1.sizes.resizeThumbW,
                y: this.height - sizes_1.sizes.resizeThumbH
            },
            max: {
                x: this.width,
                y: this.height
            }
        };
    };
    WindowE.prototype.handlePointDown = function (ev) {
        if (ev.point.y < this.titleBarHeight) {
            this.tracking = "moving";
        }
        else {
            if (this.scrollBar.intersectThumb(this.getScrollArea(), ev.point)) {
                this.tracking = "thumb";
            }
            else if (this.resizable && collision_js_1.aabbToVec(this.getResizeAABB(), ev.point)) {
                this.tracking = "resizing";
                this.startWidth = this.width;
                this.startHeight = this.height;
            }
            else {
                this.tracking = "none";
            }
        }
    };
    WindowE.prototype.handlePointMove = function (ev) {
        if (this.tracking === "moving") {
            this.handleWindowMove(ev);
        }
        else if (this.scrollable && this.tracking === "thumb") {
            this.handleThumbMove(ev);
        }
        else if (this.resizable && this.tracking === "resizing") {
            this.handleResize(ev);
        }
    };
    WindowE.prototype.handlePointUp = function (_ev) {
        this.tracking = "none";
    };
    WindowE.prototype.handleWindowMove = function (ev) {
        collision_js_1.Vec2.add(this, ev.prevDelta);
        this.modified();
    };
    WindowE.prototype.handleThumbMove = function (ev) {
        this.scrollBar.scrollBy(this.getScrollArea(), ev.prevDelta.y);
        this.modified();
    };
    WindowE.prototype.handleResize = function (ev) {
        // 自身の大きさを更新。
        // width, height は surface の生成に用いられる。そのため整数でなければならない。
        this.width = Math.round(Math.max(minWindowWidth, this.startWidth + ev.startDelta.x));
        this.height = Math.round(Math.max(maxWindowHeight, this.startHeight + ev.startDelta.y));
        this.scrollBar.scrollBy(this.getScrollArea(), 0);
        this.modified();
    };
    return WindowE;
}(WidgetE_1.WidgetE));
exports.WindowE = WindowE;
