"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mat33 = void 0;
var Vec2_1 = require("./Vec2");
var Vec3_1 = require("./Vec3");
/**
 * 3x3行列。
 */
var Mat33 = /** @class */ (function () {
    /**
     * コンストラクタ。
     *
     * @param ex 第一列。省略時 (1, 0, 0)。
     * @param ey 第二列。省略時 (0, 1, 0)。
     * @param ez 第三列。省略時 (0, 0, 1)。
     */
    function Mat33(ex, ey, ez) {
        this.ex = new Vec3_1.Vec3(ex || { x: 1, y: 0, z: 0 });
        this.ey = new Vec3_1.Vec3(ey || { x: 0, y: 1, z: 0 });
        this.ez = new Vec3_1.Vec3(ez || { x: 0, y: 0, z: 1 });
    }
    /**
     * スケール行列を作成する。
     *
     * @param scale スケール行列。
     */
    Mat33.makeScale = function (scale) {
        return new Mat33({ x: scale.x, y: 0, z: 0 }, { x: 0, y: scale.y, z: 0 }, { x: 0, y: 0, z: scale.z });
    };
    /**
     * 複製する。
     */
    Mat33.prototype.clone = function () {
        return new Mat33(this.ex, this.ey, this.ez);
    };
    /**
     * 比較する。
     *
     * 行列が等しい時、真。
     *
     * @param m 比較する行列。
     */
    Mat33.prototype.equal = function (m) {
        return this.ex.equal(m.ex) && this.ey.equal(m.ey) && this.ez.equal(m.ez);
    };
    /**
     * 行列を乗算する。
     *
     * @param m 行列。
     */
    Mat33.prototype.mul = function (m) {
        var m11 = this.ex.x * m.ex.x + this.ey.x * m.ex.y + this.ez.x * m.ex.z;
        var m21 = this.ex.y * m.ex.x + this.ey.y * m.ex.y + this.ez.y * m.ex.z;
        var m31 = this.ex.z * m.ex.x + this.ey.z * m.ex.y + this.ez.z * m.ex.z;
        var m12 = this.ex.x * m.ey.x + this.ey.x * m.ey.y + this.ez.x * m.ey.z;
        var m22 = this.ex.y * m.ey.x + this.ey.y * m.ey.y + this.ez.y * m.ey.z;
        var m32 = this.ex.z * m.ey.x + this.ey.z * m.ey.y + this.ez.z * m.ey.z;
        var m13 = this.ex.x * m.ez.x + this.ey.x * m.ez.y + this.ez.x * m.ez.z;
        var m23 = this.ex.y * m.ez.x + this.ey.y * m.ez.y + this.ez.y * m.ez.z;
        var m33 = this.ex.z * m.ez.x + this.ey.z * m.ez.y + this.ez.z * m.ez.z;
        this.ex.x = m11;
        this.ex.y = m21;
        this.ex.z = m31;
        this.ey.x = m12;
        this.ey.y = m22;
        this.ey.z = m32;
        this.ez.x = m13;
        this.ez.y = m23;
        this.ez.z = m33;
        return this;
    };
    /**
     * 行列式を求める。
     */
    Mat33.prototype.determinant = function () {
        var m00 = this.ex.x;
        var m01 = this.ey.x;
        var m02 = this.ez.x;
        var m10 = this.ex.y;
        var m11 = this.ey.y;
        var m12 = this.ez.y;
        var m20 = this.ex.z;
        var m21 = this.ey.z;
        var m22 = this.ez.z;
        var det01 = m22 * m11 - m12 * m21;
        var det11 = -m22 * m10 + m12 * m20;
        var det21 = m21 * m10 - m11 * m20;
        return m00 * det01 + m01 * det11 + m02 * det21;
    };
    /**
     * 転置行列にする。
     */
    Mat33.prototype.transpose = function () {
        var tmp1 = this.ey.x;
        var tmp2 = this.ez.x;
        var tmp3 = this.ez.y;
        this.ey.x = this.ex.y;
        this.ez.x = this.ex.z;
        this.ez.y = this.ey.z;
        this.ex.y = tmp1;
        this.ex.z = tmp2;
        this.ey.z = tmp3;
        return this;
    };
    /**
     * 逆行列にする。
     *
     * 逆行列が存在しない時 null 。
     */
    Mat33.prototype.inverse = function () {
        var det = this.determinant();
        if (det === 0) {
            return null;
        }
        var m00 = this.ex.x;
        var m01 = this.ey.x;
        var m02 = this.ez.x;
        var m10 = this.ex.y;
        var m11 = this.ey.y;
        var m12 = this.ez.y;
        var m20 = this.ex.z;
        var m21 = this.ey.z;
        var m22 = this.ez.z;
        this.ex.x = (m11 * m22 - m12 * m21) / det;
        this.ex.y = -(m10 * m22 - m12 * m20) / det;
        this.ex.z = (m10 * m21 - m11 * m20) / det;
        this.ey.x = -(m01 * m22 - m02 * m21) / det;
        this.ey.y = (m00 * m22 - m02 * m20) / det;
        this.ey.z = -(m00 * m21 - m01 * m20) / det;
        this.ez.x = (m01 * m12 - m02 * m11) / det;
        this.ez.y = -(m00 * m12 - m02 * m10) / det;
        this.ez.z = (m00 * m11 - m01 * m10) / det;
        return this;
    };
    /**
     * 単位行列にする。
     */
    Mat33.prototype.setIdentity = function () {
        this.ex.x = 1;
        this.ex.y = 0;
        this.ex.z = 0;
        this.ey.x = 0;
        this.ey.y = 1;
        this.ey.z = 0;
        this.ez.x = 0;
        this.ez.y = 0;
        this.ez.z = 1;
        return this;
    };
    /**
     * Z軸回転する。
     *
     * @param angle 回転の角度[rad]。
     */
    Mat33.prototype.rotateZ = function (angle) {
        var m11 = this.ex.x;
        var m21 = this.ex.y;
        var m12 = this.ey.x;
        var m22 = this.ey.y;
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.ex.x = c * m11 - s * m21;
        this.ex.y = s * m11 + c * m21;
        this.ey.x = c * m12 - s * m22;
        this.ey.y = s * m12 + c * m22;
        return this;
    };
    /**
     * スケールする。
     *
     * @param scale スケール。
     */
    Mat33.prototype.scale = function (scale) {
        var m11 = this.ex.x;
        var m21 = this.ex.y;
        var m31 = this.ex.z;
        var m12 = this.ey.x;
        var m22 = this.ey.y;
        var m32 = this.ey.z;
        var m13 = this.ez.x;
        var m23 = this.ez.y;
        var m33 = this.ez.z;
        var sx = scale.x;
        var sy = scale.y;
        var sz = scale.z;
        this.ex.x = sx * m11;
        this.ex.y = sy * m21;
        this.ex.z = sz * m31;
        this.ey.x = sx * m12;
        this.ey.y = sy * m22;
        this.ey.z = sz * m32;
        this.ez.x = sx * m13;
        this.ez.y = sy * m23;
        this.ez.z = sz * m33;
        return this;
    };
    /**
     * 平行移動する。
     *
     * @param t 平行移動量。
     */
    Mat33.prototype.translate = function (t) {
        this.ez.x += t.x;
        this.ez.y += t.y;
        this.ez.z += t.z;
        return this;
    };
    /**
     * 平行移動量を設定する。
     *
     * @param t 平行移動量。
     */
    Mat33.prototype.setTranslate = function (t) {
        this.ez.x = t.x;
        this.ez.y = t.y;
        this.ez.z = t.z;
        return this;
    };
    Mat33.prototype.mulVec2 = function (v, out) {
        var x = this.ex.x * v.x + this.ey.x * v.y + this.ez.x;
        var y = this.ex.y * v.x + this.ey.y * v.y + this.ez.y;
        if (out) {
            out.x = x;
            out.y = y;
            return out;
        }
        else {
            return new Vec2_1.Vec2(x, y);
        }
    };
    Mat33.prototype.mulVec3 = function (v, out) {
        var x = this.ex.x * v.x + this.ey.x * v.y + this.ez.x * v.z;
        var y = this.ex.y * v.x + this.ey.y * v.y + this.ez.y * v.z;
        var z = this.ex.z * v.x + this.ey.z * v.y + this.ez.z * v.z;
        if (out) {
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        }
        else {
            return new Vec3_1.Vec3(x, y, z);
        }
    };
    /**
     * 単位ベクトル。
     */
    Mat33.identity = Object.freeze(new Mat33());
    return Mat33;
}());
exports.Mat33 = Mat33;
