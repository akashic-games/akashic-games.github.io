"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * RPGのマップなどで利用される、マップチップとタイルデータによるパターン描画を行うエンティティ。
 */
var Tile = /** @class */ (function (_super) {
    __extends(Tile, _super);
    /**
     * 各種パラメータを指定して `Tile` のインスタンスを生成する。
     *
     * @param param このエンティティに指定するパラメータ
     */
    function Tile(param) {
        var _this = _super.call(this, param) || this;
        _this.tileWidth = param.tileWidth;
        _this.tileHeight = param.tileHeight;
        _this.tileData = param.tileData;
        _this.tileChips = g.SurfaceUtil.asSurface(param.src);
        _this.height = _this.tileHeight * _this.tileData.length;
        _this.width = _this.tileWidth * _this.tileData[0].length;
        _this._invalidateSelf();
        _this.redrawArea = param.redrawArea;
        _this._drawnTileData = undefined;
        return _this;
    }
    /**
     * このエンティティ自身の描画を行う。
     * このメソッドはエンジンから暗黙に呼び出され、ゲーム開発者が呼び出す必要はない。
     */
    Tile.prototype.renderSelf = function (renderer, camera) {
        if (this._renderedCamera !== camera) {
            this.state &= ~2 /* Cached */;
            this._renderedCamera = camera;
        }
        if (!(this.state & 2 /* Cached */)) {
            var isNew = !this._cache || this._cache.width < Math.ceil(this.width) || this._cache.height < Math.ceil(this.height);
            if (isNew) {
                if (this._cache && !this._cache.destroyed()) {
                    this._cache.destroy();
                }
                this._cache = this.scene.game.resourceFactory.createSurface(Math.ceil(this.width), Math.ceil(this.height));
                this._renderer = this._cache.renderer();
                this._drawnTileData = [];
                for (var y = 0; y < this.tileData.length; ++y) {
                    this._drawnTileData[y] = [];
                    for (var x = 0; x < this.tileData[y].length; ++x) {
                        this._drawnTileData[y][x] = -1;
                    }
                }
            }
            this._renderer.begin();
            // `CacheableE#renderSelf()` ではここで `this._renderer.clear()` を呼び出すが、
            // `Tile` は `this._cache` の描画状態を再利用するので `this._renderer.clear()` を呼び出す必要はない。
            this.renderCache(this._renderer);
            this.state |= 2 /* Cached */;
            this._renderer.end();
        }
        if (this._cache && this.width > 0 && this.height > 0) {
            renderer.drawImage(this._cache, 0, 0, this.width, this.height, 0, 0);
        }
        return this._shouldRenderChildren;
    };
    Tile.prototype.renderCache = function (renderer) {
        if (!this.tileData)
            throw g.ExceptionFactory.createAssertionError("Tile#_renderCache: don't have a tile data");
        if (this.tileWidth <= 0 || this.tileHeight <= 0) {
            return;
        }
        renderer.save();
        for (var y = 0; y < this.tileData.length; ++y) {
            var row = this.tileData[y];
            for (var x = 0; x < row.length; ++x) {
                var tile = row[x];
                if (tile < 0) {
                    continue;
                }
                if (this._drawnTileData[y] !== undefined) {
                    if (this._drawnTileData[y][x] === tile) {
                        continue;
                    }
                }
                var tileX = this.tileWidth * (tile % this._tilesInRow);
                var tileY = this.tileHeight * Math.floor(tile / this._tilesInRow);
                var dx = this.tileWidth * x;
                var dy = this.tileHeight * y;
                if (this.redrawArea !== undefined) {
                    if (dx + this.tileWidth < this.redrawArea.x || dx >= this.redrawArea.x + this.redrawArea.width ||
                        dy + this.tileHeight < this.redrawArea.y || dy >= this.redrawArea.y + this.redrawArea.height) {
                        continue;
                    }
                }
                renderer.setCompositeOperation("destination-out");
                renderer.fillRect(dx, dy, this.tileWidth, this.tileHeight, "silver"); // DestinationOutなので色はなんでも可
                renderer.setCompositeOperation("source-over");
                renderer.drawImage(this.tileChips, tileX, tileY, this.tileWidth, this.tileHeight, dx, dy);
                this._drawnTileData[y][x] = this.tileData[y][x];
            }
        }
        renderer.restore();
    };
    Tile.prototype.invalidate = function () {
        this._invalidateSelf();
        _super.prototype.invalidate.call(this);
    };
    /**
     * このエンティティを破棄する。
     * デフォルトでは利用しているマップチップの `Surface` `Surface` の破棄は行わない点に注意。
     * @param destroySurface trueを指定した場合、このエンティティが抱えるマップチップの `Surface` も合わせて破棄する
     */
    Tile.prototype.destroy = function (destroySurface) {
        if (destroySurface && this.tileChips && !this.tileChips.destroyed()) {
            this.tileChips.destroy();
        }
        this.tileChips = undefined;
        _super.prototype.destroy.call(this);
    };
    Tile.prototype._invalidateSelf = function () {
        this._tilesInRow = Math.floor(this.tileChips.width / this.tileWidth);
    };
    return Tile;
}(g.CacheableE));
module.exports = Tile;
