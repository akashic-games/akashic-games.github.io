<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>simpleshot - Akashic</title>
<script>
	require = function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
    return s;
}({
    "@akashic/akashic-engine": [ function(require, module, exports) {
        (function() {
            "use strict";
            var g, __extends = this && this.__extends || function(d, b) {
                function __() {
                    this.constructor = d;
                }
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
                d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
            !function(g) {
                var AssetLoadErrorType;
                !function(AssetLoadErrorType) {
                    AssetLoadErrorType[AssetLoadErrorType.Unspecified = 0] = "Unspecified", AssetLoadErrorType[AssetLoadErrorType.RetryLimitExceeded = 1] = "RetryLimitExceeded", 
                    AssetLoadErrorType[AssetLoadErrorType.NetworkError = 2] = "NetworkError", AssetLoadErrorType[AssetLoadErrorType.ClientError = 3] = "ClientError", 
                    AssetLoadErrorType[AssetLoadErrorType.ServerError = 4] = "ServerError";
                }(AssetLoadErrorType = g.AssetLoadErrorType || (g.AssetLoadErrorType = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var ExceptionFactory;
                !function(ExceptionFactory) {
                    function createPureVirtualError(methodName, cause) {
                        var e = new Error(methodName + " has no implementation.");
                        return e.name = "PureVirtualError", e.cause = cause, e;
                    }
                    function createAssertionError(message, cause) {
                        var e = new Error(message);
                        return e.name = "AssertionError", e.cause = cause, e;
                    }
                    function createTypeMismatchError(methodName, expected, actual, cause) {
                        var message = "Type mismatch on " + methodName + ", expected type is " + expected;
                        if (arguments.length > 2) try {
                            var actualString;
                            actualString = actual && actual.constructor && actual.constructor.name ? actual.constructor.name : typeof actual, 
                            message += ", actual type is " + (actualString.length > 40 ? actualString.substr(0, 40) : actualString);
                        } catch (ex) {}
                        message += ".";
                        var e = new Error(message);
                        return e.name = "TypeMismatchError", e.cause = cause, e.expected = expected, e.actual = actual, 
                        e;
                    }
                    function createAssetLoadError(message, retriable, type, cause) {
                        void 0 === retriable && (retriable = !0), void 0 === type && (type = g.AssetLoadErrorType.Unspecified);
                        var e = new Error(message);
                        return e.name = "AssetLoadError", e.cause = cause, e.retriable = retriable, e.type = type, 
                        e;
                    }
                    ExceptionFactory.createPureVirtualError = createPureVirtualError, ExceptionFactory.createAssertionError = createAssertionError, 
                    ExceptionFactory.createTypeMismatchError = createTypeMismatchError, ExceptionFactory.createAssetLoadError = createAssetLoadError;
                }(ExceptionFactory = g.ExceptionFactory || (g.ExceptionFactory = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var ResourceFactory = function() {
                    function ResourceFactory() {}
                    return ResourceFactory.prototype.createImageAsset = function(id, assetPath, width, height) {
                        throw g.ExceptionFactory.createPureVirtualError("ResourceFactory#createImageAsset");
                    }, ResourceFactory.prototype.createVideoAsset = function(id, assetPath, width, height, system, loop, useRealSize) {
                        throw g.ExceptionFactory.createPureVirtualError("ResourceFactory#createVideoAsset");
                    }, ResourceFactory.prototype.createAudioAsset = function(id, assetPath, duration, system, loop, hint) {
                        throw g.ExceptionFactory.createPureVirtualError("ResourceFactory#createAudioAsset");
                    }, ResourceFactory.prototype.createTextAsset = function(id, assetPath) {
                        throw g.ExceptionFactory.createPureVirtualError("ResourceFactory#createTextAsset");
                    }, ResourceFactory.prototype.createAudioPlayer = function(system) {
                        throw g.ExceptionFactory.createPureVirtualError("ResourceFactory#createAudioPlayer");
                    }, ResourceFactory.prototype.createScriptAsset = function(id, assetPath) {
                        throw g.ExceptionFactory.createPureVirtualError("ResourceFactory#createScriptAsset");
                    }, ResourceFactory.prototype.createSurface = function(width, height) {
                        throw g.ExceptionFactory.createPureVirtualError("ResourceFactory#createSurface");
                    }, ResourceFactory.prototype.createGlyphFactory = function(fontFamily, fontSize, baselineHeight, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
                        throw g.ExceptionFactory.createPureVirtualError("ResourceFactory#createGlphFactory");
                    }, ResourceFactory.prototype.createSurfaceAtlas = function(width, height) {
                        return new g.SurfaceAtlas(this.createSurface(width, height));
                    }, ResourceFactory;
                }();
                g.ResourceFactory = ResourceFactory;
            }(g || (g = {}));
            var g;
            !function(g) {
                var RequireCachedValue = function() {
                    function RequireCachedValue(value) {
                        this._value = value;
                    }
                    return RequireCachedValue.prototype._cachedValue = function() {
                        return this._value;
                    }, RequireCachedValue;
                }();
                g.RequireCachedValue = RequireCachedValue;
            }(g || (g = {}));
            var g;
            !function(g) {
                var RandomGenerator = function() {
                    function RandomGenerator(seed) {
                        this.seed = seed;
                    }
                    return RandomGenerator.prototype.get = function(min, max) {
                        throw g.ExceptionFactory.createPureVirtualError("RandomGenerator#get");
                    }, RandomGenerator.prototype.serialize = function() {
                        throw g.ExceptionFactory.createPureVirtualError("RandomGenerator#serialize");
                    }, RandomGenerator;
                }();
                g.RandomGenerator = RandomGenerator;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Asset = function() {
                    function Asset(id, path) {
                        this.id = id, this.originalPath = path, this.path = this._assetPathFilter(path);
                    }
                    return Asset.prototype.destroy = function() {
                        this.id = void 0, this.originalPath = void 0, this.path = void 0;
                    }, Asset.prototype.destroyed = function() {
                        return void 0 === this.id;
                    }, Asset.prototype.inUse = function() {
                        return !1;
                    }, Asset.prototype._load = function(loader) {
                        throw g.ExceptionFactory.createPureVirtualError("Asset#_load");
                    }, Asset.prototype._assetPathFilter = function(path) {
                        return path;
                    }, Asset;
                }();
                g.Asset = Asset;
                var ImageAsset = function(_super) {
                    function ImageAsset(id, assetPath, width, height) {
                        var _this = _super.call(this, id, assetPath) || this;
                        return _this.width = width, _this.height = height, _this;
                    }
                    return __extends(ImageAsset, _super), ImageAsset.prototype.asSurface = function() {
                        throw g.ExceptionFactory.createPureVirtualError("ImageAsset#asSurface");
                    }, ImageAsset;
                }(Asset);
                g.ImageAsset = ImageAsset;
                var VideoAsset = function(_super) {
                    function VideoAsset(id, assetPath, width, height, system, loop, useRealSize) {
                        var _this = _super.call(this, id, assetPath, width, height) || this;
                        return _this.realWidth = 0, _this.realHeight = 0, _this._system = system, _this._loop = loop, 
                        _this._useRealSize = useRealSize, _this;
                    }
                    return __extends(VideoAsset, _super), VideoAsset.prototype.asSurface = function() {
                        throw g.ExceptionFactory.createPureVirtualError("VideoAsset#asSurface");
                    }, VideoAsset.prototype.play = function(loop) {
                        return this.getPlayer().play(this), this.getPlayer();
                    }, VideoAsset.prototype.stop = function() {
                        this.getPlayer().stop();
                    }, VideoAsset.prototype.getPlayer = function() {
                        throw g.ExceptionFactory.createPureVirtualError("VideoAsset#getPlayer");
                    }, VideoAsset.prototype.destroy = function() {
                        this._system = void 0, _super.prototype.destroy.call(this);
                    }, VideoAsset;
                }(ImageAsset);
                g.VideoAsset = VideoAsset;
                var AudioAsset = function(_super) {
                    function AudioAsset(id, assetPath, duration, system, loop, hint) {
                        var _this = _super.call(this, id, assetPath) || this;
                        return _this.duration = duration, _this.loop = loop, _this.hint = hint, _this._system = system, 
                        _this.data = void 0, _this;
                    }
                    return __extends(AudioAsset, _super), AudioAsset.prototype.play = function() {
                        var player = this._system.createPlayer();
                        return player.play(this), player;
                    }, AudioAsset.prototype.stop = function() {
                        for (var players = this._system.findPlayers(this), i = 0; i < players.length; ++i) players[i].stop();
                    }, AudioAsset.prototype.inUse = function() {
                        return this._system.findPlayers(this).length > 0;
                    }, AudioAsset.prototype.destroy = function() {
                        this._system && this.stop(), this.data = void 0, this._system = void 0, _super.prototype.destroy.call(this);
                    }, AudioAsset;
                }(Asset);
                g.AudioAsset = AudioAsset;
                var TextAsset = function(_super) {
                    function TextAsset(id, assetPath) {
                        var _this = _super.call(this, id, assetPath) || this;
                        return _this.data = void 0, _this;
                    }
                    return __extends(TextAsset, _super), TextAsset.prototype.destroy = function() {
                        this.data = void 0, _super.prototype.destroy.call(this);
                    }, TextAsset;
                }(Asset);
                g.TextAsset = TextAsset;
                var ScriptAsset = function(_super) {
                    function ScriptAsset() {
                        return null !== _super && _super.apply(this, arguments) || this;
                    }
                    return __extends(ScriptAsset, _super), ScriptAsset.prototype.execute = function(execEnv) {
                        throw g.ExceptionFactory.createPureVirtualError("ScriptAsset#execute");
                    }, ScriptAsset.prototype.destroy = function() {
                        this.script = void 0, _super.prototype.destroy.call(this);
                    }, ScriptAsset;
                }(Asset);
                g.ScriptAsset = ScriptAsset;
            }(g || (g = {}));
            var g;
            !function(g) {
                function normalizeAudioSystemConfMap(confMap) {
                    confMap = confMap || {};
                    var systemDefaults = {
                        music: {
                            loop: !0,
                            hint: {
                                streaming: !0
                            }
                        },
                        sound: {
                            loop: !1,
                            hint: {
                                streaming: !1
                            }
                        }
                    };
                    for (var key in systemDefaults) key in confMap || (confMap[key] = systemDefaults[key]);
                    return confMap;
                }
                var AssetLoadingInfo = function() {
                    function AssetLoadingInfo(asset, handler) {
                        this.asset = asset, this.handlers = [ handler ], this.errorCount = 0, this.loading = !1;
                    }
                    return AssetLoadingInfo;
                }(), AssetManager = function() {
                    function AssetManager(game, conf, audioSystemConfMap) {
                        this.game = game, this.configuration = this._normalize(conf || {}, normalizeAudioSystemConfMap(audioSystemConfMap)), 
                        this._assets = {}, this._liveAssetVirtualPathTable = {}, this._liveAbsolutePathTable = {}, 
                        this._refCounts = {}, this._loadings = {};
                    }
                    return AssetManager.prototype.destroy = function() {
                        for (var assetIds = Object.keys(this._refCounts), i = 0; i < assetIds.length; ++i) this._releaseAsset(assetIds[i]);
                        this.game = void 0, this.configuration = void 0, this._assets = void 0, this._liveAssetVirtualPathTable = void 0, 
                        this._liveAbsolutePathTable = void 0, this._refCounts = void 0, this._loadings = void 0;
                    }, AssetManager.prototype.destroyed = function() {
                        return void 0 === this.game;
                    }, AssetManager.prototype.retryLoad = function(asset) {
                        if (!this._loadings.hasOwnProperty(asset.id)) throw g.ExceptionFactory.createAssertionError("AssetManager#retryLoad: invalid argument.");
                        var loadingInfo = this._loadings[asset.id];
                        if (loadingInfo.errorCount > AssetManager.MAX_ERROR_COUNT) {
                            if (!this.configuration[asset.id]) return;
                            throw g.ExceptionFactory.createAssertionError("AssetManager#retryLoad: too many retrying.");
                        }
                        loadingInfo.loading || (loadingInfo.loading = !0, asset._load(this));
                    }, AssetManager.prototype.globalAssetIds = function() {
                        var ret = [], conf = this.configuration;
                        for (var p in conf) conf.hasOwnProperty(p) && conf[p].global && ret.push(p);
                        return ret;
                    }, AssetManager.prototype.requestAsset = function(assetIdOrConf, handler) {
                        var loadingInfo, assetId = "string" == typeof assetIdOrConf ? assetIdOrConf : assetIdOrConf.id, waiting = !1;
                        if (this._assets.hasOwnProperty(assetId)) ++this._refCounts[assetId], handler._onAssetLoad(this._assets[assetId]); else if (this._loadings.hasOwnProperty(assetId)) loadingInfo = this._loadings[assetId], 
                        loadingInfo.handlers.push(handler), ++this._refCounts[assetId], waiting = !0; else {
                            var a = this._createAssetFor(assetIdOrConf);
                            loadingInfo = new AssetLoadingInfo(a, handler), this._loadings[assetId] = loadingInfo, 
                            this._refCounts[assetId] = 1, waiting = !0, loadingInfo.loading = !0, a._load(this);
                        }
                        return waiting;
                    }, AssetManager.prototype.unrefAsset = function(assetOrId) {
                        var assetId = "string" == typeof assetOrId ? assetOrId : assetOrId.id;
                        --this._refCounts[assetId] > 0 || this._releaseAsset(assetId);
                    }, AssetManager.prototype.requestAssets = function(assetIdOrConfs, handler) {
                        for (var waitingCount = 0, i = 0, len = assetIdOrConfs.length; i < len; ++i) this.requestAsset(assetIdOrConfs[i], handler) && ++waitingCount;
                        return waitingCount;
                    }, AssetManager.prototype.unrefAssets = function(assetOrIds) {
                        for (var i = 0, len = assetOrIds.length; i < len; ++i) this.unrefAsset(assetOrIds[i]);
                    }, AssetManager.prototype._normalize = function(configuration, audioSystemConfMap) {
                        var ret = {};
                        if (!(configuration instanceof Object)) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: invalid arguments.");
                        for (var p in configuration) if (configuration.hasOwnProperty(p)) {
                            var conf = Object.create(configuration[p]);
                            if (!conf.path) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: No path given for: " + p);
                            if (!conf.virtualPath) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: No virtualPath given for: " + p);
                            if (!conf.type) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: No type given for: " + p);
                            if ("image" === conf.type) {
                                if ("number" != typeof conf.width) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: wrong width given for the image asset: " + p);
                                if ("number" != typeof conf.height) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: wrong height given for the image asset: " + p);
                            }
                            if ("audio" === conf.type) {
                                void 0 === conf.duration && (conf.duration = 0);
                                var audioSystemConf = audioSystemConfMap[conf.systemId];
                                void 0 === conf.loop && (conf.loop = !!audioSystemConf && !!audioSystemConf.loop), 
                                void 0 === conf.hint && (conf.hint = audioSystemConf ? audioSystemConf.hint : {});
                            }
                            if ("video" === conf.type && !conf.useRealSize) {
                                if ("number" != typeof conf.width) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: wrong width given for the video asset: " + p);
                                if ("number" != typeof conf.height) throw g.ExceptionFactory.createAssertionError("AssetManager#_normalize: wrong height given for the video asset: " + p);
                                conf.useRealSize = !1;
                            }
                            conf.global || (conf.global = !1), ret[p] = conf;
                        }
                        return ret;
                    }, AssetManager.prototype._createAssetFor = function(idOrConf) {
                        var id, uri, conf;
                        if ("string" == typeof idOrConf) id = idOrConf, conf = this.configuration[id], uri = this.configuration[id].path; else {
                            var dynConf = idOrConf;
                            id = dynConf.id, conf = dynConf, uri = dynConf.uri;
                        }
                        var resourceFactory = this.game.resourceFactory;
                        if (!conf) throw g.ExceptionFactory.createAssertionError("AssetManager#_createAssetFor: unknown asset ID: " + id);
                        switch (conf.type) {
                          case "image":
                            return resourceFactory.createImageAsset(id, uri, conf.width, conf.height);

                          case "audio":
                            var system = conf.systemId ? this.game.audio[conf.systemId] : this.game.audio[this.game.defaultAudioSystemId];
                            return resourceFactory.createAudioAsset(id, uri, conf.duration, system, conf.loop, conf.hint);

                          case "text":
                            return resourceFactory.createTextAsset(id, uri);

                          case "script":
                            return resourceFactory.createScriptAsset(id, uri);

                          case "video":
                            return resourceFactory.createVideoAsset(id, uri, conf.width, conf.height, new g.VideoSystem(), conf.loop, conf.useRealSize);

                          default:
                            throw g.ExceptionFactory.createAssertionError("AssertionError#_createAssetFor: unknown asset type " + conf.type + " for asset ID: " + id);
                        }
                    }, AssetManager.prototype._releaseAsset = function(assetId) {
                        var path, asset = this._assets[assetId] || this._loadings[assetId] && this._loadings[assetId].asset;
                        if (asset) if (path = asset.path, asset.inUse()) if (asset instanceof g.AudioAsset) asset._system.requestDestroy(asset); else {
                            if (!(asset instanceof g.VideoAsset)) throw g.ExceptionFactory.createAssertionError("AssetManager#unrefAssets: Unsupported in-use " + asset.constructor.name);
                            asset.destroy();
                        } else asset.destroy();
                        if (delete this._refCounts[assetId], delete this._loadings[assetId], delete this._assets[assetId], 
                        this.configuration[assetId]) {
                            var virtualPath = this.configuration[assetId].virtualPath;
                            virtualPath && this._liveAssetVirtualPathTable.hasOwnProperty(virtualPath) && delete this._liveAssetVirtualPathTable[virtualPath], 
                            path && this._liveAbsolutePathTable.hasOwnProperty(path) && delete this._liveAbsolutePathTable[path];
                        }
                    }, AssetManager.prototype._countLoadingAsset = function() {
                        return Object.keys(this._loadings).length;
                    }, AssetManager.prototype._onAssetError = function(asset, error) {
                        if (!this.destroyed() && !asset.destroyed()) {
                            var loadingInfo = this._loadings[asset.id], hs = loadingInfo.handlers;
                            loadingInfo.loading = !1, ++loadingInfo.errorCount, loadingInfo.errorCount > AssetManager.MAX_ERROR_COUNT && error.retriable && (error = g.ExceptionFactory.createAssetLoadError("Retry limit exceeded", !1, g.AssetLoadErrorType.RetryLimitExceeded, error)), 
                            error.retriable || delete this._loadings[asset.id];
                            for (var i = 0; i < hs.length; ++i) hs[i]._onAssetError(asset, error, this);
                        }
                    }, AssetManager.prototype._onAssetLoad = function(asset) {
                        if (!this.destroyed() && !asset.destroyed()) {
                            var loadingInfo = this._loadings[asset.id];
                            if (loadingInfo.loading = !1, delete this._loadings[asset.id], this._assets[asset.id] = asset, 
                            this.configuration[asset.id]) {
                                var virtualPath = this.configuration[asset.id].virtualPath;
                                if (this._liveAssetVirtualPathTable.hasOwnProperty(virtualPath)) {
                                    if (this._liveAssetVirtualPathTable[virtualPath].path !== asset.path) throw g.ExceptionFactory.createAssertionError("AssetManager#_onAssetLoad(): duplicated asset path");
                                } else this._liveAssetVirtualPathTable[virtualPath] = asset;
                                this._liveAbsolutePathTable.hasOwnProperty(asset.path) || (this._liveAbsolutePathTable[asset.path] = virtualPath);
                            }
                            for (var hs = loadingInfo.handlers, i = 0; i < hs.length; ++i) hs[i]._onAssetLoad(asset);
                        }
                    }, AssetManager;
                }();
                AssetManager.MAX_ERROR_COUNT = 3, g.AssetManager = AssetManager;
            }(g || (g = {}));
            var g;
            !function(g) {
                function _require(game, path, currentModule) {
                    var targetScriptAsset, resolvedPath, resolvedVirtualPath, basedir = currentModule ? currentModule._dirname : game.assetBase, liveAssetVirtualPathTable = game._assetManager._liveAssetVirtualPathTable;
                    if (path.indexOf("/") === -1 && game._assetManager._assets.hasOwnProperty(path) && (targetScriptAsset = game._assetManager._assets[path]), 
                    /^\.\/|^\.\.\/|^\//.test(path)) {
                        if (resolvedPath = g.PathUtil.resolvePath(basedir, path), game._scriptCaches.hasOwnProperty(resolvedPath)) return game._scriptCaches[resolvedPath]._cachedValue();
                        if (game._scriptCaches.hasOwnProperty(resolvedPath + ".js")) return game._scriptCaches[resolvedPath + ".js"]._cachedValue();
                        if (currentModule) {
                            if (!currentModule._virtualDirname) throw g.ExceptionFactory.createAssertionError("g._require: require from DynamicAsset is not supported");
                            resolvedVirtualPath = g.PathUtil.resolvePath(currentModule._virtualDirname, path);
                        } else {
                            if ("./" !== path.substring(0, 2)) throw g.ExceptionFactory.createAssertionError("g._require: entry point must start with './'");
                            resolvedVirtualPath = path.substring(2);
                        }
                        targetScriptAsset || (targetScriptAsset = g.Util.findAssetByPathAsFile(resolvedVirtualPath, liveAssetVirtualPathTable)), 
                        targetScriptAsset || (targetScriptAsset = g.Util.findAssetByPathAsDirectory(resolvedVirtualPath, liveAssetVirtualPathTable));
                    } else if (!targetScriptAsset) {
                        var dirs = currentModule ? currentModule.paths : [];
                        dirs.push("node_modules");
                        for (var i = 0; i < dirs.length; ++i) {
                            var dir = dirs[i];
                            if (resolvedVirtualPath = g.PathUtil.resolvePath(dir, path), targetScriptAsset = g.Util.findAssetByPathAsFile(resolvedVirtualPath, liveAssetVirtualPathTable)) break;
                            if (targetScriptAsset = g.Util.findAssetByPathAsDirectory(resolvedVirtualPath, liveAssetVirtualPathTable)) break;
                        }
                    }
                    if (targetScriptAsset) {
                        if (game._scriptCaches.hasOwnProperty(targetScriptAsset.path)) return game._scriptCaches[targetScriptAsset.path]._cachedValue();
                        if (targetScriptAsset instanceof g.ScriptAsset) {
                            var context = new g.ScriptAssetContext(game, targetScriptAsset);
                            return game._scriptCaches[targetScriptAsset.path] = context, context._executeScript(currentModule);
                        }
                        if (targetScriptAsset instanceof g.TextAsset && targetScriptAsset && ".json" === g.PathUtil.resolveExtname(path)) {
                            var cache = game._scriptCaches[targetScriptAsset.path] = new g.RequireCachedValue(JSON.parse(targetScriptAsset.data));
                            return cache._cachedValue();
                        }
                    }
                    throw g.ExceptionFactory.createAssertionError("g._require: can not find module: " + path);
                }
                g._require = _require;
                var Module = function() {
                    function Module(game, id, path) {
                        var _this = this, dirname = g.PathUtil.resolveDirname(path), virtualPath = game._assetManager._liveAbsolutePathTable[path], virtualDirname = virtualPath ? g.PathUtil.resolveDirname(virtualPath) : void 0, _g = Object.create(g, {
                            game: {
                                value: game,
                                enumerable: !0
                            },
                            filename: {
                                value: path,
                                enumerable: !0
                            },
                            dirname: {
                                value: dirname,
                                enumerable: !0
                            },
                            module: {
                                value: this,
                                writable: !0,
                                enumerable: !0,
                                configurable: !0
                            }
                        });
                        this.id = id, this.filename = path, this.exports = {}, this.parent = null, this.loaded = !1, 
                        this.children = [], this.paths = virtualDirname ? g.PathUtil.makeNodeModulePaths(virtualDirname) : [], 
                        this._dirname = dirname, this._virtualDirname = virtualDirname, this._g = _g, this.require = function(path) {
                            return "g" === path ? _g : g._require(game, path, _this);
                        };
                    }
                    return Module;
                }();
                g.Module = Module;
            }(g || (g = {}));
            var g;
            !function(g) {
                var ScriptAssetContext = function() {
                    function ScriptAssetContext(game, asset) {
                        this._game = game, this._asset = asset, this._module = new g.Module(game, asset.path, asset.path), 
                        this._g = this._module._g, this._started = !1;
                    }
                    return ScriptAssetContext.prototype._cachedValue = function() {
                        if (!this._started) throw g.ExceptionFactory.createAssertionError("ScriptAssetContext#_cachedValue: not executed yet.");
                        return this._module.exports;
                    }, ScriptAssetContext.prototype._executeScript = function(currentModule) {
                        return this._started ? this._module.exports : (currentModule && (this._module.parent = currentModule, 
                        currentModule.children.push(this._module)), this._started = !0, this._asset.execute(this._g), 
                        this._module.loaded = !0, this._module.exports);
                    }, ScriptAssetContext;
                }();
                g.ScriptAssetContext = ScriptAssetContext;
            }(g || (g = {}));
            var g;
            !function(g) {
                var PlainMatrix = function() {
                    function PlainMatrix(widthOrSrc, height, scaleX, scaleY, angle) {
                        void 0 === widthOrSrc ? (this._modified = !1, this._matrix = [ 1, 0, 0, 1, 0, 0 ]) : "number" == typeof widthOrSrc ? (this._modified = !1, 
                        this._matrix = new Array(6), this.update(widthOrSrc, height, scaleX, scaleY, angle, 0, 0)) : (this._modified = widthOrSrc._modified, 
                        this._matrix = [ widthOrSrc._matrix[0], widthOrSrc._matrix[1], widthOrSrc._matrix[2], widthOrSrc._matrix[3], widthOrSrc._matrix[4], widthOrSrc._matrix[5] ]);
                    }
                    return PlainMatrix.prototype.update = function(width, height, scaleX, scaleY, angle, x, y) {
                        var r = angle * Math.PI / 180, _cos = Math.cos(r), _sin = Math.sin(r), a = _cos * scaleX, b = _sin * scaleX, c = _sin * scaleY, d = _cos * scaleY, w = width / 2, h = height / 2;
                        this._matrix[0] = a, this._matrix[1] = b, this._matrix[2] = -c, this._matrix[3] = d, 
                        this._matrix[4] = -a * w + c * h + w + x, this._matrix[5] = -b * w - d * h + h + y;
                    }, PlainMatrix.prototype.updateByInverse = function(width, height, scaleX, scaleY, angle, x, y) {
                        var r = angle * Math.PI / 180, _cos = Math.cos(r), _sin = Math.sin(r), a = _cos / scaleX, b = _sin / scaleY, c = _sin / scaleX, d = _cos / scaleY, w = width / 2, h = height / 2;
                        this._matrix[0] = a, this._matrix[1] = -b, this._matrix[2] = c, this._matrix[3] = d, 
                        this._matrix[4] = -a * (w + x) - c * (h + y) + w, this._matrix[5] = b * (w + x) - d * (h + y) + h;
                    }, PlainMatrix.prototype.multiply = function(matrix) {
                        var m1 = this._matrix, m2 = matrix._matrix, m10 = m1[0], m11 = m1[1], m12 = m1[2], m13 = m1[3];
                        m1[0] = m10 * m2[0] + m12 * m2[1], m1[1] = m11 * m2[0] + m13 * m2[1], m1[2] = m10 * m2[2] + m12 * m2[3], 
                        m1[3] = m11 * m2[2] + m13 * m2[3], m1[4] = m10 * m2[4] + m12 * m2[5] + m1[4], m1[5] = m11 * m2[4] + m13 * m2[5] + m1[5];
                    }, PlainMatrix.prototype.multiplyNew = function(matrix) {
                        var ret = this.clone();
                        return ret.multiply(matrix), ret;
                    }, PlainMatrix.prototype.reset = function(x, y) {
                        this._matrix[0] = 1, this._matrix[1] = 0, this._matrix[2] = 0, this._matrix[3] = 1, 
                        this._matrix[4] = x || 0, this._matrix[5] = y || 0;
                    }, PlainMatrix.prototype.clone = function() {
                        return new PlainMatrix(this);
                    }, PlainMatrix.prototype.multiplyInverseForPoint = function(point) {
                        var m = this._matrix, _id = 1 / (m[0] * m[3] + m[2] * -m[1]);
                        return {
                            x: m[3] * _id * point.x + -m[2] * _id * point.y + (m[5] * m[2] - m[4] * m[3]) * _id,
                            y: m[0] * _id * point.y + -m[1] * _id * point.x + (-m[5] * m[0] + m[4] * m[1]) * _id
                        };
                    }, PlainMatrix.prototype.scale = function(x, y) {
                        var m = this._matrix;
                        m[0] *= x, m[1] *= y, m[2] *= x, m[3] *= y, m[4] *= x, m[5] *= y;
                    }, PlainMatrix.prototype.multiplyPoint = function(point) {
                        var m = this._matrix, x = m[0] * point.x + m[2] * point.y + m[4], y = m[1] * point.x + m[3] * point.y + m[5];
                        return {
                            x: x,
                            y: y
                        };
                    }, PlainMatrix.prototype.multplyPoint = function(point) {
                        return this.multiplyPoint(point);
                    }, PlainMatrix;
                }();
                g.PlainMatrix = PlainMatrix;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Util;
                !function(Util) {
                    function distance(p1x, p1y, p2x, p2y) {
                        return Math.sqrt(Math.pow(p1x - p2x, 2) + Math.pow(p1y - p2y, 2));
                    }
                    function distanceBetweenOffsets(p1, p2) {
                        return Util.distance(p1.x, p1.y, p2.x, p2.y);
                    }
                    function distanceBetweenAreas(p1, p2) {
                        return Util.distance(p1.x - p1.width / 2, p1.y - p1.height / 2, p2.x - p2.width / 2, p2.y - p2.height / 2);
                    }
                    function createMatrix(width, height, scaleX, scaleY, angle) {
                        return void 0 === width ? new g.PlainMatrix() : new g.PlainMatrix(width, height, scaleX, scaleY, angle);
                    }
                    function createSpriteFromE(scene, e, camera) {
                        var oldX = e.x, oldY = e.y, x = 0, y = 0, width = e.width, height = e.height, boundingRect = e.calculateBoundingRect(camera);
                        if (!boundingRect) throw g.ExceptionFactory.createAssertionError("Util#createSpriteFromE: camera must look e");
                        width = boundingRect.right - boundingRect.left, height = boundingRect.bottom - boundingRect.top, 
                        boundingRect.left < e.x && (x = e.x - boundingRect.left), boundingRect.top < e.y && (y = e.y - boundingRect.top), 
                        e.moveTo(x, y), e._matrix && (e._matrix._modified = !0);
                        var surface = scene.game.resourceFactory.createSurface(Math.ceil(width), Math.ceil(height)), renderer = surface.renderer();
                        renderer.begin(), e.render(renderer, camera), renderer.end();
                        var s = new g.Sprite({
                            scene: scene,
                            src: surface,
                            width: width,
                            height: height
                        });
                        return s.moveTo(boundingRect.left, boundingRect.top), e.moveTo(oldX, oldY), e._matrix && (e._matrix._modified = !0), 
                        s;
                    }
                    function createSpriteFromScene(toScene, fromScene, camera) {
                        var surface = toScene.game.resourceFactory.createSurface(Math.ceil(fromScene.game.width), Math.ceil(fromScene.game.height)), renderer = surface.renderer();
                        renderer.begin();
                        for (var children = fromScene.children, i = 0; i < children.length; ++i) children[i].render(renderer, camera);
                        return renderer.end(), new g.Sprite({
                            scene: toScene,
                            src: surface,
                            width: fromScene.game.width,
                            height: fromScene.game.height
                        });
                    }
                    function asSurface(src) {
                        if (!src) return src;
                        if (src instanceof g.Surface) return src;
                        if (src instanceof g.ImageAsset) return src.asSurface();
                        throw g.ExceptionFactory.createTypeMismatchError("Util#asSurface", "ImageAsset|Surface", src);
                    }
                    function findAssetByPathAsFile(resolvedPath, liveAssetPathTable) {
                        return liveAssetPathTable.hasOwnProperty(resolvedPath) ? liveAssetPathTable[resolvedPath] : liveAssetPathTable.hasOwnProperty(resolvedPath + ".js") ? liveAssetPathTable[resolvedPath + ".js"] : void 0;
                    }
                    function findAssetByPathAsDirectory(resolvedPath, liveAssetPathTable) {
                        var path;
                        if (path = resolvedPath + "/package.json", liveAssetPathTable.hasOwnProperty(path) && liveAssetPathTable[path] instanceof g.TextAsset) {
                            var pkg = JSON.parse(liveAssetPathTable[path].data);
                            if (pkg && "string" == typeof pkg.main) {
                                var asset = Util.findAssetByPathAsFile(g.PathUtil.resolvePath(resolvedPath, pkg.main), liveAssetPathTable);
                                if (asset) return asset;
                            }
                        }
                        if (path = resolvedPath + "/index.js", liveAssetPathTable.hasOwnProperty(path)) return liveAssetPathTable[path];
                    }
                    function charCodeAt(str, idx) {
                        var code = str.charCodeAt(idx);
                        if (55296 <= code && code <= 56319) {
                            var hi = code, low = str.charCodeAt(idx + 1);
                            return hi << 16 | low;
                        }
                        return 56320 <= code && code <= 57343 ? null : code;
                    }
                    function setupAnimatingHandler(animatingHandler, surface) {
                        surface.isDynamic && (surface.animatingStarted.handle(animatingHandler, animatingHandler._onAnimatingStarted), 
                        surface.animatingStopped.handle(animatingHandler, animatingHandler._onAnimatingStopped), 
                        surface.isPlaying() && animatingHandler._onAnimatingStarted());
                    }
                    function migrateAnimatingHandler(animatingHandler, beforeSurface, afterSurface) {
                        animatingHandler._onAnimatingStopped(), !beforeSurface.destroyed() && beforeSurface.isDynamic && (beforeSurface.animatingStarted.remove(animatingHandler, animatingHandler._onAnimatingStarted), 
                        beforeSurface.animatingStopped.remove(animatingHandler, animatingHandler._onAnimatingStopped)), 
                        afterSurface.isDynamic && (afterSurface.animatingStarted.handle(animatingHandler, animatingHandler._onAnimatingStarted), 
                        afterSurface.animatingStopped.handle(animatingHandler, animatingHandler._onAnimatingStopped), 
                        afterSurface.isPlaying() && animatingHandler._onAnimatingStarted());
                    }
                    Util.distance = distance, Util.distanceBetweenOffsets = distanceBetweenOffsets, 
                    Util.distanceBetweenAreas = distanceBetweenAreas, Util.createMatrix = createMatrix, 
                    Util.createSpriteFromE = createSpriteFromE, Util.createSpriteFromScene = createSpriteFromScene, 
                    Util.asSurface = asSurface, Util.findAssetByPathAsFile = findAssetByPathAsFile, 
                    Util.findAssetByPathAsDirectory = findAssetByPathAsDirectory, Util.charCodeAt = charCodeAt, 
                    Util.setupAnimatingHandler = setupAnimatingHandler, Util.migrateAnimatingHandler = migrateAnimatingHandler;
                }(Util = g.Util || (g.Util = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var Collision;
                !function(Collision) {
                    function intersect(x1, y1, width1, height1, x2, y2, width2, height2) {
                        return x1 <= x2 + width2 && x2 <= x1 + width1 && y1 <= y2 + height2 && y2 <= y1 + height1;
                    }
                    function intersectAreas(t1, t2) {
                        return Collision.intersect(t1.x, t1.y, t1.width, t1.height, t2.x, t2.y, t2.width, t2.height);
                    }
                    function within(t1x, t1y, t2x, t2y, distance) {
                        return void 0 === distance && (distance = 1), distance >= g.Util.distance(t1x, t1y, t2x, t2y);
                    }
                    function withinAreas(t1, t2, distance) {
                        return void 0 === distance && (distance = 1), distance >= g.Util.distanceBetweenAreas(t1, t2);
                    }
                    Collision.intersect = intersect, Collision.intersectAreas = intersectAreas, Collision.within = within, 
                    Collision.withinAreas = withinAreas;
                }(Collision = g.Collision || (g.Collision = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var Trigger = function() {
                    function Trigger(chain) {
                        this.chain = chain, this._handlers = [];
                    }
                    return Trigger.prototype.handle = function(owner, handler, name) {
                        this._handlers.length || this._activateChain(), handler ? this._handlers.push({
                            owner: owner,
                            handler: handler,
                            name: name
                        }) : this._handlers.push({
                            owner: void 0,
                            handler: owner,
                            name: name
                        });
                    }, Trigger.prototype.destroy = function() {
                        this._deactivateChain(), this.chain = void 0, this._handlers = void 0;
                    }, Trigger.prototype.destroyed = function() {
                        return void 0 === this._handlers;
                    }, Trigger.prototype.hasHandler = function() {
                        return this._handlers && this._handlers.length > 0;
                    }, Trigger.prototype.handleInsert = function(index, owner, handler, name) {
                        this._handlers.length || this._activateChain(), handler ? this._handlers.splice(index, 0, {
                            owner: owner,
                            handler: handler,
                            name: name
                        }) : this._handlers.splice(index, 0, {
                            owner: void 0,
                            handler: owner,
                            name: name
                        });
                    }, Trigger.prototype.removeAll = function(owner) {
                        for (var tmp, handlers = []; tmp = this._handlers.shift(); ) tmp.owner !== owner && handlers.push(tmp);
                        this._handlers = handlers, this._handlers.length || this._deactivateChain();
                    }, Trigger.prototype.removeAllByHandler = function(handler) {
                        for (var tmp, handlers = []; tmp = this._handlers.shift(); ) tmp.handler !== handler && handlers.push(tmp);
                        this._handlers = handlers, this._handlers.length || this._deactivateChain();
                    }, Trigger.prototype.remove = function(owner, handler) {
                        var handlers = [];
                        handler || (handler = owner, owner = void 0);
                        for (var i = 0; i < this._handlers.length; ++i) {
                            var tmp = this._handlers[i];
                            tmp.handler === handler && tmp.owner === owner || handlers.push(tmp);
                        }
                        this._handlers = handlers, this._handlers.length || this._deactivateChain();
                    }, Trigger.prototype.removeByName = function(name) {
                        for (var handlers = [], i = 0; i < this._handlers.length; ++i) {
                            var tmp = this._handlers[i];
                            tmp.name !== name && handlers.push(tmp);
                        }
                        this._handlers = handlers, this._handlers.length || this._deactivateChain();
                    }, Trigger.prototype.isHandled = function(owner, handler) {
                        handler || (handler = owner, owner = void 0);
                        for (var i = 0; i < this._handlers.length; ++i) if (this._handlers[i].owner === owner && this._handlers[i].handler === handler) return !0;
                        return !1;
                    }, Trigger.prototype.fire = function(param) {
                        if (this._handlers && this._handlers.length) for (var handlers = this._handlers.concat(), i = 0; i < handlers.length; ++i) {
                            var handler = handlers[i];
                            handler.handler.call(handler.owner, param) && this._remove(handler);
                        }
                    }, Trigger.prototype._reset = function() {
                        this._handlers = [], this._deactivateChain();
                    }, Trigger.prototype._activateChain = function() {
                        this.chain && (this.chain.isHandled(this, this._onChainFire) || this.chain.handle(this, this._onChainFire));
                    }, Trigger.prototype._deactivateChain = function() {
                        this.chain && this.chain.isHandled(this, this._onChainFire) && this.chain.remove(this, this._onChainFire);
                    }, Trigger.prototype._remove = function(handler) {
                        var index = this._handlers.indexOf(handler);
                        index !== -1 && (this._handlers.splice(index, 1), this._handlers.length || this._deactivateChain());
                    }, Trigger.prototype._onChainFire = function(e) {
                        this.fire(e);
                    }, Trigger;
                }();
                g.Trigger = Trigger;
                var ConditionalChainTrigger = function(_super) {
                    function ConditionalChainTrigger(chain, filterOwner, filter) {
                        var _this = _super.call(this, chain) || this;
                        return _this.filterOwner = filterOwner, _this.filter = filter, _this;
                    }
                    return __extends(ConditionalChainTrigger, _super), ConditionalChainTrigger.prototype._onChainFire = function(e) {
                        this.filter && !this.filter.call(this.filterOwner, e) || this.fire(e);
                    }, ConditionalChainTrigger;
                }(Trigger);
                g.ConditionalChainTrigger = ConditionalChainTrigger;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Timer = function() {
                    function Timer(interval, fps) {
                        this.interval = interval, this._scaledInterval = Math.round(interval * fps), this.elapsed = new g.Trigger(), 
                        this._scaledElapsed = 0;
                    }
                    return Timer.prototype.tick = function() {
                        for (this._scaledElapsed += 1e3; this._scaledElapsed >= this._scaledInterval && this.elapsed; ) this.elapsed.fire(), 
                        this._scaledElapsed -= this._scaledInterval;
                    }, Timer.prototype.canDelete = function() {
                        return !this.elapsed.hasHandler();
                    }, Timer.prototype.destroy = function() {
                        this.interval = void 0, this.elapsed.destroy(), this.elapsed = void 0, this._scaledInterval = 0, 
                        this._scaledElapsed = 0;
                    }, Timer.prototype.destroyed = function() {
                        return void 0 === this.elapsed;
                    }, Timer;
                }();
                g.Timer = Timer;
            }(g || (g = {}));
            var g;
            !function(g) {
                var TimerIdentifier = function() {
                    function TimerIdentifier(timer, handler, handlerOwner, fired, firedOwner) {
                        this._timer = timer, this._handler = handler, this._handlerOwner = handlerOwner, 
                        this._fired = fired, this._firedOwner = firedOwner, this._timer.elapsed.handle(this, this._fire);
                    }
                    return TimerIdentifier.prototype.destroy = function() {
                        this._timer.elapsed.remove(this, this._fire), this._timer = void 0, this._handler = void 0, 
                        this._handlerOwner = void 0, this._fired = void 0, this._firedOwner = void 0;
                    }, TimerIdentifier.prototype.destroyed = function() {
                        return void 0 === this._timer;
                    }, TimerIdentifier.prototype._fire = function() {
                        this._handler.call(this._handlerOwner), this._fired && this._fired.call(this._firedOwner, this);
                    }, TimerIdentifier;
                }();
                g.TimerIdentifier = TimerIdentifier;
                var TimerManager = function() {
                    function TimerManager(trigger, fps) {
                        this._timers = [], this._trigger = trigger, this._identifiers = [], this._fps = fps, 
                        this._registered = !1;
                    }
                    return TimerManager.prototype.destroy = function() {
                        for (var i = 0; i < this._identifiers.length; ++i) this._identifiers[i].destroy();
                        for (var i = 0; i < this._timers.length; ++i) this._timers[i].destroy();
                        this._timers = void 0, this._trigger = void 0, this._identifiers = void 0, this._fps = void 0;
                    }, TimerManager.prototype.destroyed = function() {
                        return void 0 === this._timers;
                    }, TimerManager.prototype.createTimer = function(interval) {
                        if (this._registered || (this._trigger.handle(this, this._tick), this._registered = !0), 
                        interval < 0) throw g.ExceptionFactory.createAssertionError("TimerManager#createTimer: invalid interval");
                        interval < 1 && (interval = 1);
                        for (var acceptableMargin = Math.min(1e3, interval * this._fps), i = 0; i < this._timers.length; ++i) if (this._timers[i].interval === interval && this._timers[i]._scaledElapsed < acceptableMargin) return this._timers[i];
                        var timer = new g.Timer(interval, this._fps);
                        return this._timers.push(timer), timer;
                    }, TimerManager.prototype.deleteTimer = function(timer) {
                        if (timer.canDelete()) {
                            var index = this._timers.indexOf(timer);
                            if (index < 0) throw g.ExceptionFactory.createAssertionError("TimerManager#deleteTimer: can not find timer");
                            if (this._timers.splice(index, 1), timer.destroy(), !this._timers.length) {
                                if (!this._registered) throw g.ExceptionFactory.createAssertionError("TimerManager#deleteTimer: handler is not handled");
                                this._trigger.remove(this, this._tick), this._registered = !1;
                            }
                        }
                    }, TimerManager.prototype.setTimeout = function(milliseconds, owner, handler) {
                        void 0 === handler && (handler = owner, owner = null);
                        var timer = this.createTimer(milliseconds), identifier = new TimerIdentifier(timer, handler, owner, this._onTimeoutFired, this);
                        return this._identifiers.push(identifier), identifier;
                    }, TimerManager.prototype.clearTimeout = function(identifier) {
                        this._clear(identifier);
                    }, TimerManager.prototype.setInterval = function(interval, owner, handler) {
                        void 0 === handler && (handler = owner, owner = null);
                        var timer = this.createTimer(interval), identifier = new TimerIdentifier(timer, handler, owner);
                        return this._identifiers.push(identifier), identifier;
                    }, TimerManager.prototype.clearInterval = function(identifier) {
                        this._clear(identifier);
                    }, TimerManager.prototype._tick = function() {
                        for (var timers = this._timers.concat(), i = 0; i < timers.length; ++i) timers[i].tick();
                    }, TimerManager.prototype._onTimeoutFired = function(identifier) {
                        var index = this._identifiers.indexOf(identifier);
                        if (index < 0) throw g.ExceptionFactory.createAssertionError("TimerManager#_onTimeoutFired: can not find identifier");
                        this._identifiers.splice(index, 1);
                        var timer = identifier._timer;
                        identifier.destroy(), this.deleteTimer(timer);
                    }, TimerManager.prototype._clear = function(identifier) {
                        var index = this._identifiers.indexOf(identifier);
                        if (index < 0) throw g.ExceptionFactory.createAssertionError("TimerManager#_clear: can not find identifier");
                        if (identifier.destroyed()) throw g.ExceptionFactory.createAssertionError("TimerManager#_clear: invalid identifier");
                        this._identifiers.splice(index, 1);
                        var timer = identifier._timer;
                        identifier.destroy(), this.deleteTimer(timer);
                    }, TimerManager;
                }();
                g.TimerManager = TimerManager;
            }(g || (g = {}));
            var g;
            !function(g) {
                var AudioPlayer = function() {
                    function AudioPlayer(system) {
                        this.played = new g.Trigger(), this.stopped = new g.Trigger(), this.currentAudio = void 0, 
                        this.volume = system.volume, this._muted = system._muted, this._playbackRate = system._playbackRate, 
                        this._system = system;
                    }
                    return AudioPlayer.prototype.play = function(audio) {
                        this.currentAudio = audio, this.played.fire({
                            player: this,
                            audio: audio
                        });
                    }, AudioPlayer.prototype.stop = function() {
                        var audio = this.currentAudio;
                        this.currentAudio = void 0, this.stopped.fire({
                            player: this,
                            audio: audio
                        });
                    }, AudioPlayer.prototype.canHandleStopped = function() {
                        return !0;
                    }, AudioPlayer.prototype.changeVolume = function(volume) {
                        this.volume = volume;
                    }, AudioPlayer.prototype._changeMuted = function(muted) {
                        this._muted = muted;
                    }, AudioPlayer.prototype._changePlaybackRate = function(rate) {
                        this._playbackRate = rate;
                    }, AudioPlayer.prototype._supportsPlaybackRate = function() {
                        return !1;
                    }, AudioPlayer;
                }();
                g.AudioPlayer = AudioPlayer;
            }(g || (g = {}));
            var g;
            !function(g) {
                var AudioSystem = function() {
                    function AudioSystem(id, game) {
                        var audioSystemManager = game._audioSystemManager;
                        this.id = id, this.game = game, this._volume = 1, this._destroyRequestedAssets = {}, 
                        this._muted = audioSystemManager._muted, this._playbackRate = audioSystemManager._playbackRate;
                    }
                    return Object.defineProperty(AudioSystem.prototype, "volume", {
                        get: function() {
                            return this._volume;
                        },
                        set: function(value) {
                            if (value < 0 || value > 1 || isNaN(value) || "number" != typeof value) throw g.ExceptionFactory.createAssertionError("AudioSystem#volume: expected: 0.0-1.0, actual: " + value);
                            this._volume = value, this._onVolumeChanged();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AudioSystem.prototype.stopAll = function() {
                        throw g.ExceptionFactory.createPureVirtualError("AudioSystem#stopAll");
                    }, AudioSystem.prototype.findPlayers = function(asset) {
                        throw g.ExceptionFactory.createPureVirtualError("AudioSystem#findPlayers");
                    }, AudioSystem.prototype.createPlayer = function() {
                        throw g.ExceptionFactory.createPureVirtualError("AudioSystem#createPlayer");
                    }, AudioSystem.prototype.requestDestroy = function(asset) {
                        this._destroyRequestedAssets[asset.id] = asset;
                    }, AudioSystem.prototype._setMuted = function(value) {
                        var before = this._muted;
                        this._muted = !!value, this._muted !== before && this._onMutedChanged();
                    }, AudioSystem.prototype._setPlaybackRate = function(value) {
                        if (value < 0 || isNaN(value) || "number" != typeof value) throw g.ExceptionFactory.createAssertionError("AudioSystem#playbackRate: expected: greater or equal to 0.0, actual: " + value);
                        var before = this._playbackRate;
                        this._playbackRate = value, this._playbackRate !== before && this._onPlaybackRateChanged();
                    }, AudioSystem.prototype._onVolumeChanged = function() {
                        throw g.ExceptionFactory.createPureVirtualError("AudioSystem#_onVolumeChanged");
                    }, AudioSystem.prototype._onMutedChanged = function() {
                        throw g.ExceptionFactory.createPureVirtualError("AudioSystem#_onMutedChanged");
                    }, AudioSystem.prototype._onPlaybackRateChanged = function() {
                        throw g.ExceptionFactory.createPureVirtualError("AudioSystem#_onPlaybackRateChanged");
                    }, AudioSystem;
                }();
                g.AudioSystem = AudioSystem;
                var MusicAudioSystem = function(_super) {
                    function MusicAudioSystem(id, game) {
                        var _this = _super.call(this, id, game) || this;
                        return _this._player = void 0, _this._suppressingAudio = void 0, _this;
                    }
                    return __extends(MusicAudioSystem, _super), Object.defineProperty(MusicAudioSystem.prototype, "player", {
                        get: function() {
                            return this._player || (this._player = this.game.resourceFactory.createAudioPlayer(this), 
                            this._player.played.handle(this, this._onPlayerPlayed), this._player.stopped.handle(this, this._onPlayerStopped)), 
                            this._player;
                        },
                        set: function(v) {
                            this._player = v;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), MusicAudioSystem.prototype.findPlayers = function(asset) {
                        return this.player.currentAudio && this.player.currentAudio.id === asset.id ? [ this.player ] : [];
                    }, MusicAudioSystem.prototype.createPlayer = function() {
                        return this.player;
                    }, MusicAudioSystem.prototype.stopAll = function() {
                        this._player && this._player.stop();
                    }, MusicAudioSystem.prototype._onVolumeChanged = function() {
                        this.player.changeVolume(this._volume);
                    }, MusicAudioSystem.prototype._onMutedChanged = function() {
                        this.player._changeMuted(this._muted);
                    }, MusicAudioSystem.prototype._onPlaybackRateChanged = function() {
                        var player = this.player;
                        player._changePlaybackRate(this._playbackRate), player._supportsPlaybackRate() || this._onUnsupportedPlaybackRateChanged();
                    }, MusicAudioSystem.prototype._onUnsupportedPlaybackRateChanged = function() {
                        if (1 === this._playbackRate && this._suppressingAudio) {
                            var audio = this._suppressingAudio;
                            this._suppressingAudio = void 0, audio.destroyed() || this.player.play(audio);
                        }
                    }, MusicAudioSystem.prototype._onPlayerPlayed = function(e) {
                        if (e.player !== this._player) throw g.ExceptionFactory.createAssertionError("MusicAudioSystem#_onPlayerPlayed: unexpected audio player");
                        e.player._supportsPlaybackRate() || 1 !== this._playbackRate && (e.player.stop(), 
                        this._suppressingAudio = e.audio);
                    }, MusicAudioSystem.prototype._onPlayerStopped = function(e) {
                        this._destroyRequestedAssets[e.audio.id] && (delete this._destroyRequestedAssets[e.audio.id], 
                        e.audio.destroy());
                    }, MusicAudioSystem;
                }(AudioSystem);
                g.MusicAudioSystem = MusicAudioSystem;
                var SoundAudioSystem = function(_super) {
                    function SoundAudioSystem(id, game) {
                        var _this = _super.call(this, id, game) || this;
                        return _this.players = [], _this;
                    }
                    return __extends(SoundAudioSystem, _super), SoundAudioSystem.prototype.createPlayer = function() {
                        var player = this.game.resourceFactory.createAudioPlayer(this);
                        return player.canHandleStopped() && this.players.push(player), player.played.handle(this, this._onPlayerPlayed), 
                        player.stopped.handle(this, this._onPlayerStopped), player;
                    }, SoundAudioSystem.prototype.findPlayers = function(asset) {
                        for (var ret = [], i = 0; i < this.players.length; ++i) this.players[i].currentAudio && this.players[i].currentAudio.id === asset.id && ret.push(this.players[i]);
                        return ret;
                    }, SoundAudioSystem.prototype.stopAll = function() {
                        for (var players = this.players.concat(), i = 0; i < players.length; ++i) players[i].stop();
                    }, SoundAudioSystem.prototype._onMutedChanged = function() {
                        for (var players = this.players, i = 0; i < players.length; ++i) players[i]._changeMuted(this._muted);
                    }, SoundAudioSystem.prototype._onPlaybackRateChanged = function() {
                        for (var players = this.players, i = 0; i < players.length; ++i) players[i]._changePlaybackRate(this._playbackRate);
                    }, SoundAudioSystem.prototype._onPlayerPlayed = function(e) {
                        e.player._supportsPlaybackRate() || 1 !== this._playbackRate && e.player.stop();
                    }, SoundAudioSystem.prototype._onPlayerStopped = function(e) {
                        var index = this.players.indexOf(e.player);
                        index < 0 || (e.player.stopped.remove(this, this._onPlayerStopped), this.players.splice(index, 1), 
                        this._destroyRequestedAssets[e.audio.id] && (delete this._destroyRequestedAssets[e.audio.id], 
                        e.audio.destroy()));
                    }, SoundAudioSystem.prototype._onVolumeChanged = function() {
                        for (var i = 0; i < this.players.length; ++i) this.players[i].changeVolume(this._volume);
                    }, SoundAudioSystem;
                }(AudioSystem);
                g.SoundAudioSystem = SoundAudioSystem;
            }(g || (g = {}));
            var g;
            !function(g) {
                var VideoPlayer = function() {
                    function VideoPlayer(loop) {
                        this._loop = !!loop, this.played = new g.Trigger(), this.stopped = new g.Trigger(), 
                        this.currentVideo = void 0, this.volume = 1;
                    }
                    return VideoPlayer.prototype.play = function(videoAsset) {
                        this.currentVideo = videoAsset, this.played.fire({
                            player: this,
                            video: videoAsset
                        }), videoAsset.asSurface().animatingStarted.fire();
                    }, VideoPlayer.prototype.stop = function() {
                        var videoAsset = this.currentVideo;
                        this.stopped.fire({
                            player: this,
                            video: videoAsset
                        }), videoAsset.asSurface().animatingStopped.fire();
                    }, VideoPlayer.prototype.changeVolume = function(volume) {
                        this.volume = volume;
                    }, VideoPlayer;
                }();
                g.VideoPlayer = VideoPlayer;
            }(g || (g = {}));
            var g;
            !function(g) {
                var VideoSystem = function() {
                    function VideoSystem() {}
                    return VideoSystem;
                }();
                g.VideoSystem = VideoSystem;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Object2D = function() {
                    function Object2D(param) {
                        param ? (this.x = param.x || 0, this.y = param.y || 0, this.width = param.width || 0, 
                        this.height = param.height || 0, this.opacity = "opacity" in param ? param.opacity : 1, 
                        this.scaleX = "scaleX" in param ? param.scaleX : 1, this.scaleY = "scaleY" in param ? param.scaleY : 1, 
                        this.angle = param.angle || 0, this.compositeOperation = param.compositeOperation, 
                        this._matrix = void 0) : (this.x = 0, this.y = 0, this.width = 0, this.height = 0, 
                        this.opacity = 1, this.scaleX = 1, this.scaleY = 1, this.angle = 0, this.compositeOperation = void 0, 
                        this._matrix = void 0);
                    }
                    return Object2D.prototype.moveTo = function(posOrX, y) {
                        if ("number" == typeof posOrX && "number" != typeof y) throw g.ExceptionFactory.createAssertionError("Object2D#moveTo: arguments must be CommonOffset or pair of x and y as a number.");
                        "number" == typeof posOrX ? (this.x = posOrX, this.y = y) : (this.x = posOrX.x, 
                        this.y = posOrX.y);
                    }, Object2D.prototype.moveBy = function(x, y) {
                        this.x += x, this.y += y;
                    }, Object2D.prototype.resizeTo = function(sizeOrWidth, height) {
                        if ("number" == typeof sizeOrWidth && "number" != typeof height) throw g.ExceptionFactory.createAssertionError("Object2D#resizeTo: arguments must be CommonSize or pair of width and height as a number.");
                        "number" == typeof sizeOrWidth ? (this.width = sizeOrWidth, this.height = height) : (this.width = sizeOrWidth.width, 
                        this.height = sizeOrWidth.height);
                    }, Object2D.prototype.resizeBy = function(width, height) {
                        this.width += width, this.height += height;
                    }, Object2D.prototype.scale = function(scale) {
                        this.scaleX = scale, this.scaleY = scale;
                    }, Object2D.prototype.getMatrix = function() {
                        if (this._matrix) {
                            if (!this._matrix._modified) return this._matrix;
                        } else this._matrix = g.Util.createMatrix();
                        return this._updateMatrix(), this._matrix._modified = !1, this._matrix;
                    }, Object2D.prototype._updateMatrix = function() {
                        this.angle || 1 !== this.scaleX || 1 !== this.scaleY ? this._matrix.update(this.width, this.height, this.scaleX, this.scaleY, this.angle, this.x, this.y) : this._matrix.reset(this.x, this.y);
                    }, Object2D;
                }();
                g.Object2D = Object2D;
            }(g || (g = {}));
            var g;
            !function(g) {
                var E = function(_super) {
                    function E(sceneOrParam) {
                        var _this = this;
                        if (sceneOrParam instanceof g.Scene) {
                            var scene = sceneOrParam;
                            _this = _super.call(this) || this, _this.children = void 0, _this.parent = void 0, 
                            _this._touchable = !1, _this.state = 0, _this._hasTouchableChildren = !1, _this._update = void 0, 
                            _this._message = void 0, _this._pointDown = void 0, _this._pointMove = void 0, _this._pointUp = void 0, 
                            _this._targetCameras = void 0, _this.local = scene.local !== g.LocalTickMode.NonLocal, 
                            scene.register(_this), scene.game.logger.debug("[deprecated] E or Subclass of E: This constructor is deprecated. Refer to the API documentation and use each constructor(param: ParameterObject) instead.");
                        } else {
                            var param = sceneOrParam;
                            if (_this = _super.call(this, param) || this, _this.children = void 0, _this.parent = void 0, 
                            _this._touchable = !1, _this.state = 0, _this._hasTouchableChildren = !1, _this._update = void 0, 
                            _this._message = void 0, _this._pointDown = void 0, _this._pointMove = void 0, _this._pointUp = void 0, 
                            _this._targetCameras = void 0, _this.tag = param.tag, _this.local = param.scene.local !== g.LocalTickMode.NonLocal || !!param.local, 
                            param.children) for (var i = 0; i < param.children.length; ++i) _this.append(param.children[i]);
                            param.parent && param.parent.append(_this), param.targetCameras && (_this.targetCameras = param.targetCameras), 
                            "touchable" in param && (_this.touchable = param.touchable), param.hidden && _this.hide(), 
                            _this.id = param.id, param.scene.register(_this);
                        }
                        return _this;
                    }
                    return __extends(E, _super), Object.defineProperty(E.prototype, "update", {
                        get: function() {
                            return this._update || (this._update = new g.Trigger(this.scene.update)), this._update;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "message", {
                        get: function() {
                            return this._message || (this._message = new g.Trigger(this.scene.message)), this._message;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "pointDown", {
                        get: function() {
                            return this._pointDown || (this._pointDown = new g.ConditionalChainTrigger(this.scene.pointDownCapture, this, this._isTargetOperation)), 
                            this._pointDown;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "pointUp", {
                        get: function() {
                            return this._pointUp || (this._pointUp = new g.ConditionalChainTrigger(this.scene.pointUpCapture, this, this._isTargetOperation)), 
                            this._pointUp;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "pointMove", {
                        get: function() {
                            return this._pointMove || (this._pointMove = new g.ConditionalChainTrigger(this.scene.pointMoveCapture, this, this._isTargetOperation)), 
                            this._pointMove;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "targetCameras", {
                        get: function() {
                            return this._targetCameras || (this._targetCameras = []);
                        },
                        set: function(v) {
                            this._targetCameras = v;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(E.prototype, "touchable", {
                        get: function() {
                            return this._touchable;
                        },
                        set: function(v) {
                            this._touchable !== v && (this._touchable = v, v ? this._enableTouchPropagation() : this._disableTouchPropagation());
                        },
                        enumerable: !0,
                        configurable: !0
                    }), E.prototype.render = function(renderer, camera) {
                        if (this.state &= -5, !(1 & this.state)) {
                            var cams = this._targetCameras;
                            if (!(cams && cams.length > 0) || camera && cams.indexOf(camera) !== -1) {
                                if (8 & this.state) {
                                    renderer.translate(this.x, this.y);
                                    var goDown = this.renderSelf(renderer, camera);
                                    if (goDown && this.children) for (var children = this.children, len = children.length, i = 0; i < len; ++i) children[i].render(renderer, camera);
                                    return void renderer.translate(-this.x, -this.y);
                                }
                                renderer.save(), this.angle || 1 !== this.scaleX || 1 !== this.scaleY ? renderer.transform(this.getMatrix()._matrix) : renderer.translate(this.x, this.y), 
                                1 !== this.opacity && renderer.opacity(this.opacity), void 0 !== this.compositeOperation && renderer.setCompositeOperation(this.compositeOperation);
                                var goDown = this.renderSelf(renderer, camera);
                                if (goDown && this.children) for (var children = this.children, i = 0; i < children.length; ++i) children[i].render(renderer, camera);
                                renderer.restore();
                            }
                        }
                    }, E.prototype.renderSelf = function(renderer, camera) {
                        return !0;
                    }, E.prototype.game = function() {
                        return this.scene.game;
                    }, E.prototype.append = function(e) {
                        this.insertBefore(e, void 0);
                    }, E.prototype.insertBefore = function(e, target) {
                        e.parent && e.remove(), this.children || (this.children = []), e.parent = this;
                        var index = -1;
                        void 0 !== target && (index = this.children.indexOf(target)) > -1 ? this.children.splice(index, 0, e) : this.children.push(e), 
                        (e._touchable || e._hasTouchableChildren) && (this._hasTouchableChildren = !0, this._enableTouchPropagation()), 
                        this.modified(!0);
                    }, E.prototype.remove = function(e) {
                        if (void 0 === e) return void this.parent.remove(this);
                        var index = this.children ? this.children.indexOf(e) : -1;
                        if (index < 0) throw g.ExceptionFactory.createAssertionError("E#remove: invalid child");
                        this.children[index].parent = void 0, this.children.splice(index, 1), (e._touchable || e._hasTouchableChildren) && (this._findTouchableChildren(this) || (this._hasTouchableChildren = !1, 
                        this._disableTouchPropagation())), this.modified(!0);
                    }, E.prototype.destroy = function() {
                        if (this.parent && this.remove(), this.children) {
                            for (;this.children.length; ) this.children[this.children.length - 1].destroy();
                            this.children = void 0;
                        }
                        this._update && (this._update.destroy(), this._update = void 0), this._message && (this._message.destroy(), 
                        this._message = void 0), this._pointDown && (this._pointDown.destroy(), this._pointDown = void 0), 
                        this._pointMove && (this._pointMove.destroy(), this._pointMove = void 0), this._pointUp && (this._pointUp.destroy(), 
                        this._pointUp = void 0), this.scene.unregister(this);
                    }, E.prototype.destroyed = function() {
                        return void 0 === this.scene;
                    }, E.prototype.modified = function(isBubbling) {
                        this._matrix && (this._matrix._modified = !0), this.angle || 1 !== this.scaleX || 1 !== this.scaleY || 1 !== this.opacity || void 0 !== this.compositeOperation ? this.state &= -9 : this.state |= 8, 
                        4 & this.state || (this.state |= 4, this.parent && this.parent.modified(!0));
                    }, E.prototype.shouldFindChildrenByPoint = function(point) {
                        return !0;
                    }, E.prototype.findPointSourceByPoint = function(point, m, force, camera) {
                        if (!(1 & this.state)) {
                            var cams = this._targetCameras;
                            if (!(cams && cams.length > 0) || camera && cams.indexOf(camera) !== -1) {
                                m = m ? m.multiplyNew(this.getMatrix()) : this.getMatrix().clone();
                                var p = m.multiplyInverseForPoint(point);
                                if ((this._hasTouchableChildren || force && this.children && this.children.length) && this.shouldFindChildrenByPoint(p)) for (var i = this.children.length - 1; i >= 0; --i) {
                                    var child = this.children[i];
                                    if (force || child._touchable || child._hasTouchableChildren) {
                                        var target = child.findPointSourceByPoint(point, m, force, camera);
                                        if (target) return target;
                                    }
                                }
                                if (force || this._touchable) return 0 <= p.x && this.width > p.x && 0 <= p.y && this.height > p.y ? {
                                    target: this,
                                    point: p
                                } : void 0;
                            }
                        }
                    }, E.prototype.visible = function() {
                        return 1 !== (1 & this.state);
                    }, E.prototype.show = function() {
                        1 & this.state && (this.state &= -2, this.parent && this.parent.modified(!0));
                    }, E.prototype.hide = function() {
                        1 & this.state || (this.state |= 1, this.parent && this.parent.modified(!0));
                    }, E.prototype.calculateBoundingRect = function(c) {
                        return this._calculateBoundingRect(void 0, c);
                    }, E.prototype._calculateBoundingRect = function(m, c) {
                        var matrix = this.getMatrix();
                        if (m && (matrix = m.multiplyNew(matrix)), this.visible() && (!c || this._targetCameras && this._targetCameras.indexOf(c) !== -1)) {
                            for (var thisBoundingRect = {
                                left: 0,
                                right: this.width,
                                top: 0,
                                bottom: this.height
                            }, targetCoordinates = [ {
                                x: thisBoundingRect.left,
                                y: thisBoundingRect.top
                            }, {
                                x: thisBoundingRect.left,
                                y: thisBoundingRect.bottom
                            }, {
                                x: thisBoundingRect.right,
                                y: thisBoundingRect.top
                            }, {
                                x: thisBoundingRect.right,
                                y: thisBoundingRect.bottom
                            } ], convertedPoint = matrix.multiplyPoint(targetCoordinates[0]), result = {
                                left: convertedPoint.x,
                                right: convertedPoint.x,
                                top: convertedPoint.y,
                                bottom: convertedPoint.y
                            }, i = 1; i < targetCoordinates.length; ++i) convertedPoint = matrix.multiplyPoint(targetCoordinates[i]), 
                            result.left > convertedPoint.x && (result.left = convertedPoint.x), result.right < convertedPoint.x && (result.right = convertedPoint.x), 
                            result.top > convertedPoint.y && (result.top = convertedPoint.y), result.bottom < convertedPoint.y && (result.bottom = convertedPoint.y);
                            if (void 0 !== this.children) for (var i = 0; i < this.children.length; ++i) {
                                var nowResult = this.children[i]._calculateBoundingRect(matrix, c);
                                nowResult && (result.left > nowResult.left && (result.left = nowResult.left), result.right < nowResult.right && (result.right = nowResult.right), 
                                result.top > nowResult.top && (result.top = nowResult.top), result.bottom < nowResult.bottom && (result.bottom = nowResult.bottom));
                            }
                            return result;
                        }
                    }, E.prototype._enableTouchPropagation = function() {
                        for (var p = this.parent; p instanceof E && !p._hasTouchableChildren; ) p._hasTouchableChildren = !0, 
                        p = p.parent;
                    }, E.prototype._disableTouchPropagation = function() {
                        for (var p = this.parent; p instanceof E && p._hasTouchableChildren && !this._findTouchableChildren(p); ) p._hasTouchableChildren = !1, 
                        p = p.parent;
                    }, E.prototype._isTargetOperation = function(e) {
                        return !(1 & this.state) && (e instanceof g.PointEvent && (this._touchable && e.target === this));
                    }, E.prototype._findTouchableChildren = function(e) {
                        if (e.children) for (var i = 0; i < e.children.length; ++i) {
                            if (e.children[i].touchable) return e.children[i];
                            var tmp = this._findTouchableChildren(e.children[i]);
                            if (tmp) return tmp;
                        }
                    }, E;
                }(g.Object2D);
                g.E = E;
            }(g || (g = {}));
            var g;
            !function(g) {
                var CacheableE = function(_super) {
                    function CacheableE(sceneOrParam) {
                        var _this = _super.call(this, sceneOrParam) || this;
                        return _this._shouldRenderChildren = !0, _this._cache = void 0, _this._renderer = void 0, 
                        _this._renderedCamera = void 0, _this;
                    }
                    return __extends(CacheableE, _super), CacheableE.prototype.invalidate = function() {
                        this.state &= -3, this.modified();
                    }, CacheableE.prototype.renderSelf = function(renderer, camera) {
                        if (this._renderedCamera !== camera && (this.state &= -3, this._renderedCamera = camera), 
                        !(2 & this.state)) {
                            var isNew = !this._cache || this._cache.width < Math.ceil(this.width) || this._cache.height < Math.ceil(this.height);
                            isNew && (this._cache && !this._cache.destroyed() && this._cache.destroy(), this._cache = this.scene.game.resourceFactory.createSurface(Math.ceil(this.width), Math.ceil(this.height)), 
                            this._renderer = this._cache.renderer()), this._renderer.begin(), isNew || this._renderer.clear(), 
                            this.renderCache(this._renderer, camera), this.state |= 2, this._renderer.end();
                        }
                        return this._cache && this.width > 0 && this.height > 0 && renderer.drawImage(this._cache, 0, 0, this.width, this.height, 0, 0), 
                        this._shouldRenderChildren;
                    }, CacheableE.prototype.renderCache = function(renderer, camera) {
                        throw g.ExceptionFactory.createPureVirtualError("CacheableE#renderCache");
                    }, CacheableE.prototype.destroy = function() {
                        this._cache && !this._cache.destroyed() && this._cache.destroy(), this._cache = void 0, 
                        _super.prototype.destroy.call(this);
                    }, CacheableE;
                }(g.E);
                g.CacheableE = CacheableE;
            }(g || (g = {}));
            var g;
            !function(g) {
                var StorageRegion;
                !function(StorageRegion) {
                    StorageRegion[StorageRegion.Slots = 1] = "Slots", StorageRegion[StorageRegion.Scores = 2] = "Scores", 
                    StorageRegion[StorageRegion.Counts = 3] = "Counts", StorageRegion[StorageRegion.Values = 4] = "Values";
                }(StorageRegion = g.StorageRegion || (g.StorageRegion = {}));
                var StorageOrder;
                !function(StorageOrder) {
                    StorageOrder[StorageOrder.Asc = 0] = "Asc", StorageOrder[StorageOrder.Desc = 1] = "Desc";
                }(StorageOrder = g.StorageOrder || (g.StorageOrder = {}));
                var StorageCondition;
                !function(StorageCondition) {
                    StorageCondition[StorageCondition.Equal = 1] = "Equal", StorageCondition[StorageCondition.GreaterThan = 2] = "GreaterThan", 
                    StorageCondition[StorageCondition.LessThan = 3] = "LessThan";
                }(StorageCondition = g.StorageCondition || (g.StorageCondition = {}));
                var StorageCountsOperation;
                !function(StorageCountsOperation) {
                    StorageCountsOperation[StorageCountsOperation.Incr = 1] = "Incr", StorageCountsOperation[StorageCountsOperation.Decr = 2] = "Decr";
                }(StorageCountsOperation = g.StorageCountsOperation || (g.StorageCountsOperation = {}));
                var StorageValueStore = function() {
                    function StorageValueStore(keys, values) {
                        this._keys = keys, this._values = values;
                    }
                    return StorageValueStore.prototype.get = function(keyOrIndex) {
                        if (void 0 === this._values) return [];
                        if ("number" == typeof keyOrIndex) return this._values[keyOrIndex];
                        var index = this._keys.indexOf(keyOrIndex);
                        if (index !== -1) return this._values[index];
                        for (var i = 0; i < this._keys.length; ++i) {
                            var target = this._keys[i];
                            if (target.region === keyOrIndex.region && target.regionKey === keyOrIndex.regionKey && target.userId === keyOrIndex.userId && target.gameId === keyOrIndex.gameId) return this._values[i];
                        }
                        return [];
                    }, StorageValueStore.prototype.getOne = function(keyOrIndex) {
                        var values = this.get(keyOrIndex);
                        if (values) return values[0];
                    }, StorageValueStore;
                }();
                g.StorageValueStore = StorageValueStore;
                var StorageLoader = function() {
                    function StorageLoader(storage, keys, serialization) {
                        this._loaded = !1, this._storage = storage, this._valueStore = new StorageValueStore(keys), 
                        this._handler = void 0, this._valueStoreSerialization = serialization;
                    }
                    return StorageLoader.prototype._load = function(handler) {
                        this._handler = handler, this._storage._load && this._storage._load.call(this._storage, this._valueStore._keys, this, this._valueStoreSerialization);
                    }, StorageLoader.prototype._onLoaded = function(values, serialization) {
                        this._valueStore._values = values, this._loaded = !0, serialization && (this._valueStoreSerialization = serialization), 
                        this._handler && this._handler._onStorageLoaded();
                    }, StorageLoader.prototype._onError = function(error) {
                        this._handler && this._handler._onStorageLoadError(error);
                    }, StorageLoader;
                }();
                g.StorageLoader = StorageLoader;
                var Storage = function() {
                    function Storage(game) {
                        this._game = game;
                    }
                    return Storage.prototype.write = function(key, value, option) {
                        this._write && this._write(key, value, option);
                    }, Storage.prototype.requestValuesForJoinPlayer = function(keys) {
                        this._requestedKeysForJoinPlayer = keys;
                    }, Storage.prototype._createLoader = function(keys, serialization) {
                        return new StorageLoader(this, keys, serialization);
                    }, Storage.prototype._registerWrite = function(write) {
                        this._write = write;
                    }, Storage.prototype._registerLoad = function(load) {
                        this._load = load;
                    }, Storage;
                }();
                g.Storage = Storage;
            }(g || (g = {}));
            var g;
            !function(g) {
                var SceneAssetHolder = function() {
                    function SceneAssetHolder(param) {
                        this.waitingAssetsCount = param.assetIds.length, this._scene = param.scene, this._assetManager = param.assetManager, 
                        this._assetIds = param.assetIds, this._assets = [], this._handler = param.handler, 
                        this._handlerOwner = param.handlerOwner || null, this._direct = !!param.direct, 
                        this._requested = !1;
                    }
                    return SceneAssetHolder.prototype.request = function() {
                        return 0 !== this.waitingAssetsCount && (!!this._requested || (this._requested = !0, 
                        this._assetManager.requestAssets(this._assetIds, this), !0));
                    }, SceneAssetHolder.prototype.destroy = function() {
                        this._requested && this._assetManager.unrefAssets(this._assets), this.waitingAssetsCount = 0, 
                        this._scene = void 0, this._assetIds = void 0, this._handler = void 0, this._requested = !1;
                    }, SceneAssetHolder.prototype.destroyed = function() {
                        return !this._scene;
                    }, SceneAssetHolder.prototype.callHandler = function() {
                        this._handler.call(this._handlerOwner);
                    }, SceneAssetHolder.prototype._onAssetError = function(asset, error, assetManager) {
                        if (!this.destroyed() && !this._scene.destroyed()) {
                            var failureInfo = {
                                asset: asset,
                                error: error,
                                cancelRetry: !1
                            };
                            this._scene.assetLoadFailed.fire(failureInfo), error.retriable && !failureInfo.cancelRetry ? this._assetManager.retryLoad(asset) : this._assetManager.configuration[asset.id] && this._scene.game.terminateGame(), 
                            this._scene.assetLoadCompleted.fire(asset);
                        }
                    }, SceneAssetHolder.prototype._onAssetLoad = function(asset) {
                        if (!this.destroyed() && !this._scene.destroyed()) {
                            if (this._scene.assets[asset.id] = asset, this._scene.assetLoaded.fire(asset), this._scene.assetLoadCompleted.fire(asset), 
                            this._assets.push(asset), --this.waitingAssetsCount, this.waitingAssetsCount < 0) throw g.ExceptionFactory.createAssertionError("SceneAssetHolder#_onAssetLoad: broken waitingAssetsCount");
                            this.waitingAssetsCount > 0 || (this._direct ? this.callHandler() : this._scene.game._callSceneAssetHolderHandler(this));
                        }
                    }, SceneAssetHolder;
                }();
                g.SceneAssetHolder = SceneAssetHolder;
                var SceneState;
                !function(SceneState) {
                    SceneState[SceneState.Destroyed = 0] = "Destroyed", SceneState[SceneState.Standby = 1] = "Standby", 
                    SceneState[SceneState.Active = 2] = "Active", SceneState[SceneState.Deactive = 3] = "Deactive", 
                    SceneState[SceneState.BeforeDestroyed = 4] = "BeforeDestroyed";
                }(SceneState = g.SceneState || (g.SceneState = {}));
                var SceneLoadState;
                !function(SceneLoadState) {
                    SceneLoadState[SceneLoadState.Initial = 0] = "Initial", SceneLoadState[SceneLoadState.Ready = 1] = "Ready", 
                    SceneLoadState[SceneLoadState.ReadyFired = 2] = "ReadyFired", SceneLoadState[SceneLoadState.LoadedFired = 3] = "LoadedFired";
                }(SceneLoadState = g.SceneLoadState || (g.SceneLoadState = {}));
                var Scene = function() {
                    function Scene(gameOrParam, assetIds) {
                        var game, local, tickGenerationMode;
                        if (gameOrParam instanceof g.Game) game = gameOrParam, local = g.LocalTickMode.NonLocal, 
                        tickGenerationMode = g.TickGenerationMode.ByClock, game.logger.debug("[deprecated] Scene:This constructor is deprecated. Refer to the API documentation and use Scene(param: SceneParameterObject) instead."); else {
                            var param = gameOrParam;
                            game = param.game, assetIds = param.assetIds, param.storageKeys ? (this._storageLoader = game.storage._createLoader(param.storageKeys, param.storageValuesSerialization), 
                            this.storageValues = this._storageLoader._valueStore) : (this._storageLoader = void 0, 
                            this.storageValues = void 0), local = void 0 === param.local ? g.LocalTickMode.NonLocal : param.local === !1 ? g.LocalTickMode.NonLocal : param.local === !0 ? g.LocalTickMode.FullLocal : param.local, 
                            tickGenerationMode = void 0 !== param.tickGenerationMode ? param.tickGenerationMode : g.TickGenerationMode.ByClock, 
                            this.name = param.name;
                        }
                        assetIds || (assetIds = []), this.game = game, this.local = local, this.tickGenerationMode = tickGenerationMode, 
                        this.loaded = new g.Trigger(), this._ready = new g.Trigger(), this.assets = {}, 
                        this._loaded = !1, this._prefetchRequested = !1, this._loadingState = SceneLoadState.Initial, 
                        this.update = new g.Trigger(), this._timer = new g.TimerManager(this.update, this.game.fps), 
                        this.assetLoaded = new g.Trigger(), this.assetLoadFailed = new g.Trigger(), this.assetLoadCompleted = new g.Trigger(), 
                        this.message = new g.Trigger(), this.pointDownCapture = new g.Trigger(), this.pointMoveCapture = new g.Trigger(), 
                        this.pointUpCapture = new g.Trigger(), this.operation = new g.Trigger(), this.children = [], 
                        this.state = SceneState.Standby, this.stateChanged = new g.Trigger(), this._assetHolders = [], 
                        this._sceneAssetHolder = new SceneAssetHolder({
                            scene: this,
                            assetManager: this.game._assetManager,
                            assetIds: assetIds,
                            handler: this._onSceneAssetsLoad,
                            handlerOwner: this,
                            direct: !0
                        });
                    }
                    return Scene.prototype.modified = function(isBubbling) {
                        this.game.modified = !0;
                    }, Scene.prototype.destroy = function() {
                        this.state = SceneState.BeforeDestroyed, this.stateChanged.fire(this.state);
                        var gameDb = this.game.db;
                        for (var p in gameDb) gameDb.hasOwnProperty(p) && gameDb[p].scene === this && gameDb[p].destroy();
                        var gameDb = this.game._localDb;
                        for (var p in gameDb) gameDb.hasOwnProperty(p) && gameDb[p].scene === this && gameDb[p].destroy();
                        this._timer.destroy(), this.update.destroy(), this.message.destroy(), this.pointDownCapture.destroy(), 
                        this.pointMoveCapture.destroy(), this.pointUpCapture.destroy(), this.operation.destroy(), 
                        this.loaded.destroy(), this.assetLoaded.destroy(), this.assetLoadFailed.destroy(), 
                        this.assetLoadCompleted.destroy(), this.assets = {};
                        for (var i = 0; i < this._assetHolders.length; ++i) this._assetHolders[i].destroy();
                        this._sceneAssetHolder.destroy(), this._storageLoader = void 0, this.game = void 0, 
                        this.state = SceneState.Destroyed, this.stateChanged.fire(this.state), this.stateChanged.destroy();
                    }, Scene.prototype.destroyed = function() {
                        return void 0 === this.game;
                    }, Scene.prototype.createTimer = function(interval) {
                        return this._timer.createTimer(interval);
                    }, Scene.prototype.deleteTimer = function(timer) {
                        this._timer.deleteTimer(timer);
                    }, Scene.prototype.setInterval = function(interval, owner, handler) {
                        return this._timer.setInterval(interval, owner, handler);
                    }, Scene.prototype.clearInterval = function(identifier) {
                        this._timer.clearInterval(identifier);
                    }, Scene.prototype.setTimeout = function(milliseconds, owner, handler) {
                        return this._timer.setTimeout(milliseconds, owner, handler);
                    }, Scene.prototype.clearTimeout = function(identifier) {
                        this._timer.clearTimeout(identifier);
                    }, Scene.prototype.isCurrentScene = function() {
                        return this.game.scene() === this;
                    }, Scene.prototype.gotoScene = function(next, toPush) {
                        if (!this.isCurrentScene()) throw g.ExceptionFactory.createAssertionError("Scene#gotoScene: this scene is not the current scene");
                        toPush ? this.game.pushScene(next) : this.game.replaceScene(next);
                    }, Scene.prototype.end = function() {
                        if (!this.isCurrentScene()) throw g.ExceptionFactory.createAssertionError("Scene#end: this scene is not the current scene");
                        this.game.popScene();
                    }, Scene.prototype.register = function(e) {
                        this.game.register(e), e.scene = this;
                    }, Scene.prototype.unregister = function(e) {
                        e.scene = void 0, this.game.unregister(e);
                    }, Scene.prototype.append = function(e) {
                        this.insertBefore(e, void 0);
                    }, Scene.prototype.insertBefore = function(e, target) {
                        e.parent && e.remove(), e.parent = this;
                        var index = -1;
                        void 0 !== target && (index = this.children.indexOf(target)) > -1 ? this.children.splice(index, 0, e) : this.children.push(e), 
                        this.modified(!0);
                    }, Scene.prototype.remove = function(e) {
                        var index = this.children.indexOf(e);
                        index !== -1 && (this.children[index].parent = void 0, this.children.splice(index, 1), 
                        this.modified(!0));
                    }, Scene.prototype.findPointSourceByPoint = function(point, force, camera) {
                        var mayConsumeLocalTick = this.local !== g.LocalTickMode.NonLocal, children = this.children, m = void 0;
                        camera && camera instanceof g.Camera2D && (m = camera.getMatrix());
                        for (var i = children.length - 1; i >= 0; --i) {
                            var ret = children[i].findPointSourceByPoint(point, m, force, camera);
                            if (ret) return ret.local = ret.target.local || mayConsumeLocalTick, ret;
                        }
                        return {
                            target: void 0,
                            point: void 0,
                            local: mayConsumeLocalTick
                        };
                    }, Scene.prototype.prefetch = function() {
                        this._loaded || this._prefetchRequested || (this._prefetchRequested = !0, this._sceneAssetHolder.request());
                    }, Scene.prototype.serializeStorageValues = function() {
                        if (this._storageLoader) return this._storageLoader._valueStoreSerialization;
                    }, Scene.prototype.requestAssets = function(assetIds, handler) {
                        if (this._loadingState < SceneLoadState.ReadyFired) throw g.ExceptionFactory.createAssertionError("Scene#requestAsset(): can be called after loaded.");
                        var holder = new SceneAssetHolder({
                            scene: this,
                            assetManager: this.game._assetManager,
                            assetIds: assetIds,
                            handler: handler
                        });
                        this._assetHolders.push(holder), holder.request();
                    }, Scene.prototype._activate = function() {
                        this.state = SceneState.Active, this.stateChanged.fire(this.state);
                    }, Scene.prototype._deactivate = function() {
                        this.state = SceneState.Deactive, this.stateChanged.fire(this.state);
                    }, Scene.prototype._needsLoading = function() {
                        return this._sceneAssetHolder.waitingAssetsCount > 0 || this._storageLoader && !this._storageLoader._loaded;
                    }, Scene.prototype._load = function() {
                        if (!this._loaded) {
                            this._loaded = !0;
                            var needsWait = this._sceneAssetHolder.request();
                            this._storageLoader && (this._storageLoader._load(this), needsWait = !0), needsWait || this._notifySceneReady();
                        }
                    }, Scene.prototype._onSceneAssetsLoad = function() {
                        this._loaded && (this._storageLoader && !this._storageLoader._loaded || this._notifySceneReady());
                    }, Scene.prototype._onStorageLoadError = function(error) {
                        this.game.terminateGame();
                    }, Scene.prototype._onStorageLoaded = function() {
                        0 === this._sceneAssetHolder.waitingAssetsCount && this._notifySceneReady();
                    }, Scene.prototype._notifySceneReady = function() {
                        this._loadingState = SceneLoadState.Ready, this.game._fireSceneReady(this);
                    }, Scene.prototype._fireReady = function() {
                        this._ready.fire(this), this._loadingState = SceneLoadState.ReadyFired;
                    }, Scene.prototype._fireLoaded = function() {
                        this.loaded.fire(this), this._loadingState = SceneLoadState.LoadedFired;
                    }, Scene;
                }();
                g.Scene = Scene;
            }(g || (g = {}));
            var g;
            !function(g) {
                var LoadingScene = function(_super) {
                    function LoadingScene(param) {
                        var _this = this;
                        return param.local = !0, _this = _super.call(this, param) || this, _this.targetReset = new g.Trigger(), 
                        _this.targetReady = new g.Trigger(), _this.targetAssetLoaded = new g.Trigger(), 
                        _this._explicitEnd = !!param.explicitEnd, _this._targetScene = void 0, _this;
                    }
                    return __extends(LoadingScene, _super), LoadingScene.prototype.destroy = function() {
                        this._clearTargetScene(), _super.prototype.destroy.call(this);
                    }, LoadingScene.prototype.reset = function(targetScene) {
                        this._clearTargetScene(), this._targetScene = targetScene, this._loadingState < g.SceneLoadState.LoadedFired ? this.loaded.handle(this, this._doReset) : this._doReset();
                    }, LoadingScene.prototype.getTargetWaitingAssetsCount = function() {
                        return this._targetScene ? this._targetScene._sceneAssetHolder.waitingAssetsCount : 0;
                    }, LoadingScene.prototype.end = function() {
                        if (!this._targetScene || this._targetScene._loadingState < g.SceneLoadState.Ready) {
                            var state = this._targetScene ? g.SceneLoadState[this._targetScene._loadingState] : "(no scene)", msg = "LoadingScene#end(): the target scene is in invalid state: " + state;
                            throw g.ExceptionFactory.createAssertionError(msg);
                        }
                        this.game.popScene(!0), this.game._fireSceneLoaded(this._targetScene), this._clearTargetScene();
                    }, LoadingScene.prototype._clearTargetScene = function() {
                        this._targetScene && (this._targetScene._ready.removeAll(this), this._targetScene.assetLoaded.removeAll(this), 
                        this._targetScene = void 0);
                    }, LoadingScene.prototype._doReset = function() {
                        return this.targetReset.fire(this._targetScene), this._targetScene._loadingState < g.SceneLoadState.ReadyFired ? (this._targetScene._ready.handle(this, this._fireTriggerOnTargetReady), 
                        this._targetScene.assetLoaded.handle(this, this._fireTriggerOnTargetAssetLoad), 
                        this._targetScene._load()) : this._fireTriggerOnTargetReady(this._targetScene), 
                        !0;
                    }, LoadingScene.prototype._fireTriggerOnTargetAssetLoad = function(asset) {
                        this._onTargetAssetLoad(asset), this.targetAssetLoaded.fire(asset);
                    }, LoadingScene.prototype._fireTriggerOnTargetReady = function(scene) {
                        this.targetReady.fire(scene), this._explicitEnd || this.end();
                    }, LoadingScene.prototype._onTargetAssetLoad = function(asset) {
                        return !0;
                    }, LoadingScene;
                }(g.Scene);
                g.LoadingScene = LoadingScene;
            }(g || (g = {}));
            var g;
            !function(g) {
                var CameraCancellingE = function(_super) {
                    function CameraCancellingE(param) {
                        var _this = _super.call(this, param) || this;
                        return _this._canceller = new g.Object2D(), _this;
                    }
                    return __extends(CameraCancellingE, _super), CameraCancellingE.prototype.renderSelf = function(renderer, camera) {
                        if (!this.children) return !1;
                        if (camera) {
                            var c = camera, canceller = this._canceller;
                            c.x === canceller.x && c.y === canceller.y && c.angle === canceller.angle && c.scaleX === canceller.scaleX && c.scaleY === canceller.scaleY || (canceller.x = c.x, 
                            canceller.y = c.y, canceller.angle = c.angle, canceller.scaleX = c.scaleX, canceller.scaleY = c.scaleY, 
                            canceller._matrix && (canceller._matrix._modified = !0)), renderer.save(), renderer.transform(canceller.getMatrix()._matrix);
                        }
                        for (var children = this.children, i = 0; i < children.length; ++i) children[i].render(renderer, camera);
                        return camera && renderer.restore(), !1;
                    }, CameraCancellingE;
                }(g.E), DefaultLoadingScene = function(_super) {
                    function DefaultLoadingScene(param) {
                        var _this = _super.call(this, {
                            game: param.game,
                            name: "akashic:default-loading-scene"
                        }) || this;
                        return _this._barWidth = Math.min(param.game.width, Math.max(100, param.game.width / 2)), 
                        _this._barHeight = 5, _this._gauge = void 0, _this._gaugeUpdateCount = 0, _this._totalWaitingAssetCount = 0, 
                        _this.loaded.handle(_this, _this._onLoaded), _this.targetReset.handle(_this, _this._onTargetReset), 
                        _this.targetAssetLoaded.handle(_this, _this._onTargetAssetLoaded), _this;
                    }
                    return __extends(DefaultLoadingScene, _super), DefaultLoadingScene.prototype._onLoaded = function() {
                        var gauge;
                        return this.append(new CameraCancellingE({
                            scene: this,
                            children: [ new g.FilledRect({
                                scene: this,
                                width: this.game.width,
                                height: this.game.height,
                                cssColor: "rgba(0, 0, 0, 0.8)",
                                children: [ new g.FilledRect({
                                    scene: this,
                                    x: (this.game.width - this._barWidth) / 2,
                                    y: (this.game.height - this._barHeight) / 2,
                                    width: this._barWidth,
                                    height: this._barHeight,
                                    cssColor: "gray",
                                    children: [ gauge = new g.FilledRect({
                                        scene: this,
                                        width: 0,
                                        height: this._barHeight,
                                        cssColor: "white"
                                    }) ]
                                }) ]
                            }) ]
                        })), gauge.update.handle(this, this._onUpdateGuage), this._gauge = gauge, !0;
                    }, DefaultLoadingScene.prototype._onUpdateGuage = function() {
                        var BLINK_RANGE = 50, BLINK_PER_SEC = 2 / 3;
                        ++this._gaugeUpdateCount;
                        var c = Math.round(255 - BLINK_RANGE + Math.sin(this._gaugeUpdateCount / this.game.fps * BLINK_PER_SEC * (2 * Math.PI)) * BLINK_RANGE);
                        this._gauge.cssColor = "rgb(" + c + "," + c + "," + c + ")", this._gauge.modified();
                    }, DefaultLoadingScene.prototype._onTargetReset = function(targetScene) {
                        this._gauge && (this._gauge.width = 0, this._gauge.modified()), this._totalWaitingAssetCount = targetScene._sceneAssetHolder.waitingAssetsCount;
                    }, DefaultLoadingScene.prototype._onTargetAssetLoaded = function(asset) {
                        var waitingAssetsCount = this._targetScene._sceneAssetHolder.waitingAssetsCount;
                        this._gauge.width = Math.ceil((1 - waitingAssetsCount / this._totalWaitingAssetCount) * this._barWidth), 
                        this._gauge.modified();
                    }, DefaultLoadingScene;
                }(g.LoadingScene);
                g.DefaultLoadingScene = DefaultLoadingScene;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Sprite = function(_super) {
                    function Sprite(sceneOrParam, src, width, height) {
                        var _this = this;
                        if (sceneOrParam instanceof g.Scene) {
                            var scene = sceneOrParam;
                            _this = _super.call(this, scene) || this, _this.surface = g.Util.asSurface(src), 
                            _this.width = void 0 !== width ? width : _this.surface.width, _this.height = void 0 !== height ? height : _this.surface.height, 
                            _this.srcWidth = _this.width, _this.srcHeight = _this.height, _this.srcX = 0, _this.srcY = 0, 
                            _this._stretchMatrix = void 0, _this._beforeSurface = _this.surface, g.Util.setupAnimatingHandler(_this, _this.surface);
                        } else {
                            var param = sceneOrParam;
                            _this = _super.call(this, param) || this, _this.surface = g.Util.asSurface(param.src), 
                            "width" in param || (_this.width = _this.surface.width), "height" in param || (_this.height = _this.surface.height), 
                            _this.srcWidth = "srcWidth" in param ? param.srcWidth : _this.width, _this.srcHeight = "srcHeight" in param ? param.srcHeight : _this.height, 
                            _this.srcX = param.srcX || 0, _this.srcY = param.srcY || 0, _this._stretchMatrix = void 0, 
                            _this._beforeSurface = _this.surface, g.Util.setupAnimatingHandler(_this, _this.surface), 
                            _this._invalidateSelf();
                        }
                        return _this;
                    }
                    return __extends(Sprite, _super), Sprite.prototype._onUpdate = function() {
                        this.modified();
                    }, Sprite.prototype._onAnimatingStarted = function() {
                        this.update.isHandled(this, this._onUpdate) || this.update.handle(this, this._onUpdate);
                    }, Sprite.prototype._onAnimatingStopped = function() {
                        this.destroyed() || this.update.remove(this, this._onUpdate);
                    }, Sprite.prototype.renderSelf = function(renderer, camera) {
                        return this.srcWidth <= 0 || this.srcHeight <= 0 || (this._stretchMatrix && (renderer.save(), 
                        renderer.transform(this._stretchMatrix._matrix)), renderer.drawImage(this.surface, this.srcX, this.srcY, this.srcWidth, this.srcHeight, 0, 0), 
                        this._stretchMatrix && renderer.restore(), !0);
                    }, Sprite.prototype.invalidate = function() {
                        this._invalidateSelf(), this.modified();
                    }, Sprite.prototype.destroy = function(destroySurface) {
                        this.surface && !this.surface.destroyed() && (destroySurface ? this.surface.destroy() : this.surface.isDynamic && (this.surface.animatingStarted.remove(this, this._onAnimatingStarted), 
                        this.surface.animatingStopped.remove(this, this._onAnimatingStopped))), this.surface = void 0, 
                        _super.prototype.destroy.call(this);
                    }, Sprite.prototype._invalidateSelf = function() {
                        this.width === this.srcWidth && this.height === this.srcHeight ? this._stretchMatrix = void 0 : (this._stretchMatrix = g.Util.createMatrix(), 
                        this._stretchMatrix.scale(this.width / this.srcWidth, this.height / this.srcHeight)), 
                        this.surface !== this._beforeSurface && (g.Util.migrateAnimatingHandler(this, this._beforeSurface, this.surface), 
                        this._beforeSurface = this.surface);
                    }, Sprite;
                }(g.E);
                g.Sprite = Sprite;
            }(g || (g = {}));
            var g;
            !function(g) {
                var FrameSprite = function(_super) {
                    function FrameSprite(sceneOrParam, src, width, height) {
                        var _this = this;
                        if (sceneOrParam instanceof g.Scene) {
                            var scene = sceneOrParam;
                            _this = _super.call(this, scene, src, width, height) || this, _this._lastUsedIndex = 0, 
                            _this.frameNumber = 0, _this.frames = [ 0 ], _this.interval = void 0, _this._timer = void 0;
                        } else {
                            var param = sceneOrParam;
                            _this = _super.call(this, param) || this, _this._lastUsedIndex = 0, _this.frameNumber = param.frameNumber || 0, 
                            _this.frames = "frames" in param ? param.frames : [ 0 ], _this.interval = param.interval, 
                            _this._timer = void 0, _this._modifiedSelf();
                        }
                        return _this;
                    }
                    return __extends(FrameSprite, _super), FrameSprite.createBySprite = function(sprite, width, height) {
                        var frameSprite = new FrameSprite({
                            scene: sprite.scene,
                            src: sprite.surface,
                            width: void 0 === width ? sprite.width : width,
                            height: void 0 === height ? sprite.height : height
                        });
                        return frameSprite.srcHeight = void 0 === height ? sprite.srcHeight : height, frameSprite.srcWidth = void 0 === width ? sprite.srcWidth : width, 
                        frameSprite;
                    }, FrameSprite.prototype.start = function() {
                        void 0 === this.interval && (this.interval = 1e3 / this.game().fps), this._timer && this._free(), 
                        this._timer = this.scene.createTimer(this.interval), this._timer.elapsed.handle(this, this._onElapsed);
                    }, FrameSprite.prototype.destroy = function(destroySurface) {
                        this.stop(), _super.prototype.destroy.call(this, destroySurface);
                    }, FrameSprite.prototype.stop = function() {
                        this._timer && this._free();
                    }, FrameSprite.prototype.modified = function(isBubbling) {
                        this._modifiedSelf(isBubbling), _super.prototype.modified.call(this, isBubbling);
                    }, FrameSprite.prototype._onElapsed = function() {
                        ++this.frameNumber >= this.frames.length && (this.frameNumber = 0), this.modified();
                    }, FrameSprite.prototype._free = function() {
                        this._timer && (this._timer.elapsed.remove(this, this._onElapsed), this._timer.canDelete() && this.scene.deleteTimer(this._timer), 
                        this._timer = void 0);
                    }, FrameSprite.prototype._changeFrame = function() {
                        var frame = this.frames[this.frameNumber], sep = Math.floor(this.surface.width / this.srcWidth);
                        this.srcX = frame % sep * this.srcWidth, this.srcY = Math.floor(frame / sep) * this.srcHeight, 
                        this._lastUsedIndex = frame;
                    }, FrameSprite.prototype._modifiedSelf = function(isBubbling) {
                        this._lastUsedIndex !== this.frames[this.frameNumber] && this._changeFrame();
                    }, FrameSprite;
                }(g.Sprite);
                g.FrameSprite = FrameSprite;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Tile = function(_super) {
                    function Tile(sceneOrParam, src, tileWidth, tileHeight, tileData) {
                        var _this = this;
                        if (sceneOrParam instanceof g.Scene) {
                            var scene = sceneOrParam;
                            _this = _super.call(this, scene) || this, _this.tileWidth = tileWidth, _this.tileHeight = tileHeight, 
                            _this.tileData = tileData, _this.tileChips = g.Util.asSurface(src), _this.height = _this.tileHeight * _this.tileData.length, 
                            _this.width = _this.tileWidth * _this.tileData[0].length, _this._tilesInRow = Math.floor(_this.tileChips.width / _this.tileWidth);
                        } else {
                            var param = sceneOrParam;
                            _this = _super.call(this, param) || this, _this.tileWidth = param.tileWidth, _this.tileHeight = param.tileHeight, 
                            _this.tileData = param.tileData, _this.tileChips = g.Util.asSurface(param.src), 
                            _this.height = _this.tileHeight * _this.tileData.length, _this.width = _this.tileWidth * _this.tileData[0].length;
                        }
                        return _this._beforeTileChips = _this.tileChips, g.Util.setupAnimatingHandler(_this, _this.tileChips), 
                        _this._invalidateSelf(), _this;
                    }
                    return __extends(Tile, _super), Tile.prototype._onUpdate = function() {
                        this.invalidate();
                    }, Tile.prototype._onAnimatingStarted = function() {
                        this.update.isHandled(this, this._onUpdate) || this.update.handle(this, this._onUpdate);
                    }, Tile.prototype._onAnimatingStopped = function() {
                        this.destroyed() || this.update.remove(this, this._onUpdate);
                    }, Tile.prototype.renderCache = function(renderer) {
                        if (!this.tileData) throw g.ExceptionFactory.createAssertionError("Tile#_renderCache: don't have a tile data");
                        if (!(this.tileWidth <= 0 || this.tileHeight <= 0)) for (var y = 0; y < this.tileData.length; ++y) for (var row = this.tileData[y], x = 0; x < row.length; ++x) {
                            var tile = row[x];
                            if (!(tile < 0)) {
                                var tileX = this.tileWidth * (tile % this._tilesInRow), tileY = this.tileHeight * Math.floor(tile / this._tilesInRow), dx = this.tileWidth * x, dy = this.tileHeight * y;
                                renderer.drawImage(this.tileChips, tileX, tileY, this.tileWidth, this.tileHeight, dx, dy);
                            }
                        }
                    }, Tile.prototype.invalidate = function() {
                        this._invalidateSelf(), _super.prototype.invalidate.call(this);
                    }, Tile.prototype.destroy = function(destroySurface) {
                        destroySurface && this.tileChips && !this.tileChips.destroyed() && this.tileChips.destroy(), 
                        this.tileChips = void 0, _super.prototype.destroy.call(this);
                    }, Tile.prototype._invalidateSelf = function() {
                        this._tilesInRow = Math.floor(this.tileChips.width / this.tileWidth), this.tileChips !== this._beforeTileChips && (g.Util.migrateAnimatingHandler(this, this._beforeTileChips, this.tileChips), 
                        this._beforeTileChips = this.tileChips);
                    }, Tile;
                }(g.CacheableE);
                g.Tile = Tile;
            }(g || (g = {}));
            var g;
            !function(g) {
                var EventType;
                !function(EventType) {
                    EventType[EventType.Unknown = 0] = "Unknown", EventType[EventType.Join = 1] = "Join", 
                    EventType[EventType.Leave = 2] = "Leave", EventType[EventType.Timestamp = 3] = "Timestamp", 
                    EventType[EventType.Seed = 4] = "Seed", EventType[EventType.PointDown = 5] = "PointDown", 
                    EventType[EventType.PointMove = 6] = "PointMove", EventType[EventType.PointUp = 7] = "PointUp", 
                    EventType[EventType.Message = 8] = "Message", EventType[EventType.Operation = 9] = "Operation";
                }(EventType = g.EventType || (g.EventType = {}));
                var PointEvent = function() {
                    function PointEvent(pointerId, target, point, player, local, priority) {
                        this.priority = priority, this.local = local, this.player = player, this.pointerId = pointerId, 
                        this.target = target, this.point = point;
                    }
                    return PointEvent;
                }();
                g.PointEvent = PointEvent;
                var PointDownEvent = function(_super) {
                    function PointDownEvent(pointerId, target, point, player, local, priority) {
                        var _this = _super.call(this, pointerId, target, point, player, local, priority) || this;
                        return _this.type = EventType.PointDown, _this;
                    }
                    return __extends(PointDownEvent, _super), PointDownEvent;
                }(PointEvent);
                g.PointDownEvent = PointDownEvent;
                var PointUpEvent = function(_super) {
                    function PointUpEvent(pointerId, target, point, prevDelta, startDelta, player, local, priority) {
                        var _this = _super.call(this, pointerId, target, point, player, local, priority) || this;
                        return _this.type = EventType.PointUp, _this.prevDelta = prevDelta, _this.startDelta = startDelta, 
                        _this;
                    }
                    return __extends(PointUpEvent, _super), PointUpEvent;
                }(PointEvent);
                g.PointUpEvent = PointUpEvent;
                var PointMoveEvent = function(_super) {
                    function PointMoveEvent(pointerId, target, point, prevDelta, startDelta, player, local, priority) {
                        var _this = _super.call(this, pointerId, target, point, player, local, priority) || this;
                        return _this.type = EventType.PointMove, _this.prevDelta = prevDelta, _this.startDelta = startDelta, 
                        _this;
                    }
                    return __extends(PointMoveEvent, _super), PointMoveEvent;
                }(PointEvent);
                g.PointMoveEvent = PointMoveEvent;
                var MessageEvent = function() {
                    function MessageEvent(data, player, local, priority) {
                        this.type = EventType.Message, this.priority = priority, this.local = local, this.player = player, 
                        this.data = data;
                    }
                    return MessageEvent;
                }();
                g.MessageEvent = MessageEvent;
                var OperationEvent = function() {
                    function OperationEvent(code, data, player, local, priority) {
                        this.type = EventType.Operation, this.priority = priority, this.local = local, this.player = player, 
                        this.code = code, this.data = data;
                    }
                    return OperationEvent;
                }();
                g.OperationEvent = OperationEvent;
                var JoinEvent = function() {
                    function JoinEvent(player, storageValues, priority) {
                        this.type = EventType.Join, this.priority = priority, this.player = player, this.storageValues = storageValues;
                    }
                    return JoinEvent;
                }();
                g.JoinEvent = JoinEvent;
                var LeaveEvent = function() {
                    function LeaveEvent(player, priority) {
                        this.type = EventType.Leave, this.priority = priority, this.player = player;
                    }
                    return LeaveEvent;
                }();
                g.LeaveEvent = LeaveEvent;
                var TimestampEvent = function() {
                    function TimestampEvent(timestamp, player, priority) {
                        this.type = EventType.Timestamp, this.priority = priority, this.player = player, 
                        this.timestamp = timestamp;
                    }
                    return TimestampEvent;
                }();
                g.TimestampEvent = TimestampEvent;
                var SeedEvent = function() {
                    function SeedEvent(generator, priority) {
                        this.type = EventType.Seed, this.priority = priority, this.generator = generator;
                    }
                    return SeedEvent;
                }();
                g.SeedEvent = SeedEvent;
            }(g || (g = {}));
            var g;
            !function(g) {
                var LogLevel;
                !function(LogLevel) {
                    LogLevel[LogLevel.Error = 0] = "Error", LogLevel[LogLevel.Warn = 1] = "Warn", LogLevel[LogLevel.Info = 2] = "Info", 
                    LogLevel[LogLevel.Debug = 3] = "Debug";
                }(LogLevel = g.LogLevel || (g.LogLevel = {}));
                var Logger = function() {
                    function Logger(game) {
                        this.game = game, this.logging = new g.Trigger();
                    }
                    return Logger.prototype.error = function(message, cause) {
                        this.logging.fire({
                            game: this.game,
                            level: LogLevel.Error,
                            message: message,
                            cause: cause
                        });
                    }, Logger.prototype.warn = function(message, cause) {
                        this.logging.fire({
                            game: this.game,
                            level: LogLevel.Warn,
                            message: message,
                            cause: cause
                        });
                    }, Logger.prototype.info = function(message, cause) {
                        this.logging.fire({
                            game: this.game,
                            level: LogLevel.Info,
                            message: message,
                            cause: cause
                        });
                    }, Logger.prototype.debug = function(message, cause) {
                        this.logging.fire({
                            game: this.game,
                            level: LogLevel.Debug,
                            message: message,
                            cause: cause
                        });
                    }, Logger;
                }();
                g.Logger = Logger;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Game = function() {
                    function Game(gameConfiguration, resourceFactory, assetBase, selfId, operationPluginViewInfo) {
                        gameConfiguration = this._normalizeConfiguration(gameConfiguration), this.fps = gameConfiguration.fps, 
                        this.width = gameConfiguration.width, this.height = gameConfiguration.height, this.renderers = [], 
                        this.scenes = [], this.random = [], this.age = 0, this.assetBase = assetBase || "", 
                        this.resourceFactory = resourceFactory, this.selfId = selfId || void 0, this.playId = void 0, 
                        this._audioSystemManager = new g.AudioSystemManager(this), this.audio = {
                            music: new g.MusicAudioSystem("music", this),
                            sound: new g.SoundAudioSystem("sound", this)
                        }, this.defaultAudioSystemId = "sound", this.storage = new g.Storage(this), this.assets = {}, 
                        this.join = new g.Trigger(), this.leave = new g.Trigger(), this.seed = new g.Trigger(), 
                        this._eventTriggerMap = {}, this._eventTriggerMap[g.EventType.Join] = this.join, 
                        this._eventTriggerMap[g.EventType.Leave] = this.leave, this._eventTriggerMap[g.EventType.Seed] = this.seed, 
                        this._eventTriggerMap[g.EventType.Message] = void 0, this._eventTriggerMap[g.EventType.PointDown] = void 0, 
                        this._eventTriggerMap[g.EventType.PointMove] = void 0, this._eventTriggerMap[g.EventType.PointUp] = void 0, 
                        this._eventTriggerMap[g.EventType.Operation] = void 0, this._loaded = new g.Trigger(), 
                        this._started = new g.Trigger(), this.isLoaded = !1, this.snapshotRequest = new g.Trigger(), 
                        this.external = {}, this.logger = new g.Logger(this), this._main = gameConfiguration.main, 
                        this._mainParameter = void 0, this._configuration = gameConfiguration, this._assetManager = new g.AssetManager(this, gameConfiguration.assets, gameConfiguration.audio);
                        var operationPluginsField = gameConfiguration.operationPlugins || [];
                        this._operationPluginManager = new g.OperationPluginManager(this, operationPluginViewInfo, operationPluginsField), 
                        this._operationPluginOperated = new g.Trigger(), this._operationPluginManager.operated.handle(this._operationPluginOperated, this._operationPluginOperated.fire), 
                        this._sceneChanged = new g.Trigger(), this._sceneChanged.handle(this, this._updateEventTriggers), 
                        this._initialScene = new g.Scene({
                            game: this,
                            assetIds: this._assetManager.globalAssetIds(),
                            local: !0,
                            name: "akashic:initial-scene"
                        }), this._initialScene.loaded.handle(this, this._onInitialSceneLoaded), this._reset({
                            age: 0
                        });
                    }
                    return Object.defineProperty(Game.prototype, "focusingCamera", {
                        get: function() {
                            return this._focusingCamera;
                        },
                        set: function(c) {
                            c !== this._focusingCamera && (this.modified && this.render(this._focusingCamera), 
                            this._focusingCamera = c);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Game.prototype.pushScene = function(scene) {
                        this._sceneChangeRequests.push({
                            type: 0,
                            scene: scene
                        });
                    }, Game.prototype.replaceScene = function(scene, preserveCurrent) {
                        this._sceneChangeRequests.push({
                            type: 1,
                            scene: scene,
                            preserveCurrent: preserveCurrent
                        });
                    }, Game.prototype.popScene = function(preserveCurrent) {
                        this._sceneChangeRequests.push({
                            type: 2,
                            preserveCurrent: preserveCurrent
                        });
                    }, Game.prototype.scene = function() {
                        if (this.scenes.length) return this.scenes[this.scenes.length - 1];
                    }, Game.prototype.tick = function(advanceAge) {
                        var scene = void 0;
                        if (this._isTerminated) return !1;
                        if (this.scenes.length) {
                            if (scene = this.scenes[this.scenes.length - 1], this.events.length) {
                                var events = this.events;
                                this.events = [];
                                for (var i = 0; i < events.length; ++i) {
                                    var trigger = this._eventTriggerMap[events[i].type];
                                    trigger && trigger.fire(events[i]);
                                }
                            }
                            scene.update.fire(), (advanceAge === !0 || void 0 === advanceAge && scene.local !== g.LocalTickMode.FullLocal) && ++this.age;
                        }
                        return !!this._sceneChangeRequests.length && (this._flushSceneChangeRequests(), 
                        scene !== this.scenes[this.scenes.length - 1]);
                    }, Game.prototype.render = function(camera) {
                        camera || (camera = this.focusingCamera);
                        for (var renderers = this.renderers, i = 0; i < renderers.length; ++i) renderers[i].draw(this, camera);
                        this.modified = !1;
                    }, Game.prototype.findPointSource = function(point, camera) {
                        return camera || (camera = this.focusingCamera), this.scene().findPointSourceByPoint(point, !1, camera);
                    }, Game.prototype.register = function(e) {
                        if (e.local) {
                            if (void 0 === e.id) e.id = --this._localIdx; else {
                                if (e.id > 0) throw g.ExceptionFactory.createAssertionError("Game#register: invalid local id: " + e.id);
                                if (this._localDb.hasOwnProperty(String(e.id))) throw g.ExceptionFactory.createAssertionError("Game#register: conflicted id: " + e.id);
                                this._localIdx > e.id && (this._localIdx = e.id);
                            }
                            this._localDb[e.id] = e;
                        } else {
                            if (void 0 === e.id) e.id = ++this._idx; else {
                                if (e.id < 0) throw g.ExceptionFactory.createAssertionError("Game#register: invalid non-local id: " + e.id);
                                if (this.db.hasOwnProperty(String(e.id))) throw g.ExceptionFactory.createAssertionError("Game#register: conflicted id: " + e.id);
                                this._idx < e.id && (this._idx = e.id);
                            }
                            this.db[e.id] = e;
                        }
                    }, Game.prototype.unregister = function(e) {
                        e.local ? delete this._localDb[e.id] : delete this.db[e.id];
                    }, Game.prototype.leaveGame = function() {
                        this._leaveGame();
                    }, Game.prototype.terminateGame = function() {
                        this._leaveGame(), this._isTerminated = !0, this._terminateGame();
                    }, Game.prototype.raiseEvent = function(e) {
                        throw g.ExceptionFactory.createPureVirtualError("Game#raiseEvent");
                    }, Game.prototype.raiseTick = function(events) {
                        throw g.ExceptionFactory.createPureVirtualError("Game#raiseTick");
                    }, Game.prototype.addEventFilter = function(filter) {
                        throw g.ExceptionFactory.createPureVirtualError("Game#addEventFilter");
                    }, Game.prototype.removeEventFilter = function(filter) {
                        throw g.ExceptionFactory.createPureVirtualError("Game#removeEventFilter");
                    }, Game.prototype.shouldSaveSnapshot = function() {
                        throw g.ExceptionFactory.createPureVirtualError("Game#shouldSaveSnapshot");
                    }, Game.prototype.saveSnapshot = function(snapshot, timestamp) {
                        throw g.ExceptionFactory.createPureVirtualError("Game#saveSnapshot");
                    }, Game.prototype._fireSceneReady = function(scene) {
                        this._sceneChangeRequests.push({
                            type: 3,
                            scene: scene
                        });
                    }, Game.prototype._fireSceneLoaded = function(scene) {
                        scene._loadingState < g.SceneLoadState.LoadedFired && this._sceneChangeRequests.push({
                            type: 4,
                            scene: scene
                        });
                    }, Game.prototype._callSceneAssetHolderHandler = function(assetHolder) {
                        this._sceneChangeRequests.push({
                            type: 5,
                            assetHolder: assetHolder
                        });
                    }, Game.prototype._normalizeConfiguration = function(gameConfiguration) {
                        if (!gameConfiguration) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: invalid arguments");
                        if ("assets" in gameConfiguration || (gameConfiguration.assets = {}), "fps" in gameConfiguration || (gameConfiguration.fps = 30), 
                        "number" != typeof gameConfiguration.fps) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: fps must be given as a number");
                        if (!(0 <= gameConfiguration.fps && gameConfiguration.fps <= 60)) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: fps must be a number in (0, 60].");
                        if ("number" != typeof gameConfiguration.width) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: width must be given as a number");
                        if ("number" != typeof gameConfiguration.height) throw g.ExceptionFactory.createAssertionError("Game#_normalizeConfiguration: height must be given as a number");
                        return gameConfiguration;
                    }, Game.prototype._setAudioPlaybackRate = function(playbackRate) {
                        this._audioSystemManager._setPlaybackRate(playbackRate);
                    }, Game.prototype._setMuted = function(muted) {
                        this._audioSystemManager._setMuted(muted);
                    }, Game.prototype._decodeOperationPluginOperation = function(code, op) {
                        var plugins = this._operationPluginManager.plugins;
                        return plugins[code] && plugins[code].decode ? plugins[code].decode(op) : op;
                    }, Game.prototype._reset = function(param) {
                        if (this._operationPluginManager.stopAll(), this.scene()) {
                            for (;this.scene() !== this._initialScene; ) this.popScene(), this._flushSceneChangeRequests();
                            this.isLoaded || this.scenes.pop();
                        }
                        switch (param && (void 0 !== param.age && (this.age = param.age), void 0 !== param.randGen && (this.random[0] = param.randGen)), 
                        this._loaded.removeAllByHandler(this._start), this.join._reset(), this.leave._reset(), 
                        this.seed._reset(), this._idx = 0, this._localIdx = 0, this._cameraIdx = 0, this.db = {}, 
                        this._localDb = {}, this.events = [], this.modified = !0, this.loadingScene = void 0, 
                        this._focusingCamera = void 0, this._scriptCaches = {}, this.snapshotRequest._reset(), 
                        this._sceneChangeRequests = [], this._isTerminated = !1, this.vars = {}, this._configuration.defaultLoadingScene) {
                          case "none":
                            this._defaultLoadingScene = new g.LoadingScene({
                                game: this
                            });
                            break;

                          default:
                            this._defaultLoadingScene = new g.DefaultLoadingScene({
                                game: this
                            });
                        }
                    }, Game.prototype._loadAndStart = function(param) {
                        this._mainParameter = param || {}, this.isLoaded ? this._start() : (this._loaded.handle(this, this._start), 
                        this.pushScene(this._initialScene), this._flushSceneChangeRequests());
                    }, Game.prototype._startLoadingGlobalAssets = function() {
                        if (this.isLoaded) throw g.ExceptionFactory.createAssertionError("Game#_startLoadingGlobalAssets: already loaded.");
                        this.pushScene(this._initialScene), this._flushSceneChangeRequests();
                    }, Game.prototype._updateEventTriggers = function(scene) {
                        return this.modified = !0, scene ? (this._eventTriggerMap[g.EventType.Message] = scene.message, 
                        this._eventTriggerMap[g.EventType.PointDown] = scene.pointDownCapture, this._eventTriggerMap[g.EventType.PointMove] = scene.pointMoveCapture, 
                        this._eventTriggerMap[g.EventType.PointUp] = scene.pointUpCapture, this._eventTriggerMap[g.EventType.Operation] = scene.operation, 
                        void scene._activate()) : (this._eventTriggerMap[g.EventType.Message] = void 0, 
                        this._eventTriggerMap[g.EventType.PointDown] = void 0, this._eventTriggerMap[g.EventType.PointMove] = void 0, 
                        this._eventTriggerMap[g.EventType.PointUp] = void 0, void (this._eventTriggerMap[g.EventType.Operation] = void 0));
                    }, Game.prototype._onInitialSceneLoaded = function() {
                        this._initialScene.loaded.remove(this, this._onInitialSceneLoaded), this.assets = this._initialScene.assets, 
                        this.isLoaded = !0, this._loaded.fire();
                    }, Game.prototype._leaveGame = function() {
                        throw g.ExceptionFactory.createPureVirtualError("Game#_leaveGame");
                    }, Game.prototype._terminateGame = function() {}, Game.prototype._flushSceneChangeRequests = function() {
                        do {
                            var reqs = this._sceneChangeRequests;
                            this._sceneChangeRequests = [];
                            for (var i = 0; i < reqs.length; ++i) {
                                var req = reqs[i];
                                switch (req.type) {
                                  case 0:
                                    var oldScene = this.scene();
                                    oldScene && oldScene._deactivate(), this._doPushScene(req.scene);
                                    break;

                                  case 1:
                                    this._doPopScene(req.preserveCurrent, !1), this._doPushScene(req.scene);
                                    break;

                                  case 2:
                                    this._doPopScene(req.preserveCurrent, !0);
                                    break;

                                  case 3:
                                    req.scene._fireReady();
                                    break;

                                  case 4:
                                    req.scene._fireLoaded();
                                    break;

                                  case 5:
                                    req.assetHolder.callHandler();
                                    break;

                                  default:
                                    throw g.ExceptionFactory.createAssertionError("Game#_flushSceneChangeRequests: unknown scene change request.");
                                }
                            }
                        } while (this._sceneChangeRequests.length > 0);
                    }, Game.prototype._doPopScene = function(preserveCurrent, fireSceneChanged) {
                        var scene = this.scenes.pop();
                        if (scene === this._initialScene) throw g.ExceptionFactory.createAssertionError("Game#_doPopScene: invalid call; attempting to pop the initial scene");
                        preserveCurrent || scene.destroy(), fireSceneChanged && this._sceneChanged.fire(this.scene());
                    }, Game.prototype._start = function() {
                        if (this._operationPluginManager.initialize(), this.operationPlugins = this._operationPluginManager.plugins, 
                        !this._main) {
                            if (this._mainParameter.snapshot) {
                                if (!this.assets.snapshotLoader) throw g.ExceptionFactory.createAssertionError("Game#_start: global asset 'snapshotLoader' not found.");
                                var loader = g._require(this, "snapshotLoader");
                                loader(this._mainParameter.snapshot), this._flushSceneChangeRequests();
                            } else {
                                if (!this.assets.mainScene) throw g.ExceptionFactory.createAssertionError("Game#_start: global asset 'mainScene' not found.");
                                var mainScene = g._require(this, "mainScene")();
                                this.pushScene(mainScene), this._flushSceneChangeRequests();
                            }
                            return void this._started.fire();
                        }
                        var mainFun = g._require(this, this._main);
                        if (!mainFun || "function" != typeof mainFun) throw g.ExceptionFactory.createAssertionError("Game#_start: Entry point '" + this._main + "' not found.");
                        mainFun(this._mainParameter), this._flushSceneChangeRequests(), this._started.fire();
                    }, Game.prototype._doPushScene = function(scene, loadingScene) {
                        if (loadingScene || (loadingScene = this.loadingScene || this._defaultLoadingScene), 
                        this.scenes.push(scene), scene._needsLoading() && scene._loadingState < g.SceneLoadState.LoadedFired) {
                            if (this._defaultLoadingScene._needsLoading()) throw g.ExceptionFactory.createAssertionError("Game#_doPushScene: _defaultLoadingScene must not depend on any assets/storages.");
                            this._doPushScene(loadingScene, this._defaultLoadingScene), loadingScene.reset(scene);
                        } else this._sceneChanged.fire(scene), scene._loaded || (scene._load(), this._fireSceneLoaded(scene));
                        this.modified = !0;
                    }, Game;
                }();
                g.Game = Game;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Camera2D = function(_super) {
                    function Camera2D(gameOrParam) {
                        var _this = this;
                        if (gameOrParam instanceof g.Game) {
                            var game = gameOrParam;
                            _this = _super.call(this) || this, _this.game = game, _this.local = !1, _this.name = void 0, 
                            _this._modifiedCount = 0, _this.width = game.width, _this.height = game.height, 
                            game.logger.debug("[deprecated] Camera2D:This constructor is deprecated. Refer to the API documentation and use Camera2D(param: Camera2DParameterObject) instead.");
                        } else {
                            var param = gameOrParam;
                            _this = _super.call(this, param) || this, _this.game = param.game, _this.local = !!param.local, 
                            _this.name = param.name, _this._modifiedCount = 0, _this.width = param.game.width, 
                            _this.height = param.game.height;
                        }
                        return _this.id = _this.local ? void 0 : _this.game._cameraIdx++, _this;
                    }
                    return __extends(Camera2D, _super), Camera2D.deserialize = function(ser, game) {
                        var s = ser;
                        s.param.game = game;
                        var ret = new Camera2D(s.param);
                        return ret.id = s.id, ret;
                    }, Camera2D.prototype.modified = function() {
                        this._modifiedCount = (this._modifiedCount + 1) % 32768, this._matrix && (this._matrix._modified = !0), 
                        this.game.modified = !0;
                    }, Camera2D.prototype.serialize = function() {
                        var ser = {
                            id: this.id,
                            param: {
                                game: void 0,
                                local: this.local,
                                name: this.name,
                                x: this.x,
                                y: this.y,
                                width: this.width,
                                height: this.height,
                                opacity: this.opacity,
                                scaleX: this.scaleX,
                                scaleY: this.scaleY,
                                angle: this.angle,
                                compositeOperation: this.compositeOperation
                            }
                        };
                        return ser;
                    }, Camera2D.prototype._applyTransformToRenderer = function(renderer) {
                        this.angle || 1 !== this.scaleX || 1 !== this.scaleY ? renderer.transform(this.getMatrix()._matrix) : renderer.translate(-this.x, -this.y), 
                        1 !== this.opacity && renderer.opacity(this.opacity);
                    }, Camera2D.prototype._updateMatrix = function() {
                        this.angle || 1 !== this.scaleX || 1 !== this.scaleY ? this._matrix.updateByInverse(this.width, this.height, this.scaleX, this.scaleY, this.angle, this.x, this.y) : this._matrix.reset(-this.x, -this.y);
                    }, Camera2D;
                }(g.Object2D);
                g.Camera2D = Camera2D;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Renderer = function() {
                    function Renderer() {}
                    return Renderer.prototype.draw = function(game, camera) {
                        var scene = game.scene();
                        if (scene) {
                            this.begin(), this.clear(), camera && (this.save(), camera._applyTransformToRenderer(this));
                            for (var children = scene.children, i = 0; i < children.length; ++i) children[i].render(this, camera);
                            camera && this.restore(), this.end();
                        }
                    }, Renderer.prototype.begin = function() {}, Renderer.prototype.clear = function() {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#clear");
                    }, Renderer.prototype.drawImage = function(surface, offsetX, offsetY, width, height, destOffsetX, destOffsetY) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#drawImage");
                    }, Renderer.prototype.drawSprites = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, count) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#drawSprites");
                    }, Renderer.prototype.drawSystemText = function(text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#drawSystemText");
                    }, Renderer.prototype.translate = function(x, y) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#translate");
                    }, Renderer.prototype.transform = function(matrix) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#transform");
                    }, Renderer.prototype.opacity = function(opacity) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#opacity");
                    }, Renderer.prototype.save = function() {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#save");
                    }, Renderer.prototype.restore = function() {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#restore");
                    }, Renderer.prototype.fillRect = function(x, y, width, height, cssColor) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#fillRect");
                    }, Renderer.prototype.setCompositeOperation = function(operation) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#setCompositeOperation");
                    }, Renderer.prototype.setTransform = function(matrix) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#setTransform");
                    }, Renderer.prototype.setOpacity = function(opacity) {
                        throw g.ExceptionFactory.createPureVirtualError("Renderer#setOpacity");
                    }, Renderer.prototype.end = function() {}, Renderer;
                }();
                g.Renderer = Renderer;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Surface = function() {
                    function Surface(width, height, drawable, isDynamic) {
                        if (void 0 === isDynamic && (isDynamic = !1), width % 1 !== 0 || height % 1 !== 0) throw g.ExceptionFactory.createAssertionError("Surface#constructor: width and height must be integers");
                        this.width = width, this.height = height, drawable && (this._drawable = drawable), 
                        this.isDynamic = isDynamic, this.isDynamic ? (this.animatingStarted = new g.Trigger(), 
                        this.animatingStopped = new g.Trigger()) : (this.animatingStarted = void 0, this.animatingStopped = void 0);
                    }
                    return Surface.prototype.renderer = function() {
                        throw g.ExceptionFactory.createPureVirtualError("Surface#renderer");
                    }, Surface.prototype.isPlaying = function() {
                        throw g.ExceptionFactory.createPureVirtualError("Surface#isPlaying()");
                    }, Surface.prototype.destroy = function() {
                        this.animatingStarted && this.animatingStarted.destroy(), this.animatingStopped && this.animatingStopped.destroy(), 
                        this._destroyed = !0;
                    }, Surface.prototype.destroyed = function() {
                        return !!this._destroyed;
                    }, Surface;
                }();
                g.Surface = Surface;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Label = function(_super) {
                    function Label(sceneOrParam, text, font, fontSize) {
                        var _this = this;
                        if (sceneOrParam instanceof g.Scene) {
                            var scene = sceneOrParam;
                            _this = _super.call(this, scene) || this, _this.text = text, _this.bitmapFont = font, 
                            _this.font = font, _this.textAlign = g.TextAlign.Left, _this.glyphs = new Array(text.length), 
                            _this.fontSize = fontSize, _this.maxWidth = void 0, _this.widthAutoAdjust = !0, 
                            _this.textColor = void 0, _this._textWidth = 0, _this._game = void 0, _this._invalidateSelf();
                        } else {
                            var param = sceneOrParam;
                            if (!param.font && !param.bitmapFont) throw g.ExceptionFactory.createAssertionError("Label#constructor: 'font' or 'bitmapFont' must be given to LabelParameterObject");
                            _this = _super.call(this, param) || this, _this.text = param.text, _this.bitmapFont = param.bitmapFont, 
                            _this.font = param.font ? param.font : param.bitmapFont, _this.textAlign = "textAlign" in param ? param.textAlign : g.TextAlign.Left, 
                            _this.glyphs = new Array(param.text.length), _this.fontSize = param.fontSize, _this.maxWidth = param.maxWidth, 
                            _this.widthAutoAdjust = !("widthAutoAdjust" in param) || param.widthAutoAdjust, 
                            _this.textColor = param.textColor, _this._textWidth = 0, _this._game = void 0, _this._invalidateSelf();
                        }
                        return _this;
                    }
                    return __extends(Label, _super), Label.prototype.aligning = function(width, textAlign) {
                        this.width = width, this.widthAutoAdjust = !1, this.textAlign = textAlign;
                    }, Label.prototype.invalidate = function() {
                        this._invalidateSelf(), _super.prototype.invalidate.call(this);
                    }, Label.prototype.renderCache = function(renderer) {
                        if (!(!this.fontSize || this.height <= 0 || this._textWidth <= 0)) {
                            var textSurface = this.scene.game.resourceFactory.createSurface(Math.ceil(this._textWidth), Math.ceil(this.height)), textRenderer = textSurface.renderer();
                            textRenderer.begin(), textRenderer.save();
                            for (var i = 0; i < this.glyphs.length; ++i) {
                                var glyph = this.glyphs[i], glyphScale = this.fontSize / this.font.size, glyphWidth = glyph.advanceWidth * glyphScale;
                                glyph.surface && (textRenderer.save(), textRenderer.transform([ glyphScale, 0, 0, glyphScale, 0, 0 ]), 
                                textRenderer.drawImage(glyph.surface, glyph.x, glyph.y, glyph.width, glyph.height, glyph.offsetX, glyph.offsetY), 
                                textRenderer.restore()), textRenderer.translate(glyphWidth, 0);
                            }
                            textRenderer.restore(), textRenderer.end();
                            var offsetX, scale = this.maxWidth > 0 && this.maxWidth < this._textWidth ? this.maxWidth / this._textWidth : 1;
                            switch (this.textAlign) {
                              case g.TextAlign.Center:
                                offsetX = this.width / 2 - this._textWidth / 2 * scale;
                                break;

                              case g.TextAlign.Right:
                                offsetX = this.width - this._textWidth * scale;
                                break;

                              default:
                                offsetX = 0;
                            }
                            renderer.save(), renderer.translate(offsetX, 0), 1 !== scale && renderer.transform([ scale, 0, 0, 1, 0, 0 ]), 
                            renderer.drawImage(textSurface, 0, 0, this._textWidth, this.height, 0, 0), textSurface.destroy(), 
                            this.textColor && (renderer.setCompositeOperation(g.CompositeOperation.SourceAtop), 
                            renderer.fillRect(0, 0, this._textWidth, this.height, this.textColor)), renderer.restore();
                        }
                    }, Label.prototype.destroy = function() {
                        _super.prototype.destroy.call(this);
                    }, Label.prototype._invalidateSelf = function() {
                        if (void 0 !== this.bitmapFont && (this.font = this.bitmapFont), this.glyphs.length = 0, 
                        this._textWidth = 0, !this.fontSize) return void (this.height = 0);
                        for (var maxHeight = 0, glyphScale = this.font.size > 0 ? this.fontSize / this.font.size : 0, i = 0; i < this.text.length; ++i) {
                            var code = g.Util.charCodeAt(this.text, i);
                            if (code) {
                                var glyph = this.font.glyphForCharacter(code);
                                if (glyph) {
                                    if (!(glyph.width < 0 || glyph.height < 0 || glyph.x < 0 || glyph.y < 0)) {
                                        this.glyphs.push(glyph), this._textWidth += glyph.advanceWidth * glyphScale;
                                        var height = glyph.offsetY + glyph.height;
                                        maxHeight < height && (maxHeight = height);
                                    }
                                } else {
                                    var str = 4294901760 & code ? String.fromCharCode((4294901760 & code) >>> 16, 65535 & code) : String.fromCharCode(code);
                                    this.game().logger.warn("Label#_invalidateSelf(): failed to get a glyph for '" + str + "' (BitmapFont might not have the glyph or DynamicFont might create a glyph larger than its atlas).");
                                }
                            }
                        }
                        this.widthAutoAdjust && (this.width = this._textWidth), this.height = maxHeight * glyphScale;
                    }, Label;
                }(g.CacheableE);
                g.Label = Label;
            }(g || (g = {}));
            var g;
            !function(g_1) {
                var Glyph = function() {
                    function Glyph(code, x, y, width, height, offsetX, offsetY, advanceWidth, surface, isSurfaceValid) {
                        void 0 === offsetX && (offsetX = 0), void 0 === offsetY && (offsetY = 0), void 0 === advanceWidth && (advanceWidth = width), 
                        void 0 === isSurfaceValid && (isSurfaceValid = !!surface), this.code = code, this.x = x, 
                        this.y = y, this.width = width, this.height = height, this.offsetX = offsetX, this.offsetY = offsetY, 
                        this.advanceWidth = advanceWidth, this.surface = surface, this.isSurfaceValid = isSurfaceValid, 
                        this._atlas = null;
                    }
                    return Glyph.prototype.renderingWidth = function(fontSize) {
                        return this.width && this.height ? fontSize / this.height * this.width : 0;
                    }, Glyph;
                }();
                g_1.Glyph = Glyph;
                var BitmapFont = function() {
                    function BitmapFont(srcOrParam, map, defaultGlyphWidth, defaultGlyphHeight, missingGlyph) {
                        if (srcOrParam instanceof g_1.Surface || srcOrParam instanceof g_1.Asset) this.surface = g_1.Util.asSurface(srcOrParam), 
                        this.map = map, this.defaultGlyphWidth = defaultGlyphWidth, this.defaultGlyphHeight = defaultGlyphHeight, 
                        this.missingGlyph = missingGlyph, this.size = defaultGlyphHeight; else {
                            var param = srcOrParam;
                            this.surface = g_1.Util.asSurface(param.src), this.map = param.map, this.defaultGlyphWidth = param.defaultGlyphWidth, 
                            this.defaultGlyphHeight = param.defaultGlyphHeight, this.missingGlyph = param.missingGlyph, 
                            this.size = param.defaultGlyphHeight;
                        }
                    }
                    return BitmapFont.prototype.glyphForCharacter = function(code) {
                        var g = this.map[code] || this.missingGlyph;
                        if (!g) return null;
                        var w = void 0 === g.width ? this.defaultGlyphWidth : g.width, h = void 0 === g.height ? this.defaultGlyphHeight : g.height, offsetX = g.offsetX || 0, offsetY = g.offsetY || 0, advanceWidth = void 0 === g.advanceWidth ? w : g.advanceWidth, surface = 0 === w || 0 === h ? void 0 : this.surface;
                        return new Glyph(code, g.x, g.y, w, h, offsetX, offsetY, advanceWidth, surface, !0);
                    }, BitmapFont.prototype.destroy = function() {
                        this.surface && !this.surface.destroyed() && this.surface.destroy(), this.map = void 0;
                    }, BitmapFont.prototype.destroyed = function() {
                        return !this.map;
                    }, BitmapFont;
                }();
                g_1.BitmapFont = BitmapFont;
            }(g || (g = {}));
            var g;
            !function(g) {
                var FilledRect = function(_super) {
                    function FilledRect(sceneOrParam, cssColor, width, height) {
                        var _this = this;
                        if (sceneOrParam instanceof g.Scene) {
                            var scene = sceneOrParam;
                            if (_this = _super.call(this, scene) || this, "string" != typeof cssColor) throw g.ExceptionFactory.createTypeMismatchError("ColorBox#constructor(cssColor)", "string", cssColor);
                            _this.cssColor = cssColor, _this.width = width, _this.height = height;
                        } else {
                            var param = sceneOrParam;
                            if (_this = _super.call(this, param) || this, "string" != typeof param.cssColor) throw g.ExceptionFactory.createTypeMismatchError("ColorBox#constructor(cssColor)", "string", cssColor);
                            _this.cssColor = param.cssColor;
                        }
                        return _this;
                    }
                    return __extends(FilledRect, _super), FilledRect.prototype.renderSelf = function(renderer) {
                        return renderer.fillRect(0, 0, this.width, this.height, this.cssColor), !0;
                    }, FilledRect;
                }(g.E);
                g.FilledRect = FilledRect;
            }(g || (g = {}));
            var g;
            !function(g) {
                var Pane = function(_super) {
                    function Pane(sceneOrParam, width, height, backgroundImage, padding, backgroundEffector) {
                        var _this = this;
                        if (sceneOrParam instanceof g.Scene) {
                            var scene = sceneOrParam;
                            _this = _super.call(this, scene) || this, _this.width = _this._oldWidth = width, 
                            _this.height = _this._oldHeight = height, _this.backgroundImage = g.Util.asSurface(backgroundImage), 
                            _this.backgroundEffector = backgroundEffector, _this._shouldRenderChildren = !1, 
                            _this._padding = padding, _this._initialize(), _this._paddingChanged = !1, _this._bgSurface = void 0, 
                            _this._bgRenderer = void 0;
                        } else {
                            var param = sceneOrParam;
                            _this = _super.call(this, param) || this, _this._oldWidth = param.width, _this._oldHeight = param.height, 
                            _this.backgroundImage = g.Util.asSurface(param.backgroundImage), _this.backgroundEffector = param.backgroundEffector, 
                            _this._shouldRenderChildren = !1, _this._padding = param.padding, _this._initialize(), 
                            _this._paddingChanged = !1, _this._bgSurface = void 0, _this._bgRenderer = void 0;
                        }
                        return _this;
                    }
                    return __extends(Pane, _super), Object.defineProperty(Pane.prototype, "padding", {
                        get: function() {
                            return this._padding;
                        },
                        set: function(padding) {
                            this._padding = padding, this._paddingChanged = !0;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Pane.prototype.modified = function(isBubbling) {
                        isBubbling && (this.state &= -3), _super.prototype.modified.call(this);
                    }, Pane.prototype.shouldFindChildrenByPoint = function(point) {
                        var p = this._normalizedPadding;
                        return p.left < point.x && this.width - p.right > point.x && p.top < point.y && this.height - p.bottom > point.y;
                    }, Pane.prototype.renderCache = function(renderer, camera) {
                        this.width <= 0 || this.height <= 0 || (this._renderBackground(), this._renderChildren(camera), 
                        this._bgSurface ? renderer.drawImage(this._bgSurface, 0, 0, this.width, this.height, 0, 0) : this.backgroundImage && renderer.drawImage(this.backgroundImage, 0, 0, this.width, this.height, 0, 0), 
                        this._childrenArea.width <= 0 || this._childrenArea.height <= 0 || (renderer.save(), 
                        0 === this._childrenArea.x && 0 === this._childrenArea.y || renderer.translate(this._childrenArea.x, this._childrenArea.y), 
                        renderer.drawImage(this._childrenSurface, 0, 0, this._childrenArea.width, this._childrenArea.height, 0, 0), 
                        renderer.restore()));
                    }, Pane.prototype.destroy = function(destroySurface) {
                        destroySurface && this.backgroundImage && !this.backgroundImage.destroyed() && this.backgroundImage.destroy(), 
                        this._bgSurface && !this._bgSurface.destroyed() && this._bgSurface.destroy(), this._childrenSurface && !this._childrenSurface.destroyed() && this._childrenSurface.destroy(), 
                        this.backgroundImage = void 0, this._bgSurface = void 0, this._childrenSurface = void 0, 
                        _super.prototype.destroy.call(this);
                    }, Pane.prototype._renderBackground = function() {
                        this._bgSurface && !this._bgSurface.destroyed() && this._bgSurface.destroy(), this.backgroundImage && this.backgroundEffector ? this._bgSurface = this.backgroundEffector.render(this.backgroundImage, this.width, this.height) : this._bgSurface = void 0;
                    }, Pane.prototype._renderChildren = function(camera) {
                        var isNew = this._oldWidth !== this.width || this._oldHeight !== this.height || this._paddingChanged;
                        if (isNew && (this._initialize(), this._paddingChanged = !1, this._oldWidth = this.width, 
                        this._oldHeight = this.height), this._childrenRenderer.begin(), isNew || this._childrenRenderer.clear(), 
                        this.children) for (var children = this.children, i = 0; i < children.length; ++i) children[i].render(this._childrenRenderer, camera);
                        this._childrenRenderer.end();
                    }, Pane.prototype._initialize = function() {
                        var r, p = void 0 === this._padding ? 0 : this._padding;
                        r = "number" == typeof p ? {
                            top: p,
                            bottom: p,
                            left: p,
                            right: p
                        } : this._padding, this._childrenArea = {
                            x: r.left,
                            y: r.top,
                            width: this.width - r.left - r.right,
                            height: this.height - r.top - r.bottom
                        };
                        var resourceFactory = this.scene.game.resourceFactory;
                        this._childrenSurface && !this._childrenSurface.destroyed() && this._childrenSurface.destroy(), 
                        this._childrenSurface = resourceFactory.createSurface(Math.ceil(this._childrenArea.width), Math.ceil(this._childrenArea.height)), 
                        this._childrenRenderer = this._childrenSurface.renderer(), this._normalizedPadding = r;
                    }, Pane.prototype._calculateBoundingRect = function(m, c) {
                        var matrix = this.getMatrix();
                        if (m && (matrix = m.multiplyNew(matrix)), this.visible() && (!c || this._targetCameras && this._targetCameras.indexOf(c) !== -1)) {
                            for (var thisBoundingRect = {
                                left: 0,
                                right: this.width,
                                top: 0,
                                bottom: this.height
                            }, targetCoordinates = [ {
                                x: thisBoundingRect.left,
                                y: thisBoundingRect.top
                            }, {
                                x: thisBoundingRect.left,
                                y: thisBoundingRect.bottom
                            }, {
                                x: thisBoundingRect.right,
                                y: thisBoundingRect.top
                            }, {
                                x: thisBoundingRect.right,
                                y: thisBoundingRect.bottom
                            } ], convertedPoint = matrix.multiplyPoint(targetCoordinates[0]), result = {
                                left: convertedPoint.x,
                                right: convertedPoint.x,
                                top: convertedPoint.y,
                                bottom: convertedPoint.y
                            }, i = 1; i < targetCoordinates.length; ++i) convertedPoint = matrix.multiplyPoint(targetCoordinates[i]), 
                            result.left > convertedPoint.x && (result.left = convertedPoint.x), result.right < convertedPoint.x && (result.right = convertedPoint.x), 
                            result.top > convertedPoint.y && (result.top = convertedPoint.y), result.bottom < convertedPoint.y && (result.bottom = convertedPoint.y);
                            return result;
                        }
                    }, Pane;
                }(g.CacheableE);
                g.Pane = Pane;
            }(g || (g = {}));
            var g;
            !function(g) {
                var TextInputMethod = function() {
                    function TextInputMethod(game) {
                        this.game = game;
                    }
                    return TextInputMethod.prototype.open = function(defaultText, callback) {
                        throw g.ExceptionFactory.createPureVirtualError("TextInputMethod#open");
                    }, TextInputMethod;
                }();
                g.TextInputMethod = TextInputMethod;
            }(g || (g = {}));
            var g;
            !function(g) {
                var OperationHandler = function() {
                    function OperationHandler(code, owner, handler) {
                        this._code = code, this._handler = handler, this._handlerOwner = owner;
                    }
                    return OperationHandler.prototype.onOperation = function(op) {
                        var iop;
                        op instanceof Array ? iop = {
                            _code: this._code,
                            data: op
                        } : (iop = op, iop._code = this._code), this._handler.call(this._handlerOwner, iop);
                    }, OperationHandler;
                }(), OperationPluginManager = function() {
                    function OperationPluginManager(game, viewInfo, infos) {
                        this.operated = new g.Trigger(), this.plugins = {}, this._game = game, this._viewInfo = viewInfo, 
                        this._infos = infos, this._initialized = !1;
                    }
                    return OperationPluginManager.prototype.initialize = function() {
                        this._initialized || (this._initialized = !0, this._loadOperationPlugins()), this._doAutoStart();
                    }, OperationPluginManager.prototype.destroy = function() {
                        this.stopAll(), this.operated.destroy(), this.operated = void 0, this.plugins = void 0, 
                        this._game = void 0, this._viewInfo = void 0, this._infos = void 0;
                    }, OperationPluginManager.prototype.stopAll = function() {
                        if (this._initialized) for (var i = 0; i < this._infos.length; ++i) {
                            var info = this._infos[i];
                            info._plugin && info._plugin.stop();
                        }
                    }, OperationPluginManager.prototype._doAutoStart = function() {
                        for (var i = 0; i < this._infos.length; ++i) {
                            var info = this._infos[i];
                            !info.manualStart && info._plugin && info._plugin.start();
                        }
                    }, OperationPluginManager.prototype._loadOperationPlugins = function() {
                        for (var i = 0; i < this._infos.length; ++i) {
                            var info = this._infos[i];
                            if (info.script) {
                                var pluginClass = g._require(this._game, info.script);
                                if (pluginClass.isSupported()) {
                                    var plugin = new pluginClass(this._game, this._viewInfo, info.option), code = info.code;
                                    if (this.plugins[code]) throw new Error("Plugin#code conflicted for code: " + code);
                                    this.plugins[code] = plugin, info._plugin = plugin;
                                    var handler = new OperationHandler(code, this.operated, this.operated.fire);
                                    plugin.operationTrigger.handle(handler, handler.onOperation);
                                }
                            }
                        }
                    }, OperationPluginManager;
                }();
                g.OperationPluginManager = OperationPluginManager;
            }(g || (g = {}));
            var g;
            !function(g) {}(g || (g = {}));
            var g;
            !function(g) {
                function getSurfaceAtlasSlot(slot, width, height) {
                    for (;slot; ) {
                        if (slot.width >= width && slot.height >= height) return slot;
                        slot = slot.next;
                    }
                    return null;
                }
                function calcAtlasSize(hint) {
                    var width = Math.ceil(Math.min(hint.initialAtlasWidth, hint.maxAtlasWidth)), height = Math.ceil(Math.min(hint.initialAtlasHeight, hint.maxAtlasHeight));
                    return {
                        width: width,
                        height: height
                    };
                }
                var FontWeight;
                !function(FontWeight) {
                    FontWeight[FontWeight.Normal = 0] = "Normal", FontWeight[FontWeight.Bold = 1] = "Bold";
                }(FontWeight = g.FontWeight || (g.FontWeight = {}));
                var SurfaceAtlasSlot = function() {
                    function SurfaceAtlasSlot(x, y, width, height) {
                        this.x = x, this.y = y, this.width = width, this.height = height, this.prev = null, 
                        this.next = null;
                    }
                    return SurfaceAtlasSlot;
                }();
                g.SurfaceAtlasSlot = SurfaceAtlasSlot;
                var SurfaceAtlas = function() {
                    function SurfaceAtlas(surface) {
                        this._surface = surface, this._emptySurfaceAtlasSlotHead = new SurfaceAtlasSlot(0, 0, this._surface.width, this._surface.height), 
                        this._accessScore = 0, this._usedRectangleAreaSize = {
                            width: 0,
                            height: 0
                        };
                    }
                    return SurfaceAtlas.prototype._acquireSurfaceAtlasSlot = function(width, height) {
                        width += 1, height += 1;
                        var slot = getSurfaceAtlasSlot(this._emptySurfaceAtlasSlotHead, width, height);
                        if (!slot) return null;
                        var left, right, remainWidth = slot.width - width, remainHeight = slot.height - height;
                        remainWidth <= remainHeight ? (left = new SurfaceAtlasSlot(slot.x + width, slot.y, remainWidth, height), 
                        right = new SurfaceAtlasSlot(slot.x, slot.y + height, slot.width, remainHeight)) : (left = new SurfaceAtlasSlot(slot.x, slot.y + height, width, remainHeight), 
                        right = new SurfaceAtlasSlot(slot.x + width, slot.y, remainWidth, slot.height)), 
                        left.prev = slot.prev, left.next = right, null === left.prev ? this._emptySurfaceAtlasSlotHead = left : left.prev.next = left, 
                        right.prev = left, right.next = slot.next, right.next && (right.next.prev = right);
                        var acquiredSlot = new SurfaceAtlasSlot(slot.x, slot.y, width, height);
                        return this._updateUsedRectangleAreaSize(acquiredSlot), acquiredSlot;
                    }, SurfaceAtlas.prototype._updateUsedRectangleAreaSize = function(slot) {
                        var slotRight = slot.x + slot.width, slotBottom = slot.y + slot.height;
                        slotRight > this._usedRectangleAreaSize.width && (this._usedRectangleAreaSize.width = slotRight), 
                        slotBottom > this._usedRectangleAreaSize.height && (this._usedRectangleAreaSize.height = slotBottom);
                    }, SurfaceAtlas.prototype.addSurface = function(surface, rect) {
                        var slot = this._acquireSurfaceAtlasSlot(rect.width, rect.height);
                        if (!slot) return null;
                        var renderer = this._surface.renderer();
                        return renderer.begin(), renderer.drawImage(surface, rect.x, rect.y, rect.width, rect.height, slot.x, slot.y), 
                        renderer.end(), slot;
                    }, SurfaceAtlas.prototype.destroy = function() {
                        this._surface.destroy();
                    }, SurfaceAtlas.prototype.destroyed = function() {
                        return this._surface.destroyed();
                    }, SurfaceAtlas.prototype.duplicateSurface = function(resourceFactory) {
                        var src = this._surface, dst = resourceFactory.createSurface(this._usedRectangleAreaSize.width, this._usedRectangleAreaSize.height), renderer = dst.renderer();
                        return renderer.begin(), renderer.drawImage(src, 0, 0, this._usedRectangleAreaSize.width, this._usedRectangleAreaSize.height, 0, 0), 
                        renderer.end(), dst;
                    }, SurfaceAtlas;
                }();
                g.SurfaceAtlas = SurfaceAtlas;
                var DynamicFont = function() {
                    function DynamicFont(fontFamilyOrParam, size, game, hint, fontColor, strokeWidth, strokeColor, strokeOnly) {
                        if (void 0 === hint && (hint = {}), void 0 === fontColor && (fontColor = "black"), 
                        void 0 === strokeWidth && (strokeWidth = 0), void 0 === strokeColor && (strokeColor = "black"), 
                        void 0 === strokeOnly && (strokeOnly = !1), "number" == typeof fontFamilyOrParam) this.fontFamily = fontFamilyOrParam, 
                        this.size = size, this.hint = hint, this.fontColor = fontColor, this.strokeWidth = strokeWidth, 
                        this.strokeColor = strokeColor, this.strokeOnly = strokeOnly, this._resourceFactory = game.resourceFactory, 
                        this._glyphFactory = this._resourceFactory.createGlyphFactory(fontFamilyOrParam, size, hint.baselineHeight, fontColor, strokeWidth, strokeColor, strokeOnly), 
                        game.logger.debug("[deprecated] DynamicFont: This constructor is deprecated. Refer to the API documentation and use constructor(param: DynamicFontParameterObject) instead."); else {
                            var param = fontFamilyOrParam;
                            this.fontFamily = param.fontFamily, this.size = param.size, this.hint = "hint" in param ? param.hint : {}, 
                            this.fontColor = "fontColor" in param ? param.fontColor : "black", this.fontWeight = "fontWeight" in param ? param.fontWeight : FontWeight.Normal, 
                            this.strokeWidth = "strokeWidth" in param ? param.strokeWidth : 0, this.strokeColor = "strokeColor" in param ? param.strokeColor : "black", 
                            this.strokeOnly = "strokeOnly" in param && param.strokeOnly, this._resourceFactory = param.game.resourceFactory, 
                            this._glyphFactory = this._resourceFactory.createGlyphFactory(this.fontFamily, this.size, this.hint.baselineHeight, this.fontColor, this.strokeWidth, this.strokeColor, this.strokeOnly, this.fontWeight);
                        }
                        if (this._glyphs = {}, this._atlases = [], this._currentAtlasIndex = 0, this._destroyed = !1, 
                        this.hint.initialAtlasWidth = this.hint.initialAtlasWidth ? this.hint.initialAtlasWidth : 2048, 
                        this.hint.initialAtlasHeight = this.hint.initialAtlasHeight ? this.hint.initialAtlasHeight : 2048, 
                        this.hint.maxAtlasWidth = this.hint.maxAtlasWidth ? this.hint.maxAtlasWidth : 2048, 
                        this.hint.maxAtlasHeight = this.hint.maxAtlasHeight ? this.hint.maxAtlasHeight : 2048, 
                        this.hint.maxAtlasNum = this.hint.maxAtlasNum ? this.hint.maxAtlasNum : 1, this._atlasSize = calcAtlasSize(this.hint), 
                        this._atlases.push(this._resourceFactory.createSurfaceAtlas(this._atlasSize.width, this._atlasSize.height)), 
                        hint.presetChars) for (var i = 0, len = hint.presetChars.length; i < len; i++) {
                            var code = g.Util.charCodeAt(hint.presetChars, i);
                            code && this.glyphForCharacter(code);
                        }
                    }
                    return DynamicFont.prototype.glyphForCharacter = function(code) {
                        var glyph = this._glyphs[code];
                        if (!glyph || !glyph.isSurfaceValid) {
                            if (glyph = this._glyphFactory.create(code), glyph.surface) {
                                if (glyph.width > this._atlasSize.width || glyph.height > this._atlasSize.height) return null;
                                var atlas_1 = this._addToAtlas(glyph);
                                if (!atlas_1 && (this._reallocateAtlas(), atlas_1 = this._addToAtlas(glyph), !atlas_1)) return null;
                                glyph._atlas = atlas_1;
                            }
                            this._glyphs[code] = glyph;
                        }
                        for (var i = 0; i < this._atlases.length; i++) {
                            var atlas = this._atlases[i];
                            atlas === glyph._atlas && (atlas._accessScore += 1), atlas._accessScore /= 2;
                        }
                        return glyph;
                    }, DynamicFont.prototype.asBitmapFont = function(missingGlyphChar) {
                        var _this = this;
                        if (1 !== this._atlases.length) return null;
                        var missingGlyphCharCodePoint;
                        missingGlyphChar && (missingGlyphCharCodePoint = g.Util.charCodeAt(missingGlyphChar, 0), 
                        this.glyphForCharacter(missingGlyphCharCodePoint));
                        var glyphAreaMap = {};
                        Object.keys(this._glyphs).forEach(function(_key) {
                            var key = Number(_key), glyph = _this._glyphs[key], glyphArea = {
                                x: glyph.x,
                                y: glyph.y,
                                width: glyph.width,
                                height: glyph.height,
                                offsetX: glyph.offsetX,
                                offsetY: glyph.offsetY,
                                advanceWidth: glyph.advanceWidth
                            };
                            glyphAreaMap[key] = glyphArea;
                        });
                        var missingGlyph = glyphAreaMap[missingGlyphCharCodePoint], surface = this._atlases[0].duplicateSurface(this._resourceFactory), bitmapFont = new g.BitmapFont(surface, glyphAreaMap, 0, this.size, missingGlyph);
                        return bitmapFont;
                    }, DynamicFont.prototype._removeLowUseAtlas = function() {
                        for (var minScore = Number.MAX_VALUE, lowScoreAtlasIndex = -1, i = 0; i < this._atlases.length; i++) this._atlases[i]._accessScore <= minScore && (minScore = this._atlases[i]._accessScore, 
                        lowScoreAtlasIndex = i);
                        var removedAtlas = this._atlases.splice(lowScoreAtlasIndex, 1)[0];
                        return removedAtlas;
                    }, DynamicFont.prototype._reallocateAtlas = function() {
                        if (this._atlases.length >= this.hint.maxAtlasNum) {
                            var atlas = this._removeLowUseAtlas(), glyphs = this._glyphs;
                            for (var key in glyphs) if (glyphs.hasOwnProperty(key)) {
                                var glyph = glyphs[key];
                                glyph.surface === atlas._surface && (glyph.surface = null, glyph.isSurfaceValid = !1, 
                                glyph._atlas = null);
                            }
                            atlas.destroy();
                        }
                        this._atlases.push(this._resourceFactory.createSurfaceAtlas(this._atlasSize.width, this._atlasSize.height)), 
                        this._currentAtlasIndex = this._atlases.length - 1;
                    }, DynamicFont.prototype._addToAtlas = function(glyph) {
                        for (var atlas = null, slot = null, area = {
                            x: glyph.x,
                            y: glyph.y,
                            width: glyph.width,
                            height: glyph.height
                        }, i = 0; i < this._atlases.length; i++) {
                            var index = (this._currentAtlasIndex + i) % this._atlases.length;
                            if (atlas = this._atlases[index], slot = atlas.addSurface(glyph.surface, area)) {
                                this._currentAtlasIndex = index;
                                break;
                            }
                        }
                        return slot ? (glyph.surface.destroy(), glyph.surface = atlas._surface, glyph.x = slot.x, 
                        glyph.y = slot.y, atlas) : null;
                    }, DynamicFont.prototype.destroy = function() {
                        for (var i = 0; i < this._atlases.length; i++) this._atlases[i].destroy();
                        this._glyphs = null, this._glyphFactory = null, this._destroyed = !0;
                    }, DynamicFont.prototype.destroyed = function() {
                        return this._destroyed;
                    }, DynamicFont;
                }();
                g.DynamicFont = DynamicFont;
            }(g || (g = {}));
            var g;
            !function(g) {
                var AudioSystemManager = function() {
                    function AudioSystemManager(game) {
                        this._game = game, this._muted = !1, this._playbackRate = 1;
                    }
                    return AudioSystemManager.prototype._setMuted = function(muted) {
                        if (this._muted !== muted) {
                            this._muted = muted;
                            var systems = this._game.audio;
                            for (var id in systems) systems.hasOwnProperty(id) && systems[id]._setMuted(muted);
                        }
                    }, AudioSystemManager.prototype._setPlaybackRate = function(rate) {
                        if (this._playbackRate !== rate) {
                            this._playbackRate = rate;
                            var systems = this._game.audio;
                            for (var id in systems) systems.hasOwnProperty(id) && systems[id]._setPlaybackRate(rate);
                        }
                    }, AudioSystemManager;
                }();
                g.AudioSystemManager = AudioSystemManager;
            }(g || (g = {}));
            var g;
            !function(g) {
                var CompositeOperation;
                !function(CompositeOperation) {
                    CompositeOperation[CompositeOperation.SourceOver = 0] = "SourceOver", CompositeOperation[CompositeOperation.SourceAtop = 1] = "SourceAtop", 
                    CompositeOperation[CompositeOperation.Lighter = 2] = "Lighter", CompositeOperation[CompositeOperation.Copy = 3] = "Copy";
                }(CompositeOperation = g.CompositeOperation || (g.CompositeOperation = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var GlyphFactory = function() {
                    function GlyphFactory(fontFamily, fontSize, baselineHeight, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
                        void 0 === baselineHeight && (baselineHeight = fontSize), void 0 === fontColor && (fontColor = "black"), 
                        void 0 === strokeWidth && (strokeWidth = 0), void 0 === strokeColor && (strokeColor = "black"), 
                        void 0 === strokeOnly && (strokeOnly = !1), void 0 === fontWeight && (fontWeight = g.FontWeight.Normal), 
                        this.fontFamily = fontFamily, this.fontSize = fontSize, this.fontWeight = fontWeight, 
                        this.baselineHeight = baselineHeight, this.fontColor = fontColor, this.strokeWidth = strokeWidth, 
                        this.strokeColor = strokeColor, this.strokeOnly = strokeOnly;
                    }
                    return GlyphFactory.prototype.create = function(code) {
                        throw g.ExceptionFactory.createPureVirtualError("GlyphFactory#create");
                    }, GlyphFactory;
                }();
                g.GlyphFactory = GlyphFactory;
            }(g || (g = {}));
            var g;
            !function(g) {
                var LocalTickMode;
                !function(LocalTickMode) {
                    LocalTickMode[LocalTickMode.NonLocal = 0] = "NonLocal", LocalTickMode[LocalTickMode.FullLocal = 1] = "FullLocal", 
                    LocalTickMode[LocalTickMode.InterpolateLocal = 2] = "InterpolateLocal";
                }(LocalTickMode = g.LocalTickMode || (g.LocalTickMode = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var MultiLineLabel = function(_super) {
                    function MultiLineLabel(sceneOrParam, text, font, fontSize, width, lineBreak) {
                        void 0 === lineBreak && (lineBreak = !0);
                        var _this = this;
                        if (sceneOrParam instanceof g.Scene) {
                            var scene = sceneOrParam;
                            _this = _super.call(this, scene) || this, _this.text = text, _this.bitmapFont = font, 
                            _this.fontSize = fontSize, _this.width = width, _this.lineBreak = lineBreak, _this.lineGap = 0, 
                            _this.textAlign = g.TextAlign.Left, _this.textColor = void 0;
                        } else {
                            var param = sceneOrParam;
                            _this = _super.call(this, param) || this, _this.text = param.text, _this.bitmapFont = param.bitmapFont, 
                            _this.fontSize = param.fontSize, _this.width = param.width, _this.lineBreak = !("lineBreak" in param) || param.lineBreak, 
                            _this.lineGap = param.lineGap || 0, _this.textAlign = "textAlign" in param ? param.textAlign : g.TextAlign.Left, 
                            _this.textColor = param.textColor;
                        }
                        return _this._lines = [], _this._beforeText = void 0, _this._beforeLineBreak = void 0, 
                        _this._beforeBitmapFont = void 0, _this._beforeFontSize = void 0, _this._beforeTextAlign = void 0, 
                        _this._beforeWidth = void 0, _this._invalidateSelf(), _this;
                    }
                    return __extends(MultiLineLabel, _super), MultiLineLabel.prototype.invalidate = function() {
                        this._invalidateSelf(), _super.prototype.invalidate.call(this);
                    }, MultiLineLabel.prototype.renderCache = function(renderer) {
                        if (0 !== this.fontSize) {
                            renderer.save();
                            for (var i = 0; i < this._lines.length; ++i) this._lines[i].width <= 0 || renderer.drawImage(this._lines[i].surface, 0, 0, this._lines[i].width, this.fontSize, this._offsetX(this._lines[i].width), i * (this.fontSize + this.lineGap));
                            this.textColor && (renderer.setCompositeOperation(g.CompositeOperation.SourceAtop), 
                            renderer.fillRect(0, 0, this.width, this.height, this.textColor)), renderer.restore();
                        }
                    }, MultiLineLabel.prototype.destroy = function() {
                        this._destroyLines(), _super.prototype.destroy.call(this);
                    }, MultiLineLabel.prototype._offsetX = function(width) {
                        switch (this.textAlign) {
                          case g.TextAlign.Left:
                            return 0;

                          case g.TextAlign.Right:
                            return this.width - width;

                          case g.TextAlign.Center:
                            return (this.width - width) / 2;

                          default:
                            return 0;
                        }
                    }, MultiLineLabel.prototype._lineBrokenText = function() {
                        var splited = this.text.split(/\r\n|\r|\n/);
                        if (this.lineBreak) {
                            for (var lines = [], i = 0; i < splited.length; ++i) {
                                for (var t = splited[i], lineWidth = 0, start = 0, j = 0; j < t.length; ++j) {
                                    var glyph = this.bitmapFont.glyphForCharacter(t.charCodeAt(j)), w = glyph.renderingWidth(this.fontSize);
                                    lineWidth + w > this.width && (lines.push(t.substring(start, j)), start = j, lineWidth = 0), 
                                    lineWidth += w;
                                }
                                lines.push(t.substring(start, t.length));
                            }
                            return lines;
                        }
                        return splited;
                    }, MultiLineLabel.prototype._invalidateSelf = function() {
                        if (this.fontSize < 0) throw g.ExceptionFactory.createAssertionError("MultiLineLabel#_invalidateSelf: fontSize must not be negative.");
                        if (this.lineGap < -1 * this.fontSize) throw g.ExceptionFactory.createAssertionError("MultiLineLabel#_invalidateSelf: lineGap must be greater than -1 * fontSize.");
                        (this._beforeText !== this.text || this._beforeFontSize !== this.fontSize || this._beforeBitmapFont !== this.bitmapFont || this._beforeLineBreak !== this.lineBreak || this._beforeWidth !== this.width && this._beforeLineBreak === !0) && this._createLines(), 
                        this.height = this.fontSize + (this.fontSize + this.lineGap) * (this._lines.length - 1), 
                        this._beforeText = this.text, this._beforeTextAlign = this.textAlign, this._beforeFontSize = this.fontSize, 
                        this._beforeLineBreak = this.lineBreak, this._beforeBitmapFont = this.bitmapFont, 
                        this._beforeWidth = this.width;
                    }, MultiLineLabel.prototype._createLineInfo = function(str) {
                        if (0 === this.fontSize) return {
                            text: str,
                            width: 0
                        };
                        for (var lineWidth = 0, glyphs = [], i = 0; i < str.length; ++i) {
                            var glyph = this.bitmapFont.glyphForCharacter(str.charCodeAt(i));
                            glyph.width && glyph.height && (glyphs.push(glyph), lineWidth += glyph.renderingWidth(this.fontSize));
                        }
                        if (0 === lineWidth) return {
                            text: str,
                            width: 0
                        };
                        var textSurface = this.scene.game.resourceFactory.createSurface(Math.ceil(lineWidth), Math.ceil(this.fontSize)), textRenderer = textSurface.renderer();
                        textRenderer.begin(), textRenderer.save();
                        for (var i = 0; i < glyphs.length; ++i) {
                            var glyph = glyphs[i];
                            textRenderer.save();
                            var glyphScale = this.fontSize / glyph.height;
                            textRenderer.transform([ glyphScale, 0, 0, glyphScale, 0, 0 ]), textRenderer.drawImage(this.bitmapFont.surface, glyph.x, glyph.y, glyph.width, glyph.height, 0, 0), 
                            textRenderer.restore(), textRenderer.translate(glyph.renderingWidth(this.fontSize), 0);
                        }
                        return textRenderer.restore(), textRenderer.end(), {
                            text: str,
                            width: lineWidth,
                            surface: textSurface
                        };
                    }, MultiLineLabel.prototype._createLines = function() {
                        for (var lineText = this._lineBrokenText(), lines = [], i = 0; i < lineText.length; ++i) void 0 !== this._lines[i] && lineText[i] === this._lines[i].text && this._beforeBitmapFont === this.bitmapFont && this._beforeFontSize === this.fontSize ? lines.push(this._lines[i]) : (this._lines[i] && this._lines[i].surface && !this._lines[i].surface.destroyed() && this._lines[i].surface.destroy(), 
                        lines.push(this._createLineInfo(lineText[i])));
                        for (var i = lines.length; i < this._lines.length; i++) this._lines[i].surface && !this._lines[i].surface.destroyed() && this._lines[i].surface.destroy();
                        this._lines = lines;
                    }, MultiLineLabel.prototype._destroyLines = function() {
                        for (var i = 0; i < this._lines.length; i++) this._lines[i].surface && !this._lines[i].surface.destroyed() && this._lines[i].surface.destroy();
                        this._lines = void 0;
                    }, MultiLineLabel;
                }(g.CacheableE);
                g.MultiLineLabel = MultiLineLabel;
            }(g || (g = {}));
            var g;
            !function(g) {
                var NinePatchSurfaceEffector = function() {
                    function NinePatchSurfaceEffector(game, borderWidth) {
                        void 0 === borderWidth && (borderWidth = 4), this.game = game, "number" == typeof borderWidth ? this.borderWidth = {
                            top: borderWidth,
                            bottom: borderWidth,
                            left: borderWidth,
                            right: borderWidth
                        } : this.borderWidth = borderWidth;
                    }
                    return NinePatchSurfaceEffector.prototype.render = function(srcSurface, width, height) {
                        var surface = this.game.resourceFactory.createSurface(Math.ceil(width), Math.ceil(height)), renderer = surface.renderer();
                        renderer.begin();
                        var sx1 = this.borderWidth.left, sx2 = srcSurface.width - this.borderWidth.right, sy1 = this.borderWidth.top, sy2 = srcSurface.height - this.borderWidth.bottom, dx1 = this.borderWidth.left, dx2 = width - this.borderWidth.right, dy1 = this.borderWidth.top, dy2 = height - this.borderWidth.bottom, srcCorners = [ {
                            x: 0,
                            y: 0,
                            width: this.borderWidth.left,
                            height: this.borderWidth.top
                        }, {
                            x: sx2,
                            y: 0,
                            width: this.borderWidth.right,
                            height: this.borderWidth.top
                        }, {
                            x: 0,
                            y: sy2,
                            width: this.borderWidth.left,
                            height: this.borderWidth.bottom
                        }, {
                            x: sx2,
                            y: sy2,
                            width: this.borderWidth.right,
                            height: this.borderWidth.bottom
                        } ], destCorners = [ {
                            x: 0,
                            y: 0
                        }, {
                            x: dx2,
                            y: 0
                        }, {
                            x: 0,
                            y: dy2
                        }, {
                            x: dx2,
                            y: dy2
                        } ], i = 0;
                        for (i = 0; i < srcCorners.length; ++i) {
                            var c = srcCorners[i];
                            renderer.save(), renderer.translate(destCorners[i].x, destCorners[i].y), renderer.drawImage(srcSurface, c.x, c.y, c.width, c.height, 0, 0), 
                            renderer.restore();
                        }
                        var srcBorders = [ {
                            x: sx1,
                            y: 0,
                            width: sx2 - sx1,
                            height: this.borderWidth.top
                        }, {
                            x: 0,
                            y: sy1,
                            width: this.borderWidth.left,
                            height: sy2 - sy1
                        }, {
                            x: sx2,
                            y: sy1,
                            width: this.borderWidth.right,
                            height: sy2 - sy1
                        }, {
                            x: sx1,
                            y: sy2,
                            width: sx2 - sx1,
                            height: this.borderWidth.bottom
                        } ], destBorders = [ {
                            x: dx1,
                            y: 0,
                            width: dx2 - dx1,
                            height: this.borderWidth.top
                        }, {
                            x: 0,
                            y: dy1,
                            width: this.borderWidth.left,
                            height: dy2 - dy1
                        }, {
                            x: dx2,
                            y: dy1,
                            width: this.borderWidth.right,
                            height: dy2 - dy1
                        }, {
                            x: dx1,
                            y: dy2,
                            width: dx2 - dx1,
                            height: this.borderWidth.bottom
                        } ];
                        for (i = 0; i < srcBorders.length; ++i) {
                            var s = srcBorders[i], d = destBorders[i];
                            renderer.save(), renderer.translate(d.x, d.y), renderer.transform([ d.width / s.width, 0, 0, d.height / s.height, 0, 0 ]), 
                            renderer.drawImage(srcSurface, s.x, s.y, s.width, s.height, 0, 0), renderer.restore();
                        }
                        var sw = sx2 - sx1, sh = sy2 - sy1, dw = dx2 - dx1, dh = dy2 - dy1;
                        return renderer.save(), renderer.translate(dx1, dy1), renderer.transform([ dw / sw, 0, 0, dh / sh, 0, 0 ]), 
                        renderer.drawImage(srcSurface, sx1, sy1, sw, sh, 0, 0), renderer.restore(), renderer.end(), 
                        surface;
                    }, NinePatchSurfaceEffector;
                }();
                g.NinePatchSurfaceEffector = NinePatchSurfaceEffector;
            }(g || (g = {}));
            var g;
            !function(g) {
                var PathUtil;
                !function(PathUtil) {
                    function resolvePath(base, path) {
                        function split(str) {
                            var ret = str.split("/");
                            return "" === ret[ret.length - 1] && ret.pop(), ret;
                        }
                        if ("" === path) return base;
                        for (var baseComponents = PathUtil.splitPath(base), parts = split(baseComponents.path).concat(split(path)), resolved = [], i = 0; i < parts.length; ++i) {
                            var part = parts[i];
                            switch (part) {
                              case "..":
                                var popped = resolved.pop();
                                if (void 0 === popped || "" === popped || "." === popped) throw g.ExceptionFactory.createAssertionError("PathUtil.resolvePath: invalid arguments");
                                break;

                              case ".":
                                0 === resolved.length && resolved.push(".");
                                break;

                              case "":
                                resolved = [ "" ];
                                break;

                              default:
                                resolved.push(part);
                            }
                        }
                        return baseComponents.host + resolved.join("/");
                    }
                    function resolveDirname(path) {
                        var index = path.lastIndexOf("/");
                        return index === -1 ? path : path.substr(0, index);
                    }
                    function resolveExtname(path) {
                        for (var i = path.length - 1; i >= 0; --i) {
                            var c = path.charAt(i);
                            if ("." === c) return path.substr(i);
                            if ("/" === c) return "";
                        }
                        return "";
                    }
                    function makeNodeModulePaths(path) {
                        var pathComponents = PathUtil.splitPath(path), host = pathComponents.host;
                        path = pathComponents.path, "/" === path[path.length - 1] && (path = path.slice(0, path.length - 1));
                        for (var parts = path.split("/"), firstDir = parts.indexOf("node_modules"), root = firstDir > 0 ? firstDir - 1 : 0, dirs = [], i = parts.length - 1; i >= root; --i) if ("node_modules" !== parts[i]) {
                            var dirParts = parts.slice(0, i + 1);
                            dirParts.push("node_modules");
                            var dir = dirParts.join("/");
                            dirs.push(host + dir);
                        }
                        return dirs;
                    }
                    function addExtname(path, ext) {
                        var index = path.indexOf("?");
                        return index === -1 ? path + "." + ext : path.substring(0, index) + "." + ext + path.substring(index, path.length);
                    }
                    function splitPath(path) {
                        var host = "", doubleSlashIndex = path.indexOf("//");
                        if (doubleSlashIndex >= 0) {
                            var hostSlashIndex = path.indexOf("/", doubleSlashIndex + 2);
                            hostSlashIndex >= 0 ? (host = path.slice(0, hostSlashIndex), path = path.slice(hostSlashIndex)) : (host = path, 
                            path = "/");
                        } else host = "";
                        return {
                            host: host,
                            path: path
                        };
                    }
                    PathUtil.resolvePath = resolvePath, PathUtil.resolveDirname = resolveDirname, PathUtil.resolveExtname = resolveExtname, 
                    PathUtil.makeNodeModulePaths = makeNodeModulePaths, PathUtil.addExtname = addExtname, 
                    PathUtil.splitPath = splitPath;
                }(PathUtil = g.PathUtil || (g.PathUtil = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var TextBaseline;
                !function(TextBaseline) {
                    TextBaseline[TextBaseline.Top = 0] = "Top", TextBaseline[TextBaseline.Middle = 1] = "Middle", 
                    TextBaseline[TextBaseline.Alphabetic = 2] = "Alphabetic", TextBaseline[TextBaseline.Bottom = 3] = "Bottom";
                }(TextBaseline = g.TextBaseline || (g.TextBaseline = {}));
                var FontFamily;
                !function(FontFamily) {
                    FontFamily[FontFamily.SansSerif = 0] = "SansSerif", FontFamily[FontFamily.Serif = 1] = "Serif", 
                    FontFamily[FontFamily.Monospace = 2] = "Monospace";
                }(FontFamily = g.FontFamily || (g.FontFamily = {}));
                var SystemLabel = function(_super) {
                    function SystemLabel(param) {
                        var _this = _super.call(this, param) || this;
                        return _this.text = param.text, _this.fontSize = param.fontSize, _this.textAlign = "textAlign" in param ? param.textAlign : g.TextAlign.Left, 
                        _this.textBaseline = "textBaseline" in param ? param.textBaseline : TextBaseline.Alphabetic, 
                        _this.maxWidth = param.maxWidth, _this.textColor = "textColor" in param ? param.textColor : "black", 
                        _this.fontFamily = "fontFamily" in param ? param.fontFamily : FontFamily.SansSerif, 
                        _this.strokeWidth = "strokeWidth" in param ? param.strokeWidth : 0, _this.strokeColor = "strokeColor" in param ? param.strokeColor : "black", 
                        _this.strokeOnly = "strokeOnly" in param && param.strokeOnly, _this;
                    }
                    return __extends(SystemLabel, _super), SystemLabel.prototype.renderSelf = function(renderer, camera) {
                        if (this.text) {
                            var offsetX;
                            switch (this.textAlign) {
                              case g.TextAlign.Right:
                                offsetX = this.width;
                                break;

                              case g.TextAlign.Center:
                                offsetX = this.width / 2;
                                break;

                              default:
                                offsetX = 0;
                            }
                            renderer.drawSystemText(this.text, offsetX, 0, this.maxWidth, this.fontSize, this.textAlign, this.textBaseline, this.textColor, this.fontFamily, this.strokeWidth, this.strokeColor, this.strokeOnly);
                        }
                        return !0;
                    }, SystemLabel;
                }(g.E);
                g.SystemLabel = SystemLabel;
            }(g || (g = {}));
            var g;
            !function(g) {
                var TextAlign;
                !function(TextAlign) {
                    TextAlign[TextAlign.Left = 0] = "Left", TextAlign[TextAlign.Center = 1] = "Center", 
                    TextAlign[TextAlign.Right = 2] = "Right";
                }(TextAlign = g.TextAlign || (g.TextAlign = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                var TickGenerationMode;
                !function(TickGenerationMode) {
                    TickGenerationMode[TickGenerationMode.ByClock = 0] = "ByClock", TickGenerationMode[TickGenerationMode.Manual = 1] = "Manual";
                }(TickGenerationMode = g.TickGenerationMode || (g.TickGenerationMode = {}));
            }(g || (g = {}));
            var g;
            !function(g) {
                // Copyright (c) 2014 Andreas Madsen & Emil Bay
                // From https://github.com/AndreasMadsen/xorshift
                // https://github.com/AndreasMadsen/xorshift/blob/master/LICENSE.md
                // Arranged by DWANGO Co., Ltd.
                var Xorshift = function() {
                    function Xorshift(seed) {
                        this.initState(seed);
                    }
                    return Xorshift.deserialize = function(ser) {
                        var ret = new Xorshift(0);
                        return ret._state0U = ser._state0U, ret._state0L = ser._state0L, ret._state1U = ser._state1U, 
                        ret._state1L = ser._state1L, ret;
                    }, Xorshift.prototype.initState = function(seed) {
                        var factor = 1812433253;
                        seed = factor * (seed ^ seed >> 30) + 1, this._state0U = seed, seed = factor * (seed ^ seed >> 30) + 2, 
                        this._state0L = seed, seed = factor * (seed ^ seed >> 30) + 3, this._state1U = seed, 
                        seed = factor * (seed ^ seed >> 30) + 4, this._state1L = seed;
                    }, Xorshift.prototype.randomInt = function() {
                        var s1U = this._state0U, s1L = this._state0L, s0U = this._state1U, s0L = this._state1L;
                        this._state0U = s0U, this._state0L = s0L;
                        var t1U = 0, t1L = 0, t2U = 0, t2L = 0, a1 = 23, m1 = 4294967295 << 32 - a1;
                        t1U = s1U << a1 | (s1L & m1) >>> 32 - a1, t1L = s1L << a1, s1U ^= t1U, s1L ^= t1L, 
                        t1U = s1U ^ s0U, t1L = s1L ^ s0L;
                        var a2 = 17, m2 = 4294967295 >>> 32 - a2;
                        t2U = s1U >>> a2, t2L = s1L >>> a2 | (s1U & m2) << 32 - a2, t1U ^= t2U, t1L ^= t2L;
                        var a3 = 26, m3 = 4294967295 >>> 32 - a3;
                        t2U = s0U >>> a3, t2L = s0L >>> a3 | (s0U & m3) << 32 - a3, t1U ^= t2U, t1L ^= t2L, 
                        this._state1U = t1U, this._state1L = t1L;
                        var sumL = (t1L >>> 0) + (s0L >>> 0);
                        return t2U = t1U + s0U + (sumL / 2 >>> 31) >>> 0, t2L = sumL >>> 0, [ t2U, t2L ];
                    }, Xorshift.prototype.random = function() {
                        var t2 = this.randomInt();
                        return (4294967296 * t2[0] + t2[1]) / 0x10000000000000000;
                    }, Xorshift.prototype.nextInt = function(min, sup) {
                        return Math.floor(min + this.random() * (sup - min));
                    }, Xorshift.prototype.serialize = function() {
                        return {
                            _state0U: this._state0U,
                            _state0L: this._state0L,
                            _state1U: this._state1U,
                            _state1L: this._state1L
                        };
                    }, Xorshift;
                }();
                g.Xorshift = Xorshift;
            }(g || (g = {}));
            var g;
            !function(g) {
                var XorshiftRandomGenerator = function(_super) {
                    function XorshiftRandomGenerator(seed, xorshift) {
                        var _this = this;
                        if (void 0 === seed) throw g.ExceptionFactory.createAssertionError("XorshiftRandomGenerator#constructor: seed is undefined");
                        return _this = _super.call(this, seed) || this, xorshift ? _this._xorshift = g.Xorshift.deserialize(xorshift) : _this._xorshift = new g.Xorshift(seed), 
                        _this;
                    }
                    return __extends(XorshiftRandomGenerator, _super), XorshiftRandomGenerator.deserialize = function(ser) {
                        return new XorshiftRandomGenerator(ser._seed, ser._xorshift);
                    }, XorshiftRandomGenerator.prototype.get = function(min, max) {
                        return this._xorshift.nextInt(min, max + 1);
                    }, XorshiftRandomGenerator.prototype.serialize = function() {
                        return {
                            _seed: this.seed,
                            _xorshift: this._xorshift.serialize()
                        };
                    }, XorshiftRandomGenerator;
                }(g.RandomGenerator);
                g.XorshiftRandomGenerator = XorshiftRandomGenerator;
            }(g || (g = {})), module.exports = g;
        }).call(this);
    }, {} ]
}, {}, []);	require = function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
    return s;
}({
    1: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), Clock = function() {
            function Clock(param) {
                this.fps = param.fps, this.scaleFactor = param.scaleFactor || 1, this.frameTrigger = new g.Trigger(), 
                this.rawFrameTrigger = new g.Trigger(), this._platform = param.platform, this._maxFramePerOnce = param.maxFramePerOnce, 
                this._deltaTimeBrokenThreshold = param.deltaTimeBrokenThreshold || Clock.DEFAULT_DELTA_TIME_BROKEN_THRESHOLD, 
                param.frameHandler && this.frameTrigger.handle(param.frameHandlerOwner, param.frameHandler), 
                this.running = !1, this._totalDeltaTime = 0, this._onLooperCall_bound = this._onLooperCall.bind(this), 
                this._looper = this._platform.createLooper(this._onLooperCall_bound), this._waitTime = 0, 
                this._waitTimeDoubled = 0, this._waitTimeMax = 0, this._skipFrameWaitTime = 0, this._realMaxFramePerOnce = 0;
            }
            return Clock.prototype.start = function() {
                this.running || (this._totalDeltaTime = 0, this._updateWaitTimes(this.fps, this.scaleFactor), 
                this._looper.start(), this.running = !0);
            }, Clock.prototype.stop = function() {
                this.running && (this._looper.stop(), this.running = !1);
            }, Clock.prototype.changeScaleFactor = function(scaleFactor) {
                this.running ? (this.stop(), this.scaleFactor = scaleFactor, this.start()) : this.scaleFactor = scaleFactor;
            }, Clock.prototype._onLooperCall = function(deltaTime) {
                if (deltaTime <= 0) return this._waitTime - this._totalDeltaTime;
                deltaTime > this._deltaTimeBrokenThreshold && (deltaTime = this._waitTime);
                var totalDeltaTime = this._totalDeltaTime;
                if (totalDeltaTime += deltaTime, totalDeltaTime <= this._skipFrameWaitTime) return this._totalDeltaTime = totalDeltaTime, 
                this._waitTime - totalDeltaTime;
                for (var frameCount = totalDeltaTime < this._waitTimeDoubled ? 1 : totalDeltaTime > this._waitTimeMax ? this._realMaxFramePerOnce : totalDeltaTime / this._waitTime | 0, fc = frameCount, arg = {
                    interrupt: !1
                }; fc > 0 && this.running && !arg.interrupt; ) --fc, this.frameTrigger.fire(arg);
                return totalDeltaTime -= (frameCount - fc) * this._waitTime, this.rawFrameTrigger.fire(), 
                this._totalDeltaTime = totalDeltaTime, this._waitTime - totalDeltaTime;
            }, Clock.prototype._updateWaitTimes = function(fps, scaleFactor) {
                var realFps = fps * scaleFactor;
                this._waitTime = 1e3 / realFps, this._waitTimeDoubled = Math.max(2e3 / realFps | 0, 1), 
                this._waitTimeMax = Math.max(scaleFactor * (1e3 * this._maxFramePerOnce / realFps) | 0, 1), 
                this._skipFrameWaitTime = this._waitTime * Clock.ANTICIPATE_RATE | 0, this._realMaxFramePerOnce = this._maxFramePerOnce * scaleFactor;
            }, Clock;
        }();
        Clock.ANTICIPATE_RATE = .8, Clock.DEFAULT_DELTA_TIME_BROKEN_THRESHOLD = 150, exports.Clock = Clock;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    2: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = (require("@akashic/playlog"), require("@akashic/akashic-pdi"), require("@akashic/akashic-engine")), PointEventResolver_1 = (require("./EventIndex"), 
        require("./PointEventResolver")), EventBuffer = function() {
            function EventBuffer(param) {
                this._amflow = param.amflow, this._isReceiver = !1, this._isSender = !1, this._defaultEventPriority = 0, 
                this._buffer = null, this._joinLeaveBuffer = null, this._localBuffer = null, this._filters = null, 
                this._unfilteredLocalEvents = [], this._unfilteredEvents = [], this._unfilteredJoinLeaves = [], 
                this._pointEventResolver = new PointEventResolver_1.PointEventResolver({
                    game: param.game
                }), this._onEvent_bound = this.onEvent.bind(this);
            }
            return EventBuffer.isEventLocal = function(pev) {
                switch (pev[0]) {
                  case 0:
                    return pev[5];

                  case 1:
                    return pev[3];

                  case 2:
                    return pev[4];

                  case 32:
                    return pev[4];

                  case 33:
                    return pev[7];

                  case 34:
                    return pev[11];

                  case 35:
                    return pev[11];

                  case 64:
                    return pev[5];

                  default:
                    throw g.ExceptionFactory.createAssertionError("EventBuffer.isEventLocal");
                }
            }, EventBuffer.prototype.setMode = function(param) {
                null != param.isReceiver && this._isReceiver !== param.isReceiver && (this._isReceiver = param.isReceiver, 
                param.isReceiver ? this._amflow.onEvent(this._onEvent_bound) : this._amflow.offEvent(this._onEvent_bound)), 
                null != param.isSender && (this._isSender = param.isSender), null != param.defaultEventPriority && (this._defaultEventPriority = param.defaultEventPriority);
            }, EventBuffer.prototype.getMode = function() {
                return {
                    isReceiver: this._isReceiver,
                    isSender: this._isSender,
                    defaultEventPriority: this._defaultEventPriority
                };
            }, EventBuffer.prototype.onEvent = function(pev) {
                return EventBuffer.isEventLocal(pev) ? void this._unfilteredLocalEvents.push(pev) : (this._isReceiver && (0 === pev[0] || 1 === pev[0] ? this._unfilteredJoinLeaves.push(pev) : this._unfilteredEvents.push(pev)), 
                void (this._isSender && (null == pev[1] && (pev[1] = this._defaultEventPriority), 
                this._amflow.sendEvent(pev))));
            }, EventBuffer.prototype.onPointEvent = function(e) {
                var pev;
                switch (e.type) {
                  case 0:
                    pev = this._pointEventResolver.pointDown(e);
                    break;

                  case 1:
                    pev = this._pointEventResolver.pointMove(e);
                    break;

                  case 2:
                    pev = this._pointEventResolver.pointUp(e);
                }
                pev && this.onEvent(pev);
            }, EventBuffer.prototype.addEventDirect = function(pev) {
                return EventBuffer.isEventLocal(pev) ? void (this._localBuffer ? this._localBuffer.push(pev) : this._localBuffer = [ pev ]) : (this._isReceiver && (0 === pev[0] || 1 === pev[0] ? this._joinLeaveBuffer ? this._joinLeaveBuffer.push(pev) : this._joinLeaveBuffer = [ pev ] : this._buffer ? this._buffer.push(pev) : this._buffer = [ pev ]), 
                void (this._isSender && (null == pev[1] && (pev[1] = this._defaultEventPriority), 
                this._amflow.sendEvent(pev))));
            }, EventBuffer.prototype.readEvents = function() {
                var ret = this._buffer;
                return this._buffer = null, ret;
            }, EventBuffer.prototype.readJoinLeaves = function() {
                var ret = this._joinLeaveBuffer;
                return this._joinLeaveBuffer = null, ret;
            }, EventBuffer.prototype.readLocalEvents = function() {
                var ret = this._localBuffer;
                return this._localBuffer = null, ret;
            }, EventBuffer.prototype.addFilter = function(filter) {
                this._filters || (this._filters = []), this._filters.push(filter);
            }, EventBuffer.prototype.removeFilter = function(filter) {
                if (this._filters) {
                    if (!filter) return void (this._filters = null);
                    for (var i = this._filters.length - 1; i >= 0; --i) this._filters[i] === filter && this._filters.splice(i, 1);
                }
            }, EventBuffer.prototype.processEvents = function() {
                var lpevs = this._unfilteredLocalEvents, pevs = this._unfilteredEvents, joins = this._unfilteredJoinLeaves;
                if (!this._filters) return lpevs.length > 0 && (this._unfilteredLocalEvents = [], 
                this._localBuffer = this._localBuffer ? this._localBuffer.concat(lpevs) : lpevs), 
                pevs.length > 0 && (this._unfilteredEvents = [], this._buffer = this._buffer ? this._buffer.concat(pevs) : pevs), 
                void (joins.length > 0 && (this._unfilteredJoinLeaves = [], this._joinLeaveBuffer = this._joinLeaveBuffer ? this._joinLeaveBuffer.concat(joins) : joins));
                if (lpevs.length > 0) {
                    this._unfilteredLocalEvents = [];
                    for (var i = 0; i < this._filters.length && (lpevs = this._filters[i](lpevs), lpevs); ++i) ;
                    lpevs && lpevs.length > 0 && (this._localBuffer = this._localBuffer ? this._localBuffer.concat(lpevs) : lpevs);
                }
                if (pevs.length > 0) {
                    this._unfilteredEvents = [];
                    for (var i = 0; i < this._filters.length && (pevs = this._filters[i](pevs), pevs); ++i) ;
                    pevs && pevs.length > 0 && (this._buffer = this._buffer ? this._buffer.concat(pevs) : pevs);
                }
                if (joins.length > 0) {
                    this._unfilteredJoinLeaves = [];
                    for (var i = 0; i < this._filters.length && joins && joins.length > 0 && (joins = this._filters[i](joins), 
                    joins); ++i) ;
                    joins && joins.length > 0 && (this._joinLeaveBuffer = this._joinLeaveBuffer ? this._joinLeaveBuffer.concat(joins) : joins);
                }
            }, EventBuffer;
        }();
        exports.EventBuffer = EventBuffer;
    }, {
        "./EventIndex": 4,
        "./PointEventResolver": 13,
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "@akashic/akashic-pdi": 22,
        "@akashic/playlog": 26
    } ],
    3: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), EventConverter = (require("@akashic/playlog"), 
        require("./EventIndex"), function() {
            function EventConverter(param) {
                this._game = param.game, this._playerTable = {};
            }
            return EventConverter.prototype.toGameEvent = function(pev) {
                var pointerId, entityId, target, point, startDelta, prevDelta, local, timestamp, eventCode = pev[0], prio = pev[1], playerId = pev[2], player = this._playerTable[playerId] || {
                    id: playerId
                };
                switch (eventCode) {
                  case 0:
                    player = {
                        id: playerId,
                        name: pev[3]
                    }, this._playerTable[playerId] = player;
                    var store = void 0;
                    if (pev[4]) {
                        var keys = [], values = [];
                        pev[4].map(function(data) {
                            keys.push(data.readKey), values.push(data.values);
                        }), store = new g.StorageValueStore(keys, values);
                    }
                    return new g.JoinEvent(player, store, prio);

                  case 1:
                    return delete this._playerTable[player.id], new g.LeaveEvent(player, prio);

                  case 2:
                    return timestamp = pev[3], new g.TimestampEvent(timestamp, player, prio);

                  case 32:
                    return local = pev[4], new g.MessageEvent(pev[3], player, local, prio);

                  case 33:
                    return local = pev[7], pointerId = pev[3], entityId = pev[6], target = null == entityId ? void 0 : entityId >= 0 ? this._game.db[entityId] : this._game._localDb[entityId], 
                    point = {
                        x: pev[4],
                        y: pev[5]
                    }, new g.PointDownEvent(pointerId, target, point, player, local, prio);

                  case 34:
                    return local = pev[11], pointerId = pev[3], entityId = pev[10], target = null == entityId ? void 0 : entityId >= 0 ? this._game.db[entityId] : this._game._localDb[entityId], 
                    point = {
                        x: pev[4],
                        y: pev[5]
                    }, startDelta = {
                        x: pev[6],
                        y: pev[7]
                    }, prevDelta = {
                        x: pev[8],
                        y: pev[9]
                    }, new g.PointMoveEvent(pointerId, target, point, prevDelta, startDelta, player, local, prio);

                  case 35:
                    return local = pev[11], pointerId = pev[3], entityId = pev[10], target = null == entityId ? void 0 : entityId >= 0 ? this._game.db[entityId] : this._game._localDb[entityId], 
                    point = {
                        x: pev[4],
                        y: pev[5]
                    }, startDelta = {
                        x: pev[6],
                        y: pev[7]
                    }, prevDelta = {
                        x: pev[8],
                        y: pev[9]
                    }, new g.PointUpEvent(pointerId, target, point, prevDelta, startDelta, player, local, prio);

                  case 64:
                    local = pev[5];
                    var operationCode = pev[3], operationData = pev[4], decodedData = this._game._decodeOperationPluginOperation(operationCode, operationData);
                    return new g.OperationEvent(operationCode, decodedData, player, local, prio);

                  default:
                    throw g.ExceptionFactory.createAssertionError("EventConverter#toGameEvent");
                }
            }, EventConverter.prototype.toPlaylogEvent = function(e, preservePlayer) {
                var targetId, playerId;
                switch (e.type) {
                  case g.EventType.Join:
                  case g.EventType.Leave:
                    throw g.ExceptionFactory.createAssertionError("EventConverter#toPlaylogEvent: Invalid type: " + g.EventType[e.type]);

                  case g.EventType.Timestamp:
                    var ts = e;
                    return playerId = preservePlayer ? ts.player.id : this._game.player.id, [ 2, ts.priority, playerId, ts.timestamp ];

                  case g.EventType.PointDown:
                    var pointDown = e;
                    return targetId = pointDown.target ? pointDown.target.id : null, playerId = preservePlayer ? pointDown.player.id : this._game.player.id, 
                    [ 33, pointDown.priority, playerId, pointDown.pointerId, pointDown.point.x, pointDown.point.y, targetId, !!pointDown.local ];

                  case g.EventType.PointMove:
                    var pointMove = e;
                    return targetId = pointMove.target ? pointMove.target.id : null, playerId = preservePlayer ? pointMove.player.id : this._game.player.id, 
                    [ 34, pointMove.priority, playerId, pointMove.pointerId, pointMove.point.x, pointMove.point.y, pointMove.startDelta.x, pointMove.startDelta.y, pointMove.prevDelta.x, pointMove.prevDelta.y, targetId, !!pointMove.local ];

                  case g.EventType.PointUp:
                    var pointUp = e;
                    return targetId = pointUp.target ? pointUp.target.id : null, playerId = preservePlayer ? pointUp.player.id : this._game.player.id, 
                    [ 35, pointUp.priority, playerId, pointUp.pointerId, pointUp.point.x, pointUp.point.y, pointUp.startDelta.x, pointUp.startDelta.y, pointUp.prevDelta.x, pointUp.prevDelta.y, targetId, !!pointUp.local ];

                  case g.EventType.Message:
                    var message = e;
                    return playerId = preservePlayer ? message.player.id : this._game.player.id, [ 32, message.priority, playerId, message.data, !!message.local ];

                  case g.EventType.Operation:
                    var op = e;
                    return playerId = preservePlayer ? op.player.id : this._game.player.id, [ 64, op.priority, playerId, op.code, op.data, !!op.local ];

                  default:
                    throw g.ExceptionFactory.createAssertionError("Unknown type: " + e.type);
                }
            }, EventConverter.prototype.makePlaylogOperationEvent = function(op) {
                var playerId = this._game.player.id, priority = null != op.priority ? op.priority : 0;
                return [ 64, priority, playerId, op._code, op.data, !!op.local ];
            }, EventConverter;
        }());
        exports.EventConverter = EventConverter;
    }, {
        "./EventIndex": 4,
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "@akashic/playlog": 26
    } ],
    4: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    }, {} ],
    5: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var ExecutionMode;
        !function(ExecutionMode) {
            ExecutionMode[ExecutionMode.Active = 0] = "Active", ExecutionMode[ExecutionMode.Passive = 1] = "Passive";
        }(ExecutionMode || (ExecutionMode = {})), exports.default = ExecutionMode;
    }, {} ],
    6: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), Game = function(_super) {
            function Game(param) {
                var _this = _super.call(this, param.configuration, param.resourceFactory, param.assetBase, param.player.id, param.operationPluginViewInfo) || this;
                return _this.agePassedTrigger = new g.Trigger(), _this.skippingChangedTrigger = new g.Trigger(), 
                _this.abortTrigger = new g.Trigger(), _this.player = param.player, _this.raiseEventTrigger = new g.Trigger(), 
                _this.raiseTickTrigger = new g.Trigger(), _this.snapshotTrigger = new g.Trigger(), 
                _this.isSnapshotSaver = !!param.isSnapshotSaver, _this._getCurrentTimeFunc = null, 
                _this._eventFilterFuncs = null, _this._notifyPassedAgeTable = {}, _this._gameArgs = param.gameArgs, 
                _this._globalGameArgs = param.globalGameArgs, _this;
            }
            return __extends(Game, _super), Game.prototype.requestNotifyAgePassed = function(age) {
                this._notifyPassedAgeTable[age] = !0;
            }, Game.prototype.cancelNotifyAgePassed = function(age) {
                delete this._notifyPassedAgeTable[age];
            }, Game.prototype.fireAgePassedIfNeeded = function() {
                var age = this.age - 1;
                return !!this._notifyPassedAgeTable[age] && (delete this._notifyPassedAgeTable[age], 
                this.agePassedTrigger.fire(age), !0);
            }, Game.prototype.setCurrentTimeFunc = function(fun) {
                this._getCurrentTimeFunc = fun;
            }, Game.prototype.setEventFilterFuncs = function(funcs) {
                this._eventFilterFuncs = funcs;
            }, Game.prototype.setStorageFunc = function(funcs) {
                this.storage._registerLoad(funcs.storageGetFunc), this.storage._registerWrite(funcs.storagePutFunc), 
                this.storage.requestValuesForJoinPlayer = funcs.requestValuesForJoinFunc;
            }, Game.prototype.raiseEvent = function(event) {
                this.raiseEventTrigger.fire(event);
            }, Game.prototype.raiseTick = function(events) {
                if (!this.scene() || this.scene().tickGenerationMode !== g.TickGenerationMode.Manual) throw g.ExceptionFactory.createAssertionError("Game#raiseTick(): tickGenerationMode for the current scene is not Manual.");
                this.raiseTickTrigger.fire(events);
            }, Game.prototype.addEventFilter = function(filter) {
                this._eventFilterFuncs.addFilter(filter);
            }, Game.prototype.removeEventFilter = function(filter) {
                this._eventFilterFuncs.removeFilter(filter);
            }, Game.prototype.shouldSaveSnapshot = function() {
                return this.isSnapshotSaver;
            }, Game.prototype.saveSnapshot = function(gameSnapshot, timestamp) {
                void 0 === timestamp && (timestamp = this._getCurrentTimeFunc()), this.shouldSaveSnapshot() && this.snapshotTrigger.fire({
                    frame: this.age,
                    timestamp: timestamp,
                    data: {
                        randGenSer: this.random[0].serialize(),
                        gameSnapshot: gameSnapshot
                    }
                });
            }, Game.prototype._restartWithSnapshot = function(snapshot) {
                var data = snapshot.data;
                if (this._eventFilterFuncs.removeFilter(), null != data.seed) {
                    var randGen = new g.XorshiftRandomGenerator(data.seed);
                    this._reset({
                        age: snapshot.frame,
                        randGen: randGen
                    }), this._loadAndStart({
                        args: this._gameArgs,
                        globalArgs: this._globalGameArgs
                    });
                } else {
                    var randGen = new g.XorshiftRandomGenerator(0, data.randGenSer);
                    this._reset({
                        age: snapshot.frame,
                        randGen: randGen
                    }), this._loadAndStart({
                        snapshot: data.gameSnapshot
                    });
                }
            }, Game.prototype._leaveGame = function() {}, Game.prototype._terminateGame = function() {
                this.abortTrigger.fire();
            }, Game;
        }(g.Game);
        exports.Game = Game;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    7: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var es6_promise_1 = require("es6-promise"), g = require("@akashic/akashic-engine"), ExecutionMode_1 = require("./ExecutionMode"), Game_1 = require("./Game"), EventBuffer_1 = require("./EventBuffer"), GameLoop_1 = require("./GameLoop"), PdiUtil_1 = require("./PdiUtil"), GameDriver = function() {
            function GameDriver(param) {
                this.errorTrigger = new g.Trigger(), param.errorHandler && this.errorTrigger.handle(param.errorHandlerOwner, param.errorHandler), 
                this.configurationLoadedTrigger = new g.Trigger(), this.gameCreatedTrigger = new g.Trigger(), 
                this._platform = param.platform, this._loadConfigurationFunc = PdiUtil_1.PdiUtil.makeLoadConfigurationFunc(param.platform), 
                this._player = param.player, this._playId = null, this._game = null, this._gameLoop = null, 
                this._eventBuffer = null, this._openedAmflow = !1, this._playToken = null, this._permission = null, 
                this._hidden = !1;
            }
            return GameDriver.prototype.initialize = function(param, callback) {
                this.doInitialize(param).then(function() {
                    callback();
                }, callback);
            }, GameDriver.prototype.changeState = function(param, callback) {
                var _this = this, pausing = this._gameLoop && this._gameLoop.running;
                pausing && this._gameLoop.stop(), this.initialize(param, function(err) {
                    return err ? void callback(err) : (pausing && _this._gameLoop.start(), void callback());
                });
            }, GameDriver.prototype.startGame = function() {
                return this._gameLoop ? void this._gameLoop.start() : void this.errorTrigger.fire(new Error("Not initialized"));
            }, GameDriver.prototype.stopGame = function() {
                this._gameLoop && this._gameLoop.stop();
            }, GameDriver.prototype.setNextAge = function(age) {
                this._gameLoop.setNextAge(age);
            }, GameDriver.prototype.getPermission = function() {
                return this._permission;
            }, GameDriver.prototype.getDriverConfiguration = function() {
                return {
                    playId: this._playId,
                    playToken: this._playToken,
                    executionMode: this._gameLoop ? this._gameLoop.getExecutionMode() : void 0,
                    eventBufferMode: this._eventBuffer ? this._eventBuffer.getMode() : void 0
                };
            }, GameDriver.prototype.getLoopConfiguration = function() {
                return this._gameLoop ? this._gameLoop.getLoopConfiguration() : null;
            }, GameDriver.prototype.getHidden = function() {
                return this._hidden;
            }, GameDriver.prototype.doInitialize = function(param) {
                var _this = this, p = new es6_promise_1.Promise(function(resolve, reject) {
                    return _this._gameLoop && _this._gameLoop.running ? reject(new Error("Game is running. Must be stopped.")) : (_this._gameLoop && param.loopConfiguration && _this._gameLoop.setLoopConfiguration(param.loopConfiguration), 
                    null != param.hidden && (_this._hidden = param.hidden, _this._game && _this._game._setMuted(param.hidden)), 
                    void resolve());
                }).then(function() {
                    return _this._doSetDriverConfiguration(param.driverConfiguration);
                });
                return param.configurationUrl ? p.then(function() {
                    return _this._loadConfiguration(param.configurationUrl, param.assetBase);
                }).then(function(conf) {
                    return _this._createGame(conf, _this._player, param);
                }) : p;
            }, GameDriver.prototype._doSetDriverConfiguration = function(dconf) {
                var _this = this;
                if (null == dconf) return es6_promise_1.Promise.resolve();
                void 0 === dconf.playId && (dconf.playId = this._playId), void 0 === dconf.playToken && (dconf.playToken = this._playToken), 
                void 0 === dconf.eventBufferMode && (dconf.executionMode === ExecutionMode_1.default.Active ? dconf.eventBufferMode = {
                    isReceiver: !0,
                    isSender: !1
                } : dconf.executionMode === ExecutionMode_1.default.Passive && (dconf.eventBufferMode = {
                    isReceiver: !1,
                    isSender: !0
                }));
                var p = es6_promise_1.Promise.resolve();
                return this._playId !== dconf.playId && (p = p.then(function() {
                    return _this._doOpenAmflow(dconf.playId);
                })), this._playToken !== dconf.playToken && (p = p.then(function() {
                    return _this._doAuthenticate(dconf.playToken);
                })), p.then(function() {
                    return new es6_promise_1.Promise(function(resolve, reject) {
                        null != dconf.eventBufferMode && (null == dconf.eventBufferMode.defaultEventPriority && (dconf.eventBufferMode.defaultEventPriority = _this._permission.maxEventPriority), 
                        _this._eventBuffer && _this._eventBuffer.setMode(dconf.eventBufferMode)), null != dconf.executionMode && _this._gameLoop && _this._gameLoop.setExecutionMode(dconf.executionMode), 
                        resolve();
                    });
                });
            }, GameDriver.prototype._doCloseAmflow = function() {
                var _this = this;
                return new es6_promise_1.Promise(function(resolve, reject) {
                    return _this._openedAmflow ? void _this._platform.amflow.close(function(err) {
                        return _this._openedAmflow = !1, err ? reject(err) : void resolve();
                    }) : resolve();
                });
            }, GameDriver.prototype._doOpenAmflow = function(playId) {
                var _this = this;
                if (void 0 === playId) return es6_promise_1.Promise.resolve();
                var p = this._doCloseAmflow();
                return p.then(function() {
                    return new es6_promise_1.Promise(function(resolve, reject) {
                        return null === playId ? resolve() : void _this._platform.amflow.open(playId, function(err) {
                            return err ? reject(err) : (_this._openedAmflow = !0, _this._playId = playId, _this._game && _this._updateGamePlayId(_this._game), 
                            void resolve());
                        });
                    });
                });
            }, GameDriver.prototype._doAuthenticate = function(playToken) {
                var _this = this;
                return null == playToken ? es6_promise_1.Promise.resolve() : new es6_promise_1.Promise(function(resolve, reject) {
                    _this._platform.amflow.authenticate(playToken, function(err, permission) {
                        return err ? reject(err) : (_this._playToken = playToken, _this._permission = permission, 
                        _this._game && (_this._game.isSnapshotSaver = _this._permission.writeTick), void resolve());
                    });
                });
            }, GameDriver.prototype._loadConfiguration = function(configurationUrl, basePath) {
                var _this = this;
                return new es6_promise_1.Promise(function(resolve, reject) {
                    _this._loadConfigurationFunc(configurationUrl, basePath, function(err, conf) {
                        return err ? reject(err) : (_this.configurationLoadedTrigger.fire(conf), void resolve(conf));
                    });
                });
            }, GameDriver.prototype._putZerothStartPoint = function(data) {
                var _this = this;
                return new es6_promise_1.Promise(function(resolve, reject) {
                    var zerothStartPoint = {
                        frame: 0,
                        timestamp: 0,
                        data: data
                    };
                    _this._platform.amflow.putStartPoint(zerothStartPoint, function(err) {
                        return err ? reject(err) : void resolve();
                    });
                });
            }, GameDriver.prototype._getZerothStartPointData = function() {
                var _this = this;
                return new es6_promise_1.Promise(function(resolve, reject) {
                    _this._platform.amflow.getStartPoint({
                        frame: 0
                    }, function(err, startPoint) {
                        if (err) return reject(err);
                        var data = startPoint.data;
                        return "number" != typeof data.seed ? reject(new Error("GameDriver#_getRandomSeed: No seed found.")) : void resolve(data);
                    });
                });
            }, GameDriver.prototype._createGame = function(conf, player, param) {
                var p, _this = this, putSeed = param.driverConfiguration.executionMode === ExecutionMode_1.default.Active && this._permission.writeTick;
                return p = putSeed ? this._putZerothStartPoint({
                    seed: Date.now(),
                    globalArgs: param.globalGameArgs,
                    fps: conf.fps,
                    startedAt: Date.now()
                }) : es6_promise_1.Promise.resolve(), p = p.then(function() {
                    return _this._getZerothStartPointData();
                }), p.then(function(zerothData) {
                    var pf = _this._platform, driverConf = param.driverConfiguration || {
                        eventBufferMode: {
                            isReceiver: !0,
                            isSender: !1
                        },
                        executionMode: ExecutionMode_1.default.Active
                    }, seed = zerothData.seed, args = param.gameArgs, globalArgs = zerothData.globalArgs, startedAt = zerothData.startedAt;
                    pf.setRendererRequirement({
                        primarySurfaceWidth: conf.width,
                        primarySurfaceHeight: conf.height,
                        rendererCandidates: conf.renderers
                    });
                    var game = new Game_1.Game({
                        configuration: conf,
                        player: player,
                        resourceFactory: pf.getResourceFactory(),
                        assetBase: param.assetBase,
                        isSnapshotSaver: _this._permission.writeTick,
                        operationPluginViewInfo: pf.getOperationPluginViewInfo ? pf.getOperationPluginViewInfo() : null,
                        gameArgs: args,
                        globalGameArgs: globalArgs
                    }), eventBuffer = new EventBuffer_1.EventBuffer({
                        game: game,
                        amflow: pf.amflow
                    });
                    eventBuffer.setMode(driverConf.eventBufferMode), pf.setPlatformEventHandler(eventBuffer), 
                    game.setEventFilterFuncs({
                        addFilter: eventBuffer.addFilter.bind(eventBuffer),
                        removeFilter: eventBuffer.removeFilter.bind(eventBuffer)
                    }), game.renderers.push(pf.getPrimarySurface().renderer());
                    var gameLoop = new GameLoop_1.GameLoop({
                        game: game,
                        amflow: pf.amflow,
                        platform: pf,
                        executionMode: driverConf.executionMode,
                        eventBuffer: eventBuffer,
                        configuration: param.loopConfiguration,
                        startedAt: startedAt,
                        profiler: param.profiler
                    });
                    game.setCurrentTimeFunc(gameLoop.getCurrentTime.bind(gameLoop)), game._reset({
                        age: 0,
                        randGen: new g.XorshiftRandomGenerator(seed)
                    }), _this._updateGamePlayId(game), _this._hidden && game._setMuted(!0), game.snapshotTrigger.handle(function(startPoint) {
                        _this._platform.amflow.putStartPoint(startPoint, function(err) {
                            err && _this.errorTrigger.fire(err);
                        });
                    }), _this._game = game, _this._eventBuffer = eventBuffer, _this._gameLoop = gameLoop, 
                    _this.gameCreatedTrigger.fire(game), _this._game._loadAndStart({
                        args: param.gameArgs || void 0
                    });
                });
            }, GameDriver.prototype._updateGamePlayId = function(game) {
                var _this = this;
                game.playId = this._playId, game.external.send = function(data) {
                    _this._platform.sendToExternal(_this._playId, data);
                };
            }, GameDriver;
        }();
        exports.GameDriver = GameDriver;
    }, {
        "./EventBuffer": 2,
        "./ExecutionMode": 5,
        "./Game": 6,
        "./GameLoop": 8,
        "./PdiUtil": 12,
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "es6-promise": 27
    } ],
    8: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), LoopMode_1 = require("./LoopMode"), LoopRenderMode_1 = require("./LoopRenderMode"), ExecutionMode_1 = require("./ExecutionMode"), Clock_1 = (require("./EventIndex"), 
        require("./Clock")), ProfilerClock_1 = require("./ProfilerClock"), EventConverter_1 = require("./EventConverter"), TickController_1 = require("./TickController"), GameLoop = function() {
            function GameLoop(param) {
                this.errorTrigger = new g.Trigger(), this.running = !1, this._currentTime = 0, this._frameTime = 1e3 / param.game.fps, 
                param.errorHandler && this.errorTrigger.handle(param.errorHandlerOwner, param.errorHandler);
                var conf = param.configuration;
                this._startedAt = param.startedAt, this._targetTimeFunc = conf.targetTimeFunc || null, 
                this._targetTimeOffset = conf.targetTimeOffset || null, this._originDate = conf.originDate || null, 
                this._realTargetTimeOffset = null != this._originDate ? this._originDate - this._startedAt : this._targetTimeOffset || 0, 
                this._delayIgnoreThreshold = conf.delayIgnoreThreshold || GameLoop.DEFAULT_DELAY_IGNORE_THRESHOLD, 
                this._skipTicksAtOnce = conf.skipTicksAtOnce || GameLoop.DEFAULT_SKIP_TICKS_AT_ONCE, 
                this._skipThreshold = conf.skipThreshold || GameLoop.DEFAULT_SKIP_THRESHOLD, this._jumpTryThreshold = conf.jumpTryThreshold || GameLoop.DEFAULT_JUMP_TRY_THRESHOLD, 
                this._jumpIgnoreThreshold = conf.jumpIgnoreThreshold || GameLoop.DEFAULT_JUMP_IGNORE_THRESHOLD, 
                this._pollingTickThreshold = conf._pollingTickThreshold || GameLoop.DEFAULT_POLLING_TICK_THRESHOLD, 
                this._playbackRate = conf.playbackRate || 1;
                var loopRenderMode = null != conf.loopRenderMode ? conf.loopRenderMode : LoopRenderMode_1.default.AfterRawFrame;
                this._loopRenderMode = null, this._loopMode = conf.loopMode, this._amflow = param.amflow, 
                this._game = param.game, this._eventBuffer = param.eventBuffer, this._executionMode = param.executionMode, 
                this._sceneTickMode = null, this._sceneLocalMode = null, this._targetAge = null != conf.targetAge ? conf.targetAge : null, 
                this._waitingStartPoint = !1, this._lastRequestedStartPointAge = -1, this._lastRequestedStartPointTime = -1, 
                this._waitingNextTick = !1, this._skipping = !1, this._lastPollingTickTime = 0, 
                param.profiler ? this._clock = new ProfilerClock_1.ProfilerClock({
                    fps: param.game.fps,
                    scaleFactor: this._playbackRate,
                    platform: param.platform,
                    maxFramePerOnce: 5,
                    profiler: param.profiler
                }) : this._clock = new Clock_1.Clock({
                    fps: param.game.fps,
                    scaleFactor: this._playbackRate,
                    platform: param.platform,
                    maxFramePerOnce: 5
                }), this._tickController = new TickController_1.TickController({
                    amflow: param.amflow,
                    clock: this._clock,
                    game: param.game,
                    eventBuffer: param.eventBuffer,
                    executionMode: param.executionMode,
                    errorHandler: this.errorTrigger.fire,
                    errorHandlerOwner: this.errorTrigger
                }), this._eventConverter = new EventConverter_1.EventConverter({
                    game: param.game
                }), this._tickBuffer = this._tickController.getBuffer(), this._onGotStartPoint_bound = this._onGotStartPoint.bind(this), 
                this._setLoopRenderMode(loopRenderMode), this._game.setStorageFunc(this._tickController.storageFunc()), 
                this._game.raiseEventTrigger.handle(this, this._onGameRaiseEvent), this._game.raiseTickTrigger.handle(this, this._onGameRaiseTick), 
                this._game._started.handle(this, this._onGameStarted), this._game._operationPluginOperated.handle(this, this._onGameOperationPluginOperated), 
                this._tickBuffer.gotNextTickTrigger.handle(this, this._onGotNextFrameTick), this._tickBuffer.start(), 
                this._updateGamePlaybackRate(), this._handleSceneChange();
            }
            return GameLoop.prototype.start = function() {
                this.running = !0, this._clock.start();
            }, GameLoop.prototype.stop = function() {
                this._clock.stop(), this.running = !1;
            }, GameLoop.prototype.setNextAge = function(age) {
                this._tickController.setNextAge(age);
            }, GameLoop.prototype.getExecutionMode = function() {
                return this._executionMode;
            }, GameLoop.prototype.setExecutionMode = function(execMode) {
                this._executionMode = execMode, this._tickController.setExecutionMode(execMode);
            }, GameLoop.prototype.getLoopConfiguration = function() {
                return {
                    loopMode: this._loopMode,
                    delayIgnoreThreshold: this._delayIgnoreThreshold,
                    skipTicksAtOnce: this._skipTicksAtOnce,
                    skipThreshold: this._skipThreshold,
                    jumpTryThreshold: this._jumpTryThreshold,
                    jumpIgnoreThreshold: this._jumpIgnoreThreshold,
                    playbackRate: this._playbackRate,
                    loopRenderMode: this._loopRenderMode,
                    targetTimeFunc: this._targetTimeFunc,
                    targetTimeOffset: this._targetTimeOffset,
                    originDate: this._originDate,
                    targetAge: this._targetAge
                };
            }, GameLoop.prototype.setLoopConfiguration = function(conf) {
                null != conf.loopMode && (this._loopMode = conf.loopMode), null != conf.delayIgnoreThreshold && (this._delayIgnoreThreshold = conf.delayIgnoreThreshold), 
                null != conf.skipTicksAtOnce && (this._skipTicksAtOnce = conf.skipTicksAtOnce), 
                null != conf.skipThreshold && (this._skipThreshold = conf.skipThreshold), null != conf.jumpTryThreshold && (this._jumpTryThreshold = conf.jumpTryThreshold), 
                null != conf.jumpIgnoreThreshold && (this._jumpIgnoreThreshold = conf.jumpIgnoreThreshold), 
                null != conf.playbackRate && (this._playbackRate = conf.playbackRate, this._clock.changeScaleFactor(this._playbackRate), 
                this._updateGamePlaybackRate()), null != conf.loopRenderMode && this._setLoopRenderMode(conf.loopRenderMode), 
                null != conf.targetTimeFunc && (this._targetTimeFunc = conf.targetTimeFunc), null != conf.targetTimeOffset && (this._targetTimeOffset = conf.targetTimeOffset), 
                null != conf.originDate && (this._originDate = conf.originDate), this._realTargetTimeOffset = null != this._originDate ? this._originDate - this._startedAt : this._targetTimeOffset || 0, 
                null != conf.targetAge && (this._targetAge !== conf.targetAge && (this._waitingNextTick = !1), 
                this._targetAge = conf.targetAge);
            }, GameLoop.prototype.addTickList = function(tickList) {
                this._tickBuffer.addTickList(tickList);
            }, GameLoop.prototype.getCurrentTime = function() {
                return this._currentTime;
            }, GameLoop.prototype._startSkipping = function() {
                this._skipping = !0, this._updateGamePlaybackRate(), this._game.skippingChangedTrigger.fire(!0);
            }, GameLoop.prototype._stopSkipping = function() {
                this._skipping = !1, this._updateGamePlaybackRate(), this._game.skippingChangedTrigger.fire(!1);
            }, GameLoop.prototype._updateGamePlaybackRate = function() {
                var realPlaybackRate = this._skipping ? this._playbackRate * this._skipTicksAtOnce : this._playbackRate;
                this._game._setAudioPlaybackRate(realPlaybackRate);
            }, GameLoop.prototype._handleSceneChange = function() {
                var scene = this._game.scene(), localMode = scene ? scene.local : g.LocalTickMode.FullLocal, tickMode = scene ? scene.tickGenerationMode : g.TickGenerationMode.ByClock;
                if (this._sceneLocalMode !== localMode || this._sceneTickMode !== tickMode) switch (this._sceneLocalMode = localMode, 
                this._sceneTickMode = tickMode, localMode) {
                  case g.LocalTickMode.FullLocal:
                    this._tickController.stopTick(), this._clock.frameTrigger.remove(this, this._onFrame), 
                    this._clock.frameTrigger.handle(this, this._onLocalFrame);
                    break;

                  case g.LocalTickMode.NonLocal:
                  case g.LocalTickMode.InterpolateLocal:
                    tickMode === g.TickGenerationMode.ByClock ? this._tickController.startTick() : this._tickController.startTickOnce(), 
                    this._clock.frameTrigger.remove(this, this._onLocalFrame), this._clock.frameTrigger.handle(this, this._onFrame);
                    break;

                  default:
                    return void this.errorTrigger.fire(new Error("Unknown LocalTickMode: " + localMode));
                }
            }, GameLoop.prototype._onLocalFrame = function() {
                this._doLocalTick();
            }, GameLoop.prototype._doLocalTick = function() {
                var game = this._game, pevs = this._eventBuffer.readLocalEvents();
                if (this._currentTime += this._frameTime, pevs) for (var i = 0, len = pevs.length; i < len; ++i) game.events.push(this._eventConverter.toGameEvent(pevs[i]));
                var sceneChanged = game.tick(!1);
                sceneChanged && this._handleSceneChange();
            }, GameLoop.prototype._onFrame = function(frameArg) {
                this._loopMode === LoopMode_1.default.Replay && this._targetTimeFunc ? this._onFrameForTimedReplay(frameArg) : this._onFrameNormal(frameArg);
            }, GameLoop.prototype._onFrameForTimedReplay = function(frameArg) {
                var sceneChanged = !1, game = this._game, targetTime = this._targetTimeFunc() + this._realTargetTimeOffset, timeGap = targetTime - this._currentTime, frameGap = timeGap / this._frameTime;
                if ((frameGap > this._jumpTryThreshold || frameGap < 0) && !this._waitingStartPoint && this._lastRequestedStartPointTime < this._currentTime && (this._waitingStartPoint = !0, 
                this._lastRequestedStartPointTime = targetTime, this._amflow.getStartPoint({
                    timestamp: targetTime
                }, this._onGotStartPoint_bound)), this._skipping ? frameGap <= 1 && this._stopSkipping() : frameGap > this._skipThreshold && this._startSkipping(), 
                !(frameGap <= 0)) for (var i = 0; i < this._skipTicksAtOnce; ++i) {
                    if (!this._tickBuffer.hasNextTick()) {
                        this._waitingNextTick || (this._tickBuffer.requestTicks(), this._startWaitingNextTick());
                        break;
                    }
                    var nextFrameTime = this._currentTime + this._frameTime, nextTickTime = this._tickBuffer.readNextTickTime();
                    if (null == nextTickTime && (nextTickTime = nextFrameTime), targetTime < nextFrameTime) {
                        if (!(nextTickTime <= targetTime)) break;
                        nextFrameTime = targetTime;
                    } else if (nextFrameTime < nextTickTime) {
                        this._sceneLocalMode === g.LocalTickMode.InterpolateLocal && this._doLocalTick();
                        continue;
                    }
                    this._currentTime = nextFrameTime;
                    var tick = this._tickBuffer.consume(), consumedAge = -1, pevs = this._eventBuffer.readLocalEvents();
                    if (pevs) for (var j = 0, len = pevs.length; j < len; ++j) game.events.push(this._eventConverter.toGameEvent(pevs[j]));
                    if ("number" == typeof tick) consumedAge = tick, sceneChanged = game.tick(!0); else {
                        consumedAge = tick[0];
                        var pevs_1 = tick[1];
                        if (pevs_1) for (var j = 0, len = pevs_1.length; j < len; ++j) game.events.push(this._eventConverter.toGameEvent(pevs_1[j]));
                        sceneChanged = game.tick(!0);
                    }
                    if (game._notifyPassedAgeTable[consumedAge] && game.fireAgePassedIfNeeded()) {
                        frameArg.interrupt = !0;
                        break;
                    }
                    if (sceneChanged) {
                        this._handleSceneChange();
                        break;
                    }
                }
            }, GameLoop.prototype._onFrameNormal = function(frameArg) {
                var sceneChanged = !1, game = this._game;
                if (this._waitingNextTick) return void (this._sceneLocalMode === g.LocalTickMode.InterpolateLocal && this._doLocalTick());
                var targetAge, ageGap;
                if (this._loopMode === LoopMode_1.default.Realtime ? (targetAge = this._tickBuffer.knownLatestAge + 1, 
                ageGap = targetAge - this._tickBuffer.currentAge) : null === this._targetAge ? (targetAge = null, 
                ageGap = 1) : this._targetAge === this._tickBuffer.currentAge ? (targetAge = this._targetAge = null, 
                ageGap = 1) : (targetAge = this._targetAge, ageGap = targetAge - this._tickBuffer.currentAge), 
                (ageGap > this._jumpTryThreshold || ageGap < 0) && !this._waitingStartPoint && this._lastRequestedStartPointAge < this._tickBuffer.currentAge && (this._waitingStartPoint = !0, 
                this._lastRequestedStartPointAge = targetAge, this._amflow.getStartPoint({
                    frame: targetAge
                }, this._onGotStartPoint_bound)), this._skipping) {
                    var skipStopGap = this._loopMode === LoopMode_1.default.Realtime ? 0 : 1;
                    ageGap <= skipStopGap && this._stopSkipping();
                } else ageGap > this._skipThreshold && this._startSkipping();
                if (ageGap <= 0) return 0 === ageGap && (this._sceneTickMode !== g.TickGenerationMode.Manual && this._loopMode !== LoopMode_1.default.Replay || 0 !== this._tickBuffer.currentAge || this._tickBuffer.requestTicks(), 
                this._startWaitingNextTick()), void (this._sceneLocalMode === g.LocalTickMode.InterpolateLocal && this._doLocalTick());
                for (var loopCount = !this._skipping && ageGap <= this._delayIgnoreThreshold ? 1 : Math.min(ageGap, this._skipTicksAtOnce), i = 0; i < loopCount; ++i) {
                    var nextFrameTime = this._currentTime + this._frameTime;
                    if (this._loopMode === LoopMode_1.default.Realtime) ; else {
                        var nextTickTime = this._tickBuffer.readNextTickTime();
                        if (null != nextTickTime && nextFrameTime < nextTickTime) {
                            if (this._sceneLocalMode === g.LocalTickMode.InterpolateLocal) {
                                this._doLocalTick();
                                continue;
                            }
                            break;
                        }
                    }
                    this._currentTime = nextFrameTime;
                    var tick = this._tickBuffer.consume(), consumedAge = -1;
                    if (null == tick) {
                        this._tickBuffer.requestTicks(), this._startWaitingNextTick();
                        break;
                    }
                    var pevs = this._eventBuffer.readLocalEvents();
                    if (pevs) for (var i_1 = 0, len = pevs.length; i_1 < len; ++i_1) game.events.push(this._eventConverter.toGameEvent(pevs[i_1]));
                    if ("number" == typeof tick) consumedAge = tick, sceneChanged = game.tick(!0); else {
                        consumedAge = tick[0];
                        var pevs_2 = tick[1];
                        if (pevs_2) for (var j = 0, len = pevs_2.length; j < len; ++j) game.events.push(this._eventConverter.toGameEvent(pevs_2[j]));
                        sceneChanged = game.tick(!0);
                    }
                    if (game._notifyPassedAgeTable[consumedAge] && game.fireAgePassedIfNeeded()) {
                        frameArg.interrupt = !0;
                        break;
                    }
                    if (sceneChanged) {
                        this._handleSceneChange();
                        break;
                    }
                }
            }, GameLoop.prototype._onGotNextFrameTick = function() {
                this._waitingNextTick && this._loopMode !== LoopMode_1.default.FrameByFrame && this._stopWaitingNextTick();
            }, GameLoop.prototype._onGotStartPoint = function(err, startPoint) {
                if (this._waitingStartPoint = !1, err) throw new Error();
                if (this._targetTimeFunc && this._loopMode !== LoopMode_1.default.Realtime) {
                    var targetTime = this._targetTimeFunc() + this._realTargetTimeOffset;
                    if (targetTime < startPoint.timestamp) return;
                    var currentTime = this._currentTime;
                    if (currentTime < targetTime && startPoint.timestamp < currentTime + this._jumpIgnoreThreshold * this._frameTime) return;
                } else {
                    var targetAge = this._loopMode === LoopMode_1.default.Realtime ? this._tickBuffer.knownLatestAge : this._targetAge;
                    if (null === targetAge || targetAge < startPoint.frame) return;
                    var currentAge = this._tickBuffer.currentAge;
                    if (currentAge < targetAge && startPoint.frame < currentAge + this._jumpIgnoreThreshold) return;
                }
                this._clock.frameTrigger.remove(this._eventBuffer, this._eventBuffer.processEvents), 
                this._tickBuffer.setCurrentAge(startPoint.frame), this._currentTime = startPoint.timestamp || startPoint.data.timestamp || 0, 
                this._waitingNextTick = !1, this._lastRequestedStartPointAge = -1, this._lastRequestedStartPointTime = -1, 
                this._game._restartWithSnapshot(startPoint), this._handleSceneChange(), this.start();
            }, GameLoop.prototype._onGameStarted = function() {
                this._clock.frameTrigger.handleInsert(0, this._eventBuffer, this._eventBuffer.processEvents);
            }, GameLoop.prototype._setLoopRenderMode = function(mode) {
                if (mode !== this._loopRenderMode) switch (this._loopRenderMode = mode, mode) {
                  case LoopRenderMode_1.default.AfterRawFrame:
                    this._clock.rawFrameTrigger.handle(this, this._renderOnRawFrame);
                    break;

                  case LoopRenderMode_1.default.None:
                    this._clock.rawFrameTrigger.remove(this, this._renderOnRawFrame);
                    break;

                  default:
                    this.errorTrigger.fire(new Error("GameLoop#_setLoopRenderMode: unknown mode: " + mode));
                }
            }, GameLoop.prototype._renderOnRawFrame = function() {
                var game = this._game;
                game.modified && game.scenes.length > 0 && game.render();
            }, GameLoop.prototype._onGameRaiseEvent = function(e) {
                var pev = this._eventConverter.toPlaylogEvent(e);
                this._eventBuffer.onEvent(pev);
            }, GameLoop.prototype._onGameRaiseTick = function(es) {
                if (this._executionMode === ExecutionMode_1.default.Active) {
                    if (es) for (var i = 0; i < es.length; ++i) this._eventBuffer.addEventDirect(this._eventConverter.toPlaylogEvent(es[i]));
                    this._tickController.forceGenerateTick();
                }
            }, GameLoop.prototype._onGameOperationPluginOperated = function(op) {
                var pev = this._eventConverter.makePlaylogOperationEvent(op);
                this._eventBuffer.onEvent(pev);
            }, GameLoop.prototype._onPollingTick = function() {
                var time = +new Date();
                time - this._lastPollingTickTime > this._pollingTickThreshold && (this._lastPollingTickTime = time, 
                this._tickBuffer.requestTicks());
            }, GameLoop.prototype._startWaitingNextTick = function() {
                this._waitingNextTick = !0, this._clock.rawFrameTrigger.handle(this, this._onPollingTick), 
                this._lastPollingTickTime = +new Date();
            }, GameLoop.prototype._stopWaitingNextTick = function() {
                this._waitingNextTick = !1, this._clock.rawFrameTrigger.remove(this, this._onPollingTick);
            }, GameLoop;
        }();
        GameLoop.DEFAULT_DELAY_IGNORE_THRESHOLD = 6, GameLoop.DEFAULT_SKIP_TICKS_AT_ONCE = 100, 
        GameLoop.DEFAULT_SKIP_THRESHOLD = 3e4, GameLoop.DEFAULT_JUMP_TRY_THRESHOLD = 9e4, 
        GameLoop.DEFAULT_JUMP_IGNORE_THRESHOLD = 15e3, GameLoop.DEFAULT_POLLING_TICK_THRESHOLD = 1e4, 
        GameLoop.DEFAULT_DELAY_IGNORE_THERSHOLD = GameLoop.DEFAULT_DELAY_IGNORE_THRESHOLD, 
        exports.GameLoop = GameLoop;
    }, {
        "./Clock": 1,
        "./EventConverter": 3,
        "./EventIndex": 4,
        "./ExecutionMode": 5,
        "./LoopMode": 10,
        "./LoopRenderMode": 11,
        "./ProfilerClock": 14,
        "./TickController": 17,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    9: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = (require("@akashic/playlog"), require("@akashic/akashic-engine")), JoinLeaveRequest = (require("./EventIndex"), 
        function() {
            function JoinLeaveRequest(pev, joinResolver, amflow, keys) {
                this.joinResolver = joinResolver, this.pev = pev, 0 === pev[0] && keys ? (this.resolved = !1, 
                amflow.getStorageData(keys, this._onGotStorageData.bind(this))) : this.resolved = !0;
            }
            return JoinLeaveRequest.prototype._onGotStorageData = function(err, sds) {
                return this.resolved = !0, err ? void this.joinResolver.errorTrigger.fire(err) : void (this.pev[4] = sds);
            }, JoinLeaveRequest;
        }());
        exports.JoinLeaveRequest = JoinLeaveRequest;
        var JoinResolver = function() {
            function JoinResolver(param) {
                this.errorTrigger = new g.Trigger(), param.errorHandler && this.errorTrigger.handle(param.errorHandlerOwner, param.errorHandler), 
                this._amflow = param.amflow, this._keysForJoin = null, this._requested = [];
            }
            return JoinResolver.prototype.request = function(pev) {
                this._requested.push(new JoinLeaveRequest(pev, this, this._amflow, this._keysForJoin));
            }, JoinResolver.prototype.readResolved = function() {
                var len = this._requested.length;
                if (0 === len || !this._requested[0].resolved) return null;
                for (var ret = [], i = 0; i < len; ++i) {
                    var req = this._requested[i];
                    if (!req.resolved) break;
                    ret.push(req.pev);
                }
                return this._requested.splice(0, i), ret;
            }, JoinResolver.prototype.setRequestValuesForJoin = function(keys) {
                this._keysForJoin = keys;
            }, JoinResolver;
        }();
        exports.JoinResolver = JoinResolver;
    }, {
        "./EventIndex": 4,
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "@akashic/playlog": 26
    } ],
    10: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var LoopMode;
        !function(LoopMode) {
            LoopMode[LoopMode.Realtime = 0] = "Realtime", LoopMode[LoopMode.Replay = 1] = "Replay", 
            LoopMode[LoopMode.FrameByFrame = 2] = "FrameByFrame";
        }(LoopMode || (LoopMode = {})), exports.default = LoopMode;
    }, {} ],
    11: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var LoopRenderMode;
        !function(LoopRenderMode) {
            LoopRenderMode[LoopRenderMode.AfterRawFrame = 0] = "AfterRawFrame", LoopRenderMode[LoopRenderMode.None = 1] = "None";
        }(LoopRenderMode || (LoopRenderMode = {})), exports.default = LoopRenderMode;
    }, {} ],
    12: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var PdiUtil, es6_promise_1 = require("es6-promise"), g = require("@akashic/akashic-engine");
        !function(PdiUtil) {
            function makeLoadConfigurationFunc(pf) {
                function loadResolvedConfiguration(url, basePath, callback) {
                    pf.loadGameConfiguration(url, function(err, conf) {
                        if (err) return void callback(err, null);
                        try {
                            conf = PdiUtil._resolveConfigurationBasePath(conf, null != basePath ? basePath : g.PathUtil.resolveDirname(url));
                        } catch (e) {
                            return void callback(e, null);
                        }
                        if (!conf.definitions) return void callback(null, conf);
                        var defs = conf.definitions.map(function(def) {
                            return "string" == typeof def ? promisifiedLoad(def) : promisifiedLoad(def.url, def.basePath);
                        });
                        es6_promise_1.Promise.all(defs).then(function(confs) {
                            return callback(null, confs.reduce(PdiUtil._mergeGameConfiguration));
                        }).catch(function(e) {
                            return callback(e, null);
                        });
                    });
                }
                function promisifiedLoad(url, basePath) {
                    return new es6_promise_1.Promise(function(resolve, reject) {
                        loadResolvedConfiguration(url, basePath, function(err, conf) {
                            err ? reject(err) : resolve(conf);
                        });
                    });
                }
                return loadResolvedConfiguration;
            }
            function _resolveConfigurationBasePath(configuration, basePath) {
                function resolvePath(base, path) {
                    var ret = g.PathUtil.resolvePath(base, path);
                    if (0 !== ret.indexOf(base)) throw g.ExceptionFactory.createAssertionError("PdiUtil._resolveConfigurationBasePath: invalid path: " + path);
                    return ret;
                }
                var assets = configuration.assets;
                if (assets instanceof Object) for (var p in assets) assets.hasOwnProperty(p) && "path" in assets[p] && (assets[p].virtualPath = assets[p].virtualPath || assets[p].path, 
                assets[p].path = resolvePath(basePath, assets[p].path));
                return configuration.globalScripts && (configuration.globalScripts.forEach(function(path) {
                    if (assets.hasOwnProperty(path)) throw g.ExceptionFactory.createAssertionError("PdiUtil._resolveConfigurationBasePath: asset ID already exists: " + path);
                    assets[path] = {
                        type: /\.json$/i.test(path) ? "text" : "script",
                        virtualPath: path,
                        path: resolvePath(basePath, path),
                        global: !0
                    };
                }), delete configuration.globalScripts), configuration;
            }
            function _mergeObject(target, source) {
                for (var ks = Object.keys(source), i = 0, len = ks.length; i < len; ++i) {
                    var k = ks[i], sourceVal = source[k], sourceValType = typeof sourceVal, targetValType = typeof target[k];
                    if (sourceValType === targetValType) switch (typeof sourceVal) {
                      case "string":
                      case "number":
                      case "boolean":
                        target[k] = sourceVal;
                        break;

                      case "object":
                        null == sourceVal ? target[k] = sourceVal : Array.isArray(sourceVal) ? target[k] = target[k].concat(sourceVal) : PdiUtil._mergeObject(target[k], sourceVal);
                        break;

                      default:
                        throw new Error("PdiUtil._mergeObject(): unknown type");
                    } else target[k] = sourceVal;
                }
                return target;
            }
            function _mergeGameConfiguration(target, source) {
                return PdiUtil._mergeObject(target, source);
            }
            PdiUtil.makeLoadConfigurationFunc = makeLoadConfigurationFunc, PdiUtil._resolveConfigurationBasePath = _resolveConfigurationBasePath, 
            PdiUtil._mergeObject = _mergeObject, PdiUtil._mergeGameConfiguration = _mergeGameConfiguration;
        }(PdiUtil = exports.PdiUtil || (exports.PdiUtil = {}));
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "es6-promise": 27
    } ],
    13: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var PointEventResolver = (require("@akashic/playlog"), function() {
            function PointEventResolver(param) {
                this._game = param.game, this._pointEventMap = {};
            }
            return PointEventResolver.prototype.pointDown = function(e) {
                var player = this._game.player, source = this._game.findPointSource(e.offset), point = source.point ? source.point : e.offset, targetId = source.target ? source.target.id : null;
                this._pointEventMap[e.identifier] = {
                    targetId: targetId,
                    local: source.local,
                    point: point,
                    start: {
                        x: e.offset.x,
                        y: e.offset.y
                    },
                    prev: {
                        x: e.offset.x,
                        y: e.offset.y
                    }
                };
                var ret = [ 33, 2, player.id, e.identifier, point.x, point.y, targetId ];
                return source.local && ret.push(source.local), ret;
            }, PointEventResolver.prototype.pointMove = function(e) {
                var player = this._game.player, holder = this._pointEventMap[e.identifier];
                if (!holder) return null;
                var prev = {
                    x: 0,
                    y: 0
                }, start = {
                    x: 0,
                    y: 0
                };
                this._pointMoveAndUp(holder, e.offset, prev, start);
                var ret = [ 34, 2, player.id, e.identifier, holder.point.x, holder.point.y, start.x, start.y, prev.x, prev.y, holder.targetId ];
                return holder.local && ret.push(holder.local), ret;
            }, PointEventResolver.prototype.pointUp = function(e) {
                var player = this._game.player, holder = this._pointEventMap[e.identifier];
                if (!holder) return null;
                var prev = {
                    x: 0,
                    y: 0
                }, start = {
                    x: 0,
                    y: 0
                };
                this._pointMoveAndUp(holder, e.offset, prev, start), delete this._pointEventMap[e.identifier];
                var ret = [ 35, 2, player.id, e.identifier, holder.point.x, holder.point.y, start.x, start.y, prev.x, prev.y, holder.targetId ];
                return holder.local && ret.push(holder.local), ret;
            }, PointEventResolver.prototype._pointMoveAndUp = function(holder, offset, prevDelta, startDelta) {
                startDelta.x = offset.x - holder.start.x, startDelta.y = offset.y - holder.start.y, 
                prevDelta.x = offset.x - holder.prev.x, prevDelta.y = offset.y - holder.prev.y, 
                holder.prev.x = offset.x, holder.prev.y = offset.y;
            }, PointEventResolver;
        }());
        exports.PointEventResolver = PointEventResolver;
    }, {
        "@akashic/playlog": 26
    } ],
    14: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var Clock_1 = require("./Clock"), ProfilerClock = function(_super) {
            function ProfilerClock(param) {
                var _this = _super.call(this, param) || this;
                return _this._profiler = param.profiler, _this;
            }
            return __extends(ProfilerClock, _super), ProfilerClock.prototype._onLooperCall = function(deltaTime) {
                if (deltaTime <= 0) return this._waitTime - this._totalDeltaTime;
                deltaTime > this._deltaTimeBrokenThreshold && (deltaTime = this._waitTime);
                var totalDeltaTime = this._totalDeltaTime;
                if (totalDeltaTime += deltaTime, totalDeltaTime <= this._skipFrameWaitTime) return this._totalDeltaTime = totalDeltaTime, 
                this._waitTime - totalDeltaTime;
                this._profiler.timeEnd(1), this._profiler.time(1);
                var frameCount = totalDeltaTime < this._waitTimeDoubled ? 1 : totalDeltaTime > this._waitTimeMax ? this._realMaxFramePerOnce : totalDeltaTime / this._waitTime | 0, fc = frameCount, arg = {
                    interrupt: !1
                };
                for (this._profiler.setValue(0, fc - 1); fc > 0 && this.running && !arg.interrupt; ) --fc, 
                this._profiler.time(2), this.frameTrigger.fire(arg), this._profiler.timeEnd(2);
                return totalDeltaTime -= (frameCount - fc) * this._waitTime, this._profiler.time(3), 
                this.rawFrameTrigger.fire(), this._profiler.timeEnd(3), this._totalDeltaTime = totalDeltaTime, 
                this._profiler.flush(), this._waitTime - totalDeltaTime;
            }, ProfilerClock;
        }(Clock_1.Clock);
        exports.ProfilerClock = ProfilerClock;
    }, {
        "./Clock": 1
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), ExecutionMode_1 = require("./ExecutionMode"), StorageResolver = function() {
            function StorageResolver(param) {
                this.errorTrigger = new g.Trigger(), param.errorHandler && this.errorTrigger.handle(param.errorHandlerOwner, param.errorHandler), 
                this.getStorageFunc = this._getStorage.bind(this), this.putStorageFunc = this._putStorage.bind(this), 
                this.requestValuesForJoinFunc = this._requestValuesForJoin.bind(this), this._game = param.game, 
                this._amflow = param.amflow, this._tickGenerator = param.tickGenerator, this._tickBuffer = param.tickBuffer, 
                this._executionMode = null, this.setExecutionMode(param.executionMode), this._unresolvedLoaders = {}, 
                this._unresolvedStorages = {}, this._onStoragePut_bound = this._onStoragePut.bind(this);
            }
            return StorageResolver.prototype.setExecutionMode = function(executionMode) {
                if (this._executionMode !== executionMode) {
                    this._executionMode = executionMode;
                    var tickBuf = this._tickBuffer, tickGen = this._tickGenerator;
                    executionMode === ExecutionMode_1.default.Active ? (tickBuf.gotStorageTrigger.remove(this, this._onGotStorageOnTick), 
                    tickGen.gotStorageTrigger.handle(this, this._onGotStorageOnTick)) : (tickGen.gotStorageTrigger.remove(this, this._onGotStorageOnTick), 
                    tickBuf.gotStorageTrigger.handle(this, this._onGotStorageOnTick));
                }
            }, StorageResolver.prototype._onGotStorageOnTick = function(storageOnTick) {
                var resolvingAge = storageOnTick.age, storageData = storageOnTick.storageData, loader = this._unresolvedLoaders[resolvingAge];
                if (!loader) return void (this._unresolvedStorages[resolvingAge] = storageData);
                delete this._unresolvedLoaders[resolvingAge];
                var serialization = resolvingAge, values = storageData.map(function(d) {
                    return d.values;
                });
                loader._onLoaded(values, serialization);
            }, StorageResolver.prototype._getStorage = function(keys, loader, ser) {
                var resolvingAge;
                null != ser ? (resolvingAge = ser, this._tickBuffer.requestTicks(resolvingAge, 1)) : this._executionMode === ExecutionMode_1.default.Active ? resolvingAge = this._tickGenerator.requestStorageTick(keys) : (resolvingAge = this._game.age, 
                this._tickBuffer.requestTicks(resolvingAge, 1));
                var sd = this._unresolvedStorages[resolvingAge];
                if (!sd) return void (this._unresolvedLoaders[resolvingAge] = loader);
                delete this._unresolvedStorages[resolvingAge];
                var serialization = resolvingAge, values = sd.map(function(d) {
                    return d.values;
                });
                loader._onLoaded(values, serialization);
            }, StorageResolver.prototype._putStorage = function(key, value, option) {
                this._executionMode === ExecutionMode_1.default.Active && this._amflow.putStorageData(key, value, option, this._onStoragePut_bound);
            }, StorageResolver.prototype._requestValuesForJoin = function(keys) {
                this._tickGenerator.setRequestValuesForJoin(keys);
            }, StorageResolver.prototype._onStoragePut = function(err) {
                err && this.errorTrigger.fire(err);
            }, StorageResolver;
        }();
        exports.StorageResolver = StorageResolver;
    }, {
        "./ExecutionMode": 5,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    16: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = (require("@akashic/playlog"), require("@akashic/akashic-engine")), ExecutionMode_1 = (require("./EventIndex"), 
        require("./ExecutionMode")), TickBuffer = function() {
            function TickBuffer(param) {
                this.currentAge = 0, this.knownLatestAge = -1, this.gotNextTickTrigger = new g.Trigger(), 
                this.gotStorageTrigger = new g.Trigger(), this._amflow = param.amflow, this._prefetchThreshold = param.prefetchThreshold || TickBuffer.DEFAULT_PREFETCH_THRESHOLD, 
                this._sizeRequestOnce = param.sizeRequestOnce || TickBuffer.DEFAULT_SIZE_REQUEST_ONCE, 
                this._executionMode = param.executionMode, this._receiving = !1, this._tickRanges = [], 
                this._nearestAbsentAge = this.currentAge, this._nextTickTimeCache = null, this._addTick_bound = this.addTick.bind(this), 
                this._onTicks_bound = this._onTicks.bind(this);
            }
            return TickBuffer.prototype.start = function() {
                this._receiving = !0, this._updateAmflowReceiveState();
            }, TickBuffer.prototype.stop = function() {
                this._receiving = !1, this._updateAmflowReceiveState();
            }, TickBuffer.prototype.setExecutionMode = function(execMode) {
                this._executionMode !== execMode && (this._dropUntil(this.knownLatestAge + 1), this._nextTickTimeCache = null, 
                this._nearestAbsentAge = this.currentAge, this._executionMode = execMode, this._updateAmflowReceiveState());
            }, TickBuffer.prototype.setCurrentAge = function(age) {
                this._dropUntil(age), this._nextTickTimeCache = null, this.currentAge = age, this._nearestAbsentAge = this._findNearestAbscentAge(age);
            }, TickBuffer.prototype.hasNextTick = function() {
                return this.currentAge !== this._nearestAbsentAge;
            }, TickBuffer.prototype.consume = function() {
                if (this.currentAge === this._nearestAbsentAge) return null;
                var age = this.currentAge, range = this._tickRanges[0];
                return age === range.start ? (this._nextTickTimeCache = null, ++this.currentAge, 
                ++range.start, age + this._prefetchThreshold === this._nearestAbsentAge && this.requestTicks(this._nearestAbsentAge, this._sizeRequestOnce), 
                range.start === range.end && this._tickRanges.shift(), range.ticks.length > 0 && range.ticks[0][0] === age ? range.ticks.shift() : age) : (this._dropUntil(this.currentAge), 
                this.consume());
            }, TickBuffer.prototype.readNextTickTime = function() {
                if (null != this._nextTickTimeCache) return this._nextTickTimeCache;
                if (this.currentAge === this._nearestAbsentAge) return null;
                var age = this.currentAge, range = this._tickRanges[0];
                if (age === range.start) {
                    if (0 === range.ticks.length) return null;
                    var tick = range.ticks[0];
                    if (tick[0] !== age) return null;
                    var pevs = tick[1];
                    if (!pevs) return null;
                    for (var i = 0; i < pevs.length; ++i) if (2 === pevs[i][0]) return this._nextTickTimeCache = pevs[i][3], 
                    this._nextTickTimeCache;
                    return null;
                }
                return this._dropUntil(this.currentAge), this.readNextTickTime();
            }, TickBuffer.prototype.requestTicks = function(from, len) {
                void 0 === from && (from = this.currentAge), void 0 === len && (len = this._sizeRequestOnce), 
                this._executionMode === ExecutionMode_1.default.Passive && this._amflow.getTickList(from, from + len, this._onTicks_bound);
            }, TickBuffer.prototype.addTick = function(tick) {
                var age = tick[0], gotNext = this.currentAge === age && this._nearestAbsentAge === age;
                this.knownLatestAge < age && (this.knownLatestAge = age), tick[2] && this.gotStorageTrigger.fire({
                    age: tick[0],
                    storageData: tick[2]
                });
                for (var i = this._tickRanges.length - 1; i >= 0; --i) {
                    var range = this._tickRanges[i];
                    if (age >= range.start) break;
                }
                var nextRange = this._tickRanges[i + 1];
                if (i < 0) this._tickRanges.unshift(this._createTickRangeFromTick(tick)); else {
                    var range = this._tickRanges[i];
                    age === range.end ? (++range.end, tick[1] && range.ticks.push(tick)) : age > range.end && this._tickRanges.splice(i + 1, 0, this._createTickRangeFromTick(tick));
                }
                this._nearestAbsentAge === age && (++this._nearestAbsentAge, nextRange && this._nearestAbsentAge === nextRange.start && (this._nearestAbsentAge = this._findNearestAbscentAge(this._nearestAbsentAge))), 
                gotNext && this.gotNextTickTrigger.fire();
            }, TickBuffer.prototype.addTickList = function(tickList) {
                var start = tickList[0], end = tickList[1] + 1, ticks = tickList[2], origStart = start, origEnd = end;
                this.knownLatestAge < end - 1 && (this.knownLatestAge = end - 1);
                var i = 0, len = this._tickRanges.length;
                for (i = 0; i < len; ++i) {
                    var range_1 = this._tickRanges[i];
                    if (start < range_1.start) break;
                }
                var insertPoint = i;
                if (i > 0) {
                    --i;
                    var leftEndAge = this._tickRanges[i].end;
                    start < leftEndAge && (start = leftEndAge);
                }
                for (;i < len; ++i) {
                    var range_2 = this._tickRanges[i];
                    if (end <= range_2.end) break;
                }
                if (i < len) {
                    var rightStartAge = this._tickRanges[i].start;
                    end > rightStartAge && (end = rightStartAge);
                }
                if (start >= end) return {
                    start: start,
                    end: start,
                    ticks: []
                };
                ticks || (ticks = []), origStart === start && origEnd === end || (ticks = ticks.filter(function(tick) {
                    var age = tick[0];
                    return start <= age && age < end;
                }));
                for (var j = 0; j < ticks.length; ++j) {
                    var tick = ticks[j];
                    tick[2] && this.gotStorageTrigger.fire({
                        age: tick[0],
                        storageData: tick[2]
                    });
                }
                var range = {
                    start: start,
                    end: end,
                    ticks: ticks
                }, delLen = Math.max(0, i - insertPoint);
                return this._tickRanges.splice(insertPoint, delLen, range), start <= this._nearestAbsentAge && this._nearestAbsentAge < end && (this._nearestAbsentAge = this._findNearestAbscentAge(this._nearestAbsentAge)), 
                range;
            }, TickBuffer.prototype._updateAmflowReceiveState = function() {
                this._receiving && this._executionMode === ExecutionMode_1.default.Passive ? this._amflow.onTick(this._addTick_bound) : this._amflow.offTick(this._addTick_bound);
            }, TickBuffer.prototype._onTicks = function(err, ticks) {
                if (err) throw new Error();
                if (ticks) {
                    var mayGotNext = this.currentAge === this._nearestAbsentAge, inserted = this.addTickList(ticks);
                    mayGotNext && inserted.start <= this.currentAge && this.currentAge < inserted.end && this.gotNextTickTrigger.fire();
                }
            }, TickBuffer.prototype._findNearestAbscentAge = function(age) {
                for (var i = 0, len = this._tickRanges.length; i < len && !(age <= this._tickRanges[i].end); ++i) ;
                for (;i < len; ++i) {
                    var range = this._tickRanges[i];
                    if (age < range.start) break;
                    age = range.end;
                }
                return age;
            }, TickBuffer.prototype._dropUntil = function(age) {
                var i;
                for (i = 0; i < this._tickRanges.length && !(age < this._tickRanges[i].end); ++i) ;
                if (this._tickRanges = this._tickRanges.slice(i), 0 !== this._tickRanges.length) {
                    var range = this._tickRanges[0];
                    if (!(age < range.start)) {
                        for (range.start = age, i = 0; i < range.ticks.length && !(age <= range.ticks[i][0]); ++i) ;
                        range.ticks = range.ticks.slice(i);
                    }
                }
            }, TickBuffer.prototype._createTickRangeFromTick = function(tick) {
                var age = tick[0], range = {
                    start: age,
                    end: age + 1,
                    ticks: []
                };
                return tick[1] && range.ticks.push(tick), range;
            }, TickBuffer;
        }();
        TickBuffer.DEFAULT_PREFETCH_THRESHOLD = 1800, TickBuffer.DEFAULT_SIZE_REQUEST_ONCE = 9e3, 
        exports.TickBuffer = TickBuffer;
    }, {
        "./EventIndex": 4,
        "./ExecutionMode": 5,
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "@akashic/playlog": 26
    } ],
    17: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), ExecutionMode_1 = require("./ExecutionMode"), TickBuffer_1 = require("./TickBuffer"), TickGenerator_1 = require("./TickGenerator"), sr = require("./StorageResolver"), TickController = function() {
            function TickController(param) {
                this.errorTrigger = new g.Trigger(), param.errorHandler && this.errorTrigger.handle(param.errorHandlerOwner, param.errorHandler), 
                this._amflow = param.amflow, this._clock = param.clock, this._started = !1, this._executionMode = param.executionMode, 
                this._generator = new TickGenerator_1.TickGenerator({
                    amflow: param.amflow,
                    eventBuffer: param.eventBuffer,
                    errorHandler: this.errorTrigger.fire,
                    errorHandlerOwner: this.errorTrigger
                }), this._buffer = new TickBuffer_1.TickBuffer({
                    amflow: param.amflow,
                    executionMode: param.executionMode
                }), this._storageResolver = new sr.StorageResolver({
                    game: param.game,
                    amflow: param.amflow,
                    tickGenerator: this._generator,
                    tickBuffer: this._buffer,
                    executionMode: param.executionMode,
                    errorHandler: this.errorTrigger.fire,
                    errorHandlerOwner: this.errorTrigger
                }), this._generator.tickTrigger.handle(this, this._onTickGenerated), this._clock.frameTrigger.handle(this._generator, this._generator.next);
            }
            return TickController.prototype.startTick = function() {
                this._started = !0, this._updateGeneratorState();
            }, TickController.prototype.stopTick = function() {
                this._started = !1, this._updateGeneratorState();
            }, TickController.prototype.startTickOnce = function() {
                this._started = !0, this._generator.tickTrigger.handle(this, this._stopTriggerOnTick), 
                this._updateGeneratorState();
            }, TickController.prototype.setNextAge = function(age) {
                this._generator.setNextAge(age);
            }, TickController.prototype.forceGenerateTick = function() {
                this._generator.forceNext();
            }, TickController.prototype.getBuffer = function() {
                return this._buffer;
            }, TickController.prototype.storageFunc = function() {
                return {
                    storageGetFunc: this._storageResolver.getStorageFunc,
                    storagePutFunc: this._storageResolver.putStorageFunc,
                    requestValuesForJoinFunc: this._storageResolver.requestValuesForJoinFunc
                };
            }, TickController.prototype.setExecutionMode = function(execMode) {
                this._executionMode !== execMode && (this._executionMode = execMode, this._updateGeneratorState(), 
                this._buffer.setExecutionMode(execMode), this._storageResolver.setExecutionMode(execMode));
            }, TickController.prototype._stopTriggerOnTick = function() {
                return this.stopTick(), !0;
            }, TickController.prototype._updateGeneratorState = function() {
                var toGenerate = this._started && this._executionMode === ExecutionMode_1.default.Active;
                this._generator.startStopGenerate(toGenerate);
            }, TickController.prototype._onTickGenerated = function(tick) {
                this._amflow.sendTick(tick), this._buffer.addTick(tick);
            }, TickController;
        }();
        exports.TickController = TickController;
    }, {
        "./ExecutionMode": 5,
        "./StorageResolver": 15,
        "./TickBuffer": 16,
        "./TickGenerator": 18,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    18: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), JoinResolver_1 = require("./JoinResolver"), TickGenerator = function() {
            function TickGenerator(param) {
                this.tickTrigger = new g.Trigger(), this.gotStorageTrigger = new g.Trigger(), this.errorTrigger = new g.Trigger(), 
                param.errorHandler && this.errorTrigger.handle(param.errorHandlerOwner, param.errorHandler), 
                this._amflow = param.amflow, this._eventBuffer = param.eventBuffer, this._joinResolver = new JoinResolver_1.JoinResolver({
                    amflow: param.amflow,
                    errorHandler: this.errorTrigger.fire,
                    errorHandlerOwner: this.errorTrigger
                }), this._nextAge = 0, this._storageDataForNext = null, this._generatingTick = !1, 
                this._waitingStorage = !1, this._onGotStorageData_bound = this._onGotStorageData.bind(this);
            }
            return TickGenerator.prototype.next = function() {
                if (this._generatingTick && !this._waitingStorage) {
                    var joinLeaves = this._eventBuffer.readJoinLeaves();
                    if (joinLeaves) for (var i = 0; i < joinLeaves.length; ++i) this._joinResolver.request(joinLeaves[i]);
                    var evs = this._eventBuffer.readEvents(), resolvedJoinLeaves = this._joinResolver.readResolved();
                    resolvedJoinLeaves && (evs ? evs.push.apply(evs, resolvedJoinLeaves) : evs = resolvedJoinLeaves);
                    var sds = this._storageDataForNext;
                    this._storageDataForNext = null, this.tickTrigger.fire([ this._nextAge++, evs, sds ]);
                }
            }, TickGenerator.prototype.forceNext = function() {
                if (this._waitingStorage) return void this.errorTrigger.fire(new Error("TickGenerator#forceNext(): cannot generate tick while waiting storage."));
                var origValue = this._generatingTick;
                this._generatingTick = !0, this.next(), this._generatingTick = origValue;
            }, TickGenerator.prototype.startStopGenerate = function(toGenerate) {
                this._generatingTick = toGenerate;
            }, TickGenerator.prototype.startTick = function() {
                this._generatingTick = !0;
            }, TickGenerator.prototype.stopTick = function() {
                this._generatingTick = !1;
            }, TickGenerator.prototype.setNextAge = function(age) {
                return this._waitingStorage ? void this.errorTrigger.fire(new Error("TickGenerator#setNextAge(): cannot change the next age while waiting storage.")) : void (this._nextAge = age);
            }, TickGenerator.prototype.requestStorageTick = function(keys) {
                if (this._waitingStorage) {
                    var err = g.ExceptionFactory.createAssertionError("TickGenerator#requestStorageTick(): Unsupported: multiple storage request");
                    return this.errorTrigger.fire(err), -1;
                }
                return this._waitingStorage = !0, this._amflow.getStorageData(keys, this._onGotStorageData_bound), 
                this._nextAge;
            }, TickGenerator.prototype.setRequestValuesForJoin = function(keys) {
                this._joinResolver.setRequestValuesForJoin(keys);
            }, TickGenerator.prototype._onGotStorageData = function(err, sds) {
                return this._waitingStorage = !1, err ? void this.errorTrigger.fire(err) : (this._storageDataForNext = sds, 
                void this.gotStorageTrigger.fire({
                    age: this._nextAge,
                    storageData: sds
                }));
            }, TickGenerator;
        }();
        exports.TickGenerator = TickGenerator;
    }, {
        "./JoinResolver": 9,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    19: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var MemoryAmflowClient = (require("../EventIndex"), function() {
            function MemoryAmflowClient(param) {
                this._playId = param.playId, this._putStorageDataSyncFunc = param.putStorageDataSyncFunc || function() {
                    throw new Error("Implementation not given");
                }, this._getStorageDataSyncFunc = param.getStorageDataSyncFunc || function() {
                    throw new Error("Implementation not given");
                }, this._tickHandlers = [], this._eventHandlers = [], this._events = [], this._tickList = null, 
                param.startPoints ? (this._tickList = param.tickList, this._startPoints = param.startPoints) : this._startPoints = [];
            }
            return MemoryAmflowClient.prototype.dump = function() {
                return {
                    tickList: this._tickList,
                    startPoints: this._startPoints
                };
            }, MemoryAmflowClient.prototype.open = function(playId, callback) {
                var _this = this;
                setTimeout(function() {
                    return playId !== _this._playId ? void callback(new Error("MemoryAmflowClient#open: unknown playId")) : void callback();
                }, 0);
            }, MemoryAmflowClient.prototype.close = function(callback) {
                setTimeout(function() {
                    callback();
                }, 0);
            }, MemoryAmflowClient.prototype.authenticate = function(token, callback) {
                setTimeout(function() {
                    switch (token) {
                      case MemoryAmflowClient.TOKEN_ACTIVE:
                        callback(null, {
                            writeTick: !0,
                            readTick: !0,
                            subscribeTick: !1,
                            sendEvent: !1,
                            subscribeEvent: !0,
                            maxEventPriority: 2
                        });
                        break;

                      case MemoryAmflowClient.TOKEN_PASSIVE:
                        callback(null, {
                            writeTick: !1,
                            readTick: !0,
                            subscribeTick: !0,
                            sendEvent: !0,
                            subscribeEvent: !1,
                            maxEventPriority: 2
                        });
                        break;

                      default:
                        callback(null, {
                            writeTick: !0,
                            readTick: !0,
                            subscribeTick: !0,
                            sendEvent: !0,
                            subscribeEvent: !0,
                            maxEventPriority: 2
                        });
                    }
                }, 0);
            }, MemoryAmflowClient.prototype.sendTick = function(tick) {
                if (this._tickList) {
                    if (this._tickList[0] <= tick[0] && tick[0] <= this._tickList[1]) throw new Error("illegal age tick");
                    this._tickList[1] = tick[0];
                } else this._tickList = [ tick[0], tick[0], [] ];
                (tick[1] || tick[2]) && this._tickList[2].push(tick), this._tickHandlers.forEach(function(h) {
                    return h(tick);
                });
            }, MemoryAmflowClient.prototype.onTick = function(handler) {
                this._tickHandlers.push(handler);
            }, MemoryAmflowClient.prototype.offTick = function(handler) {
                this._tickHandlers = this._tickHandlers.filter(function(h) {
                    return h !== handler;
                });
            }, MemoryAmflowClient.prototype.sendEvent = function(pev) {
                return 0 === this._eventHandlers.length ? void this._events.push(pev) : void this._eventHandlers.forEach(function(h) {
                    return h(pev);
                });
            }, MemoryAmflowClient.prototype.onEvent = function(handler) {
                var _this = this;
                this._eventHandlers.push(handler), this._events.length > 0 && (this._events.forEach(function(pev) {
                    _this._eventHandlers.forEach(function(h) {
                        return h(pev);
                    });
                }), this._events = []);
            }, MemoryAmflowClient.prototype.offEvent = function(handler) {
                this._eventHandlers = this._eventHandlers.filter(function(h) {
                    return h !== handler;
                });
            }, MemoryAmflowClient.prototype.getTickList = function(from, to, callback) {
                if (!this._tickList) return void setTimeout(function() {
                    return callback(null, null);
                }, 0);
                from = Math.max(from, this._tickList[0]), to = Math.min(to, this._tickList[1]);
                var ticks = this._tickList[2].filter(function(tick) {
                    var age = tick[0];
                    return from <= age && age <= to;
                }), tickList = [ from, to, ticks ];
                setTimeout(function() {
                    return callback(null, tickList);
                }, 0);
            }, MemoryAmflowClient.prototype.putStartPoint = function(startPoint, callback) {
                var _this = this;
                setTimeout(function() {
                    _this._startPoints.push(startPoint), callback(null);
                }, 0);
            }, MemoryAmflowClient.prototype.getStartPoint = function(opts, callback) {
                var _this = this;
                setTimeout(function() {
                    if (!_this._startPoints || 0 === _this._startPoints.length) return void callback(new Error("no startpoint"));
                    var index = 0;
                    if (null != opts.frame) for (var nearestFrame = _this._startPoints[0].frame, i = 1; i < _this._startPoints.length; ++i) {
                        var frame = _this._startPoints[i].frame;
                        frame <= opts.frame && nearestFrame < frame && (nearestFrame = frame, index = i);
                    } else for (var nearestTimestamp = _this._startPoints[0].timestamp, i = 1; i < _this._startPoints.length; ++i) {
                        var timestamp = _this._startPoints[i].timestamp;
                        timestamp <= opts.timestamp && nearestTimestamp < timestamp && (nearestTimestamp = timestamp, 
                        index = i);
                    }
                    callback(null, _this._startPoints[index]);
                }, 0);
            }, MemoryAmflowClient.prototype.putStorageData = function(key, value, options, callback) {
                var _this = this;
                setTimeout(function() {
                    try {
                        _this._putStorageDataSyncFunc(key, value, options), callback(null);
                    } catch (e) {
                        callback(e);
                    }
                }, 0);
            }, MemoryAmflowClient.prototype.getStorageData = function(keys, callback) {
                var _this = this;
                setTimeout(function() {
                    try {
                        var data = _this._getStorageDataSyncFunc(keys);
                        callback(null, data);
                    } catch (e) {
                        callback(e);
                    }
                }, 0);
            }, MemoryAmflowClient.prototype.dropAfter = function(age) {
                if (this._tickList) {
                    var from = this._tickList[0], to = this._tickList[1];
                    age <= from ? (this._tickList = null, this._startPoints = []) : age <= to && (this._tickList[1] = age - 1, 
                    this._tickList[2] = this._tickList[2].filter(function(tick) {
                        var ta = tick[0];
                        return from <= ta && ta <= age - 1;
                    }), this._startPoints = this._startPoints.filter(function(sp) {
                        return sp.frame < age;
                    }));
                }
            }, MemoryAmflowClient;
        }());
        MemoryAmflowClient.TOKEN_ACTIVE = "mamfc-token:active", MemoryAmflowClient.TOKEN_PASSIVE = "mamfc-token:passive", 
        exports.MemoryAmflowClient = MemoryAmflowClient;
    }, {
        "../EventIndex": 4
    } ],
    20: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var ReplayAmflowProxy = (require("../EventIndex"), function() {
            function ReplayAmflowProxy(param) {
                this._amflow = param.amflow, this._tickList = param.tickList, this._startPoints = param.startPoints;
            }
            return ReplayAmflowProxy.prototype.dropAfter = function(age) {
                if (this._tickList) {
                    var givenFrom = this._tickList[0], givenTo = this._tickList[1], givenTicksWithEvents = this._tickList[2];
                    age <= givenFrom ? (this._tickList = null, this._startPoints = []) : age <= givenTo && (this._tickList[1] = age - 1, 
                    this._tickList[2] = this._sliceTicks(givenTicksWithEvents, givenTo, age - 1), this._startPoints = this._startPoints.filter(function(sp) {
                        return sp.frame < age;
                    }));
                }
            }, ReplayAmflowProxy.prototype.open = function(playId, callback) {
                this._amflow.open(playId, callback);
            }, ReplayAmflowProxy.prototype.close = function(callback) {
                this._amflow.close(callback);
            }, ReplayAmflowProxy.prototype.authenticate = function(token, callback) {
                this._amflow.authenticate(token, callback);
            }, ReplayAmflowProxy.prototype.sendTick = function(tick) {
                this._amflow.sendTick(tick);
            }, ReplayAmflowProxy.prototype.onTick = function(handler) {
                this._amflow.onTick(handler);
            }, ReplayAmflowProxy.prototype.offTick = function(handler) {
                this._amflow.offTick(handler);
            }, ReplayAmflowProxy.prototype.sendEvent = function(event) {
                this._amflow.sendEvent(event);
            }, ReplayAmflowProxy.prototype.onEvent = function(handler) {
                this._amflow.onEvent(handler);
            }, ReplayAmflowProxy.prototype.offEvent = function(handler) {
                this._amflow.offEvent(handler);
            }, ReplayAmflowProxy.prototype.getTickList = function(from, to, callback) {
                var _this = this;
                if (!this._tickList) return void this._amflow.getTickList(from, to, callback);
                var givenFrom = this._tickList[0], givenTo = this._tickList[1], givenTicksWithEvents = this._tickList[2], fromInGiven = givenFrom <= from && from <= givenTo, toInGiven = givenFrom <= to && to <= givenTo;
                fromInGiven && toInGiven ? setTimeout(function() {
                    callback(null, [ from, to, _this._sliceTicks(givenTicksWithEvents, from, to) ]);
                }, 0) : this._amflow.getTickList(from, to, function(err, tickList) {
                    if (err) return void callback(err);
                    if (tickList) if (fromInGiven || toInGiven) if (fromInGiven) {
                        var ticksWithEvents = _this._sliceTicks(givenTicksWithEvents, from, to).concat(tickList[2] || []);
                        callback(null, [ from, tickList[1], ticksWithEvents ]);
                    } else {
                        var ticksWithEvents = (tickList[2] || []).concat(_this._sliceTicks(givenTicksWithEvents, from, to));
                        callback(null, [ tickList[0], to, ticksWithEvents ]);
                    } else if (to < givenFrom || givenTo < from) callback(null, tickList); else {
                        var ticksWithEvents = tickList[2];
                        if (ticksWithEvents) {
                            var beforeGiven = _this._sliceTicks(ticksWithEvents, from, givenFrom - 1), afterGiven = _this._sliceTicks(ticksWithEvents, givenTo + 1, to);
                            ticksWithEvents = beforeGiven.concat(givenTicksWithEvents, afterGiven);
                        } else ticksWithEvents = givenTicksWithEvents;
                        callback(null, [ from, to, ticksWithEvents ]);
                    } else fromInGiven || toInGiven ? fromInGiven ? callback(null, [ from, givenTo, _this._sliceTicks(givenTicksWithEvents, from, to) ]) : callback(null, [ givenFrom, to, _this._sliceTicks(givenTicksWithEvents, from, to) ]) : to < givenFrom || givenTo < from ? callback(null, tickList) : callback(null, [ givenFrom, givenTo, _this._sliceTicks(givenTicksWithEvents, from, to) ]);
                });
            }, ReplayAmflowProxy.prototype.putStartPoint = function(startPoint, callback) {
                this._amflow.putStartPoint(startPoint, callback);
            }, ReplayAmflowProxy.prototype.getStartPoint = function(opts, callback) {
                var _this = this, index = 0;
                if (this._startPoints.length > 0) if (null != opts.frame) for (var nearestFrame = this._startPoints[0].frame, i = 1; i < this._startPoints.length; ++i) {
                    var frame = this._startPoints[i].frame;
                    frame <= opts.frame && nearestFrame < frame && (nearestFrame = frame, index = i);
                } else for (var nearestTimestamp = this._startPoints[0].timestamp, i = 1; i < this._startPoints.length; ++i) {
                    var timestamp = this._startPoints[i].timestamp;
                    timestamp <= opts.timestamp && nearestTimestamp < timestamp && (nearestTimestamp = timestamp, 
                    index = i);
                }
                var givenTo = this._tickList ? this._tickList[1] : -1;
                opts.frame > givenTo ? this._amflow.getStartPoint(opts, function(err, startPoint) {
                    return err ? void callback(err) : void (givenTo < startPoint.frame ? callback(null, startPoint) : callback(null, _this._startPoints[index]));
                }) : setTimeout(function() {
                    callback(null, _this._startPoints[index]);
                }, 0);
            }, ReplayAmflowProxy.prototype.putStorageData = function(key, value, options, callback) {
                this._amflow.putStorageData(key, value, options, callback);
            }, ReplayAmflowProxy.prototype.getStorageData = function(keys, callback) {
                this._amflow.getStorageData(keys, callback);
            }, ReplayAmflowProxy.prototype._sliceTicks = function(ticks, from, to) {
                return ticks.filter(function(t) {
                    var age = t[0];
                    return from <= age && age <= to;
                });
            }, ReplayAmflowProxy;
        }());
        exports.ReplayAmflowProxy = ReplayAmflowProxy;
    }, {
        "../EventIndex": 4
    } ],
    21: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), SimpleProfiler = function() {
            function SimpleProfiler(param) {
                this._interval = null != param.interval ? param.interval : SimpleProfiler.DEFAULT_INTERVAL, 
                null != param.limit ? this._limit = param.limit >= SimpleProfiler.DEFAULT_LIMIT ? param.limit : SimpleProfiler.DEFAULT_LIMIT : this._limit = SimpleProfiler.DEFAULT_LIMIT, 
                this._calculateProfilerValueTrigger = new g.Trigger(), param.getValueHandler && this._calculateProfilerValueTrigger.handle(param.getValueHandlerOwner, param.getValueHandler), 
                this._reset();
            }
            return SimpleProfiler.prototype.time = function(type) {
                this._beforeTimes[type] = this._getCurrentTime();
            }, SimpleProfiler.prototype.timeEnd = function(type) {
                var now = this._getCurrentTime(), value = null != this._beforeTimes[type] ? now - this._beforeTimes[type] : 0;
                this._values[type].push({
                    time: now,
                    value: value
                });
            }, SimpleProfiler.prototype.flush = function() {
                var now = this._getCurrentTime();
                if (0 === this._beforeFlushTime && (this._beforeFlushTime = now), this._beforeFlushTime + this._interval < now && (this._calculateProfilerValueTrigger.fire(this.getProfilerValue(this._interval)), 
                this._beforeFlushTime = now), this._values[1].length > this._limit) for (var i in this._values) this._values.hasOwnProperty(i) && (this._values[i] = this._values[i].slice(-SimpleProfiler.BACKUP_MARGIN));
            }, SimpleProfiler.prototype.setValue = function(type, value) {
                this._values[type].push({
                    time: this._getCurrentTime(),
                    value: value
                });
            }, SimpleProfiler.prototype.getProfilerValue = function(time) {
                var rawFrameInterval = this._calculateProfilerValue(1, time);
                return {
                    skippedFrameCount: this._calculateProfilerValue(0, time),
                    rawFrameInterval: rawFrameInterval,
                    framePerSecond: {
                        ave: 1e3 / rawFrameInterval.ave,
                        max: 1e3 / rawFrameInterval.min,
                        min: 1e3 / rawFrameInterval.max
                    },
                    frameTime: this._calculateProfilerValue(2, time),
                    renderingTime: this._calculateProfilerValue(3, time)
                };
            }, SimpleProfiler.prototype._reset = function() {
                this._startTime = this._getCurrentTime(), this._beforeFlushTime = 0, this._beforeTimes = [], 
                this._beforeTimes[1] = 0, this._beforeTimes[2] = 0, this._beforeTimes[3] = 0, this._beforeTimes[0] = 0, 
                this._values = [], this._values[1] = [], this._values[2] = [], this._values[3] = [], 
                this._values[0] = [];
            }, SimpleProfiler.prototype._calculateProfilerValue = function(type, time) {
                for (var limit = this._getCurrentTime() - time, sum = 0, num = 0, max = 0, min = Number.MAX_VALUE, i = this._values[type].length - 1; i >= 0 && !(0 < num && this._values[type][i].time < limit); --i) {
                    var value = this._values[type][i].value;
                    max < value && (max = value), value < min && (min = value), sum += value, ++num;
                }
                return {
                    ave: sum / num,
                    max: max,
                    min: min
                };
            }, SimpleProfiler.prototype._getCurrentTime = function() {
                return +new Date();
            }, SimpleProfiler;
        }();
        SimpleProfiler.DEFAULT_INTERVAL = 1e3, SimpleProfiler.DEFAULT_LIMIT = 1e3, SimpleProfiler.BACKUP_MARGIN = 100, 
        exports.SimpleProfiler = SimpleProfiler;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    22: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    }, {} ],
    23: [ function(require, module, exports) {}, {} ],
    24: [ function(require, module, exports) {
        arguments[4][23][0].apply(exports, arguments);
    }, {
        dup: 23
    } ],
    25: [ function(require, module, exports) {
        arguments[4][23][0].apply(exports, arguments);
    }, {
        dup: 23
    } ],
    26: [ function(require, module, exports) {
        function __export(m) {
            for (var p in m) exports.hasOwnProperty(p) || (exports[p] = m[p]);
        }
        __export(require("./Tick")), __export(require("./Event")), __export(require("./StorageData"));
    }, {
        "./Event": 23,
        "./StorageData": 24,
        "./Tick": 25
    } ],
    27: [ function(require, module, exports) {
        (function(process, global) {
            /*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */
            !function(global, factory) {
                "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.ES6Promise = factory();
            }(this, function() {
                "use strict";
                function objectOrFunction(x) {
                    return "function" == typeof x || "object" == typeof x && null !== x;
                }
                function isFunction(x) {
                    return "function" == typeof x;
                }
                function setScheduler(scheduleFn) {
                    customSchedulerFn = scheduleFn;
                }
                function setAsap(asapFn) {
                    asap = asapFn;
                }
                function useNextTick() {
                    return function() {
                        return process.nextTick(flush);
                    };
                }
                function useVertxTimer() {
                    return function() {
                        vertxNext(flush);
                    };
                }
                function useMutationObserver() {
                    var iterations = 0, observer = new BrowserMutationObserver(flush), node = document.createTextNode("");
                    return observer.observe(node, {
                        characterData: !0
                    }), function() {
                        node.data = iterations = ++iterations % 2;
                    };
                }
                function useMessageChannel() {
                    var channel = new MessageChannel();
                    return channel.port1.onmessage = flush, function() {
                        return channel.port2.postMessage(0);
                    };
                }
                function useSetTimeout() {
                    var globalSetTimeout = setTimeout;
                    return function() {
                        return globalSetTimeout(flush, 1);
                    };
                }
                function flush() {
                    for (var i = 0; i < len; i += 2) {
                        var callback = queue[i], arg = queue[i + 1];
                        callback(arg), queue[i] = void 0, queue[i + 1] = void 0;
                    }
                    len = 0;
                }
                function attemptVertx() {
                    try {
                        var r = require, vertx = r("vertx");
                        return vertxNext = vertx.runOnLoop || vertx.runOnContext, useVertxTimer();
                    } catch (e) {
                        return useSetTimeout();
                    }
                }
                function then(onFulfillment, onRejection) {
                    var _arguments = arguments, parent = this, child = new this.constructor(noop);
                    void 0 === child[PROMISE_ID] && makePromise(child);
                    var _state = parent._state;
                    return _state ? !function() {
                        var callback = _arguments[_state - 1];
                        asap(function() {
                            return invokeCallback(_state, child, callback, parent._result);
                        });
                    }() : subscribe(parent, child, onFulfillment, onRejection), child;
                }
                function resolve(object) {
                    var Constructor = this;
                    if (object && "object" == typeof object && object.constructor === Constructor) return object;
                    var promise = new Constructor(noop);
                    return _resolve(promise, object), promise;
                }
                function noop() {}
                function selfFulfillment() {
                    return new TypeError("You cannot resolve a promise with itself");
                }
                function cannotReturnOwn() {
                    return new TypeError("A promises callback cannot return that same promise.");
                }
                function getThen(promise) {
                    try {
                        return promise.then;
                    } catch (error) {
                        return GET_THEN_ERROR.error = error, GET_THEN_ERROR;
                    }
                }
                function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
                    try {
                        then.call(value, fulfillmentHandler, rejectionHandler);
                    } catch (e) {
                        return e;
                    }
                }
                function handleForeignThenable(promise, thenable, then) {
                    asap(function(promise) {
                        var sealed = !1, error = tryThen(then, thenable, function(value) {
                            sealed || (sealed = !0, thenable !== value ? _resolve(promise, value) : fulfill(promise, value));
                        }, function(reason) {
                            sealed || (sealed = !0, _reject(promise, reason));
                        }, "Settle: " + (promise._label || " unknown promise"));
                        !sealed && error && (sealed = !0, _reject(promise, error));
                    }, promise);
                }
                function handleOwnThenable(promise, thenable) {
                    thenable._state === FULFILLED ? fulfill(promise, thenable._result) : thenable._state === REJECTED ? _reject(promise, thenable._result) : subscribe(thenable, void 0, function(value) {
                        return _resolve(promise, value);
                    }, function(reason) {
                        return _reject(promise, reason);
                    });
                }
                function handleMaybeThenable(promise, maybeThenable, then$$) {
                    maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve ? handleOwnThenable(promise, maybeThenable) : then$$ === GET_THEN_ERROR ? _reject(promise, GET_THEN_ERROR.error) : void 0 === then$$ ? fulfill(promise, maybeThenable) : isFunction(then$$) ? handleForeignThenable(promise, maybeThenable, then$$) : fulfill(promise, maybeThenable);
                }
                function _resolve(promise, value) {
                    promise === value ? _reject(promise, selfFulfillment()) : objectOrFunction(value) ? handleMaybeThenable(promise, value, getThen(value)) : fulfill(promise, value);
                }
                function publishRejection(promise) {
                    promise._onerror && promise._onerror(promise._result), publish(promise);
                }
                function fulfill(promise, value) {
                    promise._state === PENDING && (promise._result = value, promise._state = FULFILLED, 
                    0 !== promise._subscribers.length && asap(publish, promise));
                }
                function _reject(promise, reason) {
                    promise._state === PENDING && (promise._state = REJECTED, promise._result = reason, 
                    asap(publishRejection, promise));
                }
                function subscribe(parent, child, onFulfillment, onRejection) {
                    var _subscribers = parent._subscribers, length = _subscribers.length;
                    parent._onerror = null, _subscribers[length] = child, _subscribers[length + FULFILLED] = onFulfillment, 
                    _subscribers[length + REJECTED] = onRejection, 0 === length && parent._state && asap(publish, parent);
                }
                function publish(promise) {
                    var subscribers = promise._subscribers, settled = promise._state;
                    if (0 !== subscribers.length) {
                        for (var child = void 0, callback = void 0, detail = promise._result, i = 0; i < subscribers.length; i += 3) child = subscribers[i], 
                        callback = subscribers[i + settled], child ? invokeCallback(settled, child, callback, detail) : callback(detail);
                        promise._subscribers.length = 0;
                    }
                }
                function ErrorObject() {
                    this.error = null;
                }
                function tryCatch(callback, detail) {
                    try {
                        return callback(detail);
                    } catch (e) {
                        return TRY_CATCH_ERROR.error = e, TRY_CATCH_ERROR;
                    }
                }
                function invokeCallback(settled, promise, callback, detail) {
                    var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = void 0, failed = void 0;
                    if (hasCallback) {
                        if (value = tryCatch(callback, detail), value === TRY_CATCH_ERROR ? (failed = !0, 
                        error = value.error, value = null) : succeeded = !0, promise === value) return void _reject(promise, cannotReturnOwn());
                    } else value = detail, succeeded = !0;
                    promise._state !== PENDING || (hasCallback && succeeded ? _resolve(promise, value) : failed ? _reject(promise, error) : settled === FULFILLED ? fulfill(promise, value) : settled === REJECTED && _reject(promise, value));
                }
                function initializePromise(promise, resolver) {
                    try {
                        resolver(function(value) {
                            _resolve(promise, value);
                        }, function(reason) {
                            _reject(promise, reason);
                        });
                    } catch (e) {
                        _reject(promise, e);
                    }
                }
                function nextId() {
                    return id++;
                }
                function makePromise(promise) {
                    promise[PROMISE_ID] = id++, promise._state = void 0, promise._result = void 0, promise._subscribers = [];
                }
                function Enumerator(Constructor, input) {
                    this._instanceConstructor = Constructor, this.promise = new Constructor(noop), this.promise[PROMISE_ID] || makePromise(this.promise), 
                    isArray(input) ? (this._input = input, this.length = input.length, this._remaining = input.length, 
                    this._result = new Array(this.length), 0 === this.length ? fulfill(this.promise, this._result) : (this.length = this.length || 0, 
                    this._enumerate(), 0 === this._remaining && fulfill(this.promise, this._result))) : _reject(this.promise, validationError());
                }
                function validationError() {
                    return new Error("Array Methods must be provided an Array");
                }
                function all(entries) {
                    return new Enumerator(this, entries).promise;
                }
                function race(entries) {
                    var Constructor = this;
                    return new Constructor(isArray(entries) ? function(resolve, reject) {
                        for (var length = entries.length, i = 0; i < length; i++) Constructor.resolve(entries[i]).then(resolve, reject);
                    } : function(_, reject) {
                        return reject(new TypeError("You must pass an array to race."));
                    });
                }
                function reject(reason) {
                    var Constructor = this, promise = new Constructor(noop);
                    return _reject(promise, reason), promise;
                }
                function needsResolver() {
                    throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                }
                function needsNew() {
                    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                }
                function Promise(resolver) {
                    this[PROMISE_ID] = nextId(), this._result = this._state = void 0, this._subscribers = [], 
                    noop !== resolver && ("function" != typeof resolver && needsResolver(), this instanceof Promise ? initializePromise(this, resolver) : needsNew());
                }
                function polyfill() {
                    var local = void 0;
                    if ("undefined" != typeof global) local = global; else if ("undefined" != typeof self) local = self; else try {
                        local = Function("return this")();
                    } catch (e) {
                        throw new Error("polyfill failed because global object is unavailable in this environment");
                    }
                    var P = local.Promise;
                    if (P) {
                        var promiseToString = null;
                        try {
                            promiseToString = Object.prototype.toString.call(P.resolve());
                        } catch (e) {}
                        if ("[object Promise]" === promiseToString && !P.cast) return;
                    }
                    local.Promise = Promise;
                }
                var _isArray = void 0;
                _isArray = Array.isArray ? Array.isArray : function(x) {
                    return "[object Array]" === Object.prototype.toString.call(x);
                };
                var isArray = _isArray, len = 0, vertxNext = void 0, customSchedulerFn = void 0, asap = function(callback, arg) {
                    queue[len] = callback, queue[len + 1] = arg, len += 2, 2 === len && (customSchedulerFn ? customSchedulerFn(flush) : scheduleFlush());
                }, browserWindow = "undefined" != typeof window ? window : void 0, browserGlobal = browserWindow || {}, BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver, isNode = "undefined" == typeof self && "undefined" != typeof process && "[object process]" === {}.toString.call(process), isWorker = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel, queue = new Array(1e3), scheduleFlush = void 0;
                scheduleFlush = isNode ? useNextTick() : BrowserMutationObserver ? useMutationObserver() : isWorker ? useMessageChannel() : void 0 === browserWindow && "function" == typeof require ? attemptVertx() : useSetTimeout();
                var PROMISE_ID = Math.random().toString(36).substring(16), PENDING = void 0, FULFILLED = 1, REJECTED = 2, GET_THEN_ERROR = new ErrorObject(), TRY_CATCH_ERROR = new ErrorObject(), id = 0;
                return Enumerator.prototype._enumerate = function() {
                    for (var length = this.length, _input = this._input, i = 0; this._state === PENDING && i < length; i++) this._eachEntry(_input[i], i);
                }, Enumerator.prototype._eachEntry = function(entry, i) {
                    var c = this._instanceConstructor, resolve$$ = c.resolve;
                    if (resolve$$ === resolve) {
                        var _then = getThen(entry);
                        if (_then === then && entry._state !== PENDING) this._settledAt(entry._state, i, entry._result); else if ("function" != typeof _then) this._remaining--, 
                        this._result[i] = entry; else if (c === Promise) {
                            var promise = new c(noop);
                            handleMaybeThenable(promise, entry, _then), this._willSettleAt(promise, i);
                        } else this._willSettleAt(new c(function(resolve$$) {
                            return resolve$$(entry);
                        }), i);
                    } else this._willSettleAt(resolve$$(entry), i);
                }, Enumerator.prototype._settledAt = function(state, i, value) {
                    var promise = this.promise;
                    promise._state === PENDING && (this._remaining--, state === REJECTED ? _reject(promise, value) : this._result[i] = value), 
                    0 === this._remaining && fulfill(promise, this._result);
                }, Enumerator.prototype._willSettleAt = function(promise, i) {
                    var enumerator = this;
                    subscribe(promise, void 0, function(value) {
                        return enumerator._settledAt(FULFILLED, i, value);
                    }, function(reason) {
                        return enumerator._settledAt(REJECTED, i, reason);
                    });
                }, Promise.all = all, Promise.race = race, Promise.resolve = resolve, Promise.reject = reject, 
                Promise._setScheduler = setScheduler, Promise._setAsap = setAsap, Promise._asap = asap, 
                Promise.prototype = {
                    constructor: Promise,
                    then: then,
                    catch: function(onRejection) {
                        return this.then(null, onRejection);
                    }
                }, polyfill(), Promise.polyfill = polyfill, Promise.Promise = Promise, Promise;
            });
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        _process: 28
    } ],
    28: [ function(require, module, exports) {
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
            clearTimeout(marker);
            try {
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, runClearTimeout(timeout);
            }
        }
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
        process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, {} ],
    "@akashic/game-driver": [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var EventIndex = require("./EventIndex");
        exports.EventIndex = EventIndex;
        var LoopMode_1 = require("./LoopMode");
        exports.LoopMode = LoopMode_1.default;
        var LoopRenderMode_1 = require("./LoopRenderMode");
        exports.LoopRenderMode = LoopRenderMode_1.default;
        var ExecutionMode_1 = require("./ExecutionMode");
        exports.ExecutionMode = ExecutionMode_1.default;
        var GameDriver_1 = require("./GameDriver");
        exports.GameDriver = GameDriver_1.GameDriver;
        var Game_1 = require("./Game");
        exports.Game = Game_1.Game;
        var ReplayAmflowProxy_1 = require("./auxiliary/ReplayAmflowProxy");
        exports.ReplayAmflowProxy = ReplayAmflowProxy_1.ReplayAmflowProxy;
        var MemoryAmflowClient_1 = require("./auxiliary/MemoryAmflowClient");
        exports.MemoryAmflowClient = MemoryAmflowClient_1.MemoryAmflowClient;
        var SimpleProfiler_1 = require("./auxiliary/SimpleProfiler");
        exports.SimpleProfiler = SimpleProfiler_1.SimpleProfiler;
    }, {
        "./EventIndex": 4,
        "./ExecutionMode": 5,
        "./Game": 6,
        "./GameDriver": 7,
        "./LoopMode": 10,
        "./LoopRenderMode": 11,
        "./auxiliary/MemoryAmflowClient": 19,
        "./auxiliary/ReplayAmflowProxy": 20,
        "./auxiliary/SimpleProfiler": 21
    } ]
}, {}, []);	require = function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
    return s;
}({
    "@akashic/pdi-browser": [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var Platform_1 = require("./Platform");
        exports.Platform = Platform_1.Platform;
        var ResourceFactory_1 = require("./ResourceFactory");
        exports.ResourceFactory = ResourceFactory_1.ResourceFactory;
        var g = require("@akashic/akashic-engine");
        exports.g = g;
        var AudioPluginRegistry_1 = require("./plugin/AudioPluginRegistry");
        exports.AudioPluginRegistry = AudioPluginRegistry_1.AudioPluginRegistry;
        var AudioPluginManager_1 = require("./plugin/AudioPluginManager");
        exports.AudioPluginManager = AudioPluginManager_1.AudioPluginManager;
        var HTMLAudioPlugin_1 = require("./plugin/HTMLAudioPlugin/HTMLAudioPlugin");
        exports.HTMLAudioPlugin = HTMLAudioPlugin_1.HTMLAudioPlugin;
        var WebAudioPlugin_1 = require("./plugin/WebAudioPlugin/WebAudioPlugin");
        exports.WebAudioPlugin = WebAudioPlugin_1.WebAudioPlugin;
    }, {
        "./Platform": 3,
        "./ResourceFactory": 5,
        "./plugin/AudioPluginManager": 34,
        "./plugin/AudioPluginRegistry": 35,
        "./plugin/HTMLAudioPlugin/HTMLAudioPlugin": 38,
        "./plugin/WebAudioPlugin/WebAudioPlugin": 42,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    1: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), RenderingHelper_1 = require("./canvas/RenderingHelper"), InputHandlerLayer_1 = require("./InputHandlerLayer"), ContainerController = function() {
            function ContainerController() {
                this.container = null, this.surface = null, this.inputHandlerLayer = null, this.rootView = null, 
                this.defaultSize = null, this.useResizeForScaling = !1, this.pointEventTrigger = new g.Trigger(), 
                this._rendererReq = null, this._disablePreventDefault = !1;
            }
            return ContainerController.prototype.initialize = function(param) {
                this._rendererReq = param.rendererRequirement, this._disablePreventDefault = !!param.disablePreventDefault, 
                this._loadView();
            }, ContainerController.prototype.setRootView = function(rootView) {
                var _this = this;
                rootView !== this.rootView && (this.rootView && (this.unloadView(), this._loadView()), 
                this.rootView = rootView, rootView.appendChild(this.container), this.inputHandlerLayer.enablePointerEvent(), 
                this.inputHandlerLayer.pointEventTrigger.handle(function(ev) {
                    _this.pointEventTrigger.fire(ev);
                }));
            }, ContainerController.prototype.getRenderer = function() {
                if (!this.surface) throw new Error("this container has no surface");
                return this.surface.renderer();
            }, ContainerController.prototype.fitToSize = function(viewportSize, noCenter) {
                var gameScale = Math.min(viewportSize.width / this._rendererReq.primarySurfaceWidth, viewportSize.height / this._rendererReq.primarySurfaceHeight), gameSize = {
                    width: Math.floor(this._rendererReq.primarySurfaceWidth * gameScale),
                    height: Math.floor(this._rendererReq.primarySurfaceHeight * gameScale)
                }, gameOffset = {
                    x: Math.floor((viewportSize.width - gameSize.width) / 2),
                    y: Math.floor((viewportSize.height - gameSize.height) / 2)
                };
                this.changeScale(gameScale, gameScale), noCenter && this.inputHandlerLayer.setOffset(gameOffset);
            }, ContainerController.prototype.revertSize = function() {
                this.fitToSize(this.defaultSize);
            }, ContainerController.prototype.changeScale = function(xScale, yScale) {
                this.useResizeForScaling ? this.surface.changeCanvasSize(this.defaultSize.width * xScale, this.defaultSize.height * yScale) : this.surface.changeCanvasScale(xScale, yScale, this.defaultSize), 
                this.inputHandlerLayer._inputHandler.setScale(xScale, yScale);
            }, ContainerController.prototype.unloadView = function() {
                if (this.inputHandlerLayer.disablePointerEvent(), this.rootView) for (;this.rootView.firstChild; ) this.rootView.removeChild(this.rootView.firstChild);
            }, ContainerController.prototype._loadView = function() {
                this.container = document.createDocumentFragment(), this.inputHandlerLayer = new InputHandlerLayer_1.InputHandlerLayer({
                    width: this._rendererReq.primarySurfaceWidth,
                    height: this._rendererReq.primarySurfaceHeight,
                    disablePreventDefault: this._disablePreventDefault
                }), this.surface = RenderingHelper_1.RenderingHelper.createPrimarySurface(this._rendererReq.primarySurfaceWidth, this._rendererReq.primarySurfaceHeight, this._rendererReq.rendererCandidates), 
                this.surface.setParentElement(this.inputHandlerLayer.view), this.container.appendChild(this.inputHandlerLayer.view), 
                this.defaultSize = {
                    width: this.surface.width,
                    height: this.surface.height
                };
            }, ContainerController;
        }();
        exports.ContainerController = ContainerController;
    }, {
        "./InputHandlerLayer": 2,
        "./canvas/RenderingHelper": 16,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    2: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), MouseHandler_1 = require("./handler/MouseHandler"), TouchHandler_1 = require("./handler/TouchHandler"), InputHandlerLayer = function() {
            function InputHandlerLayer(param) {
                this.view = this._createInputView(param.width, param.height), this._inputHandler = void 0, 
                this.pointEventTrigger = new g.Trigger(), this._disablePreventDefault = !!param.disablePreventDefault;
            }
            return InputHandlerLayer.prototype.enablePointerEvent = function() {
                var _this = this;
                TouchHandler_1.TouchHandler.isSupported() ? this._inputHandler = new TouchHandler_1.TouchHandler(this.view, this._disablePreventDefault) : this._inputHandler = new MouseHandler_1.MouseHandler(this.view, this._disablePreventDefault), 
                this._inputHandler.pointTrigger.handle(function(e) {
                    _this.pointEventTrigger.fire(e);
                }), this._inputHandler.start();
            }, InputHandlerLayer.prototype.disablePointerEvent = function() {
                this._inputHandler.stop();
            }, InputHandlerLayer.prototype.setOffset = function(offset) {
                var inputViewStyle = "position:relative; left:" + offset.x + "px; top:" + offset.y + "px";
                this._inputHandler.inputView.setAttribute("style", inputViewStyle), this._inputHandler.setOffset(offset);
            }, InputHandlerLayer.prototype.notifyViewMoved = function() {
                this._inputHandler.notifyViewMoved();
            }, InputHandlerLayer.prototype._createInputView = function(width, height) {
                var view = document.createElement("div");
                return view.setAttribute("tabindex", "1"), view.className = "input-handler", view.setAttribute("style", "display:inline-block; outline:none;"), 
                view.style.width = width + "px", view.style.height = height + "px", view;
            }, InputHandlerLayer;
        }();
        exports.InputHandlerLayer = InputHandlerLayer;
    }, {
        "./handler/MouseHandler": 32,
        "./handler/TouchHandler": 33,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    3: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var RafLooper_1 = require("./RafLooper"), ResourceFactory_1 = require("./ResourceFactory"), ContainerController_1 = require("./ContainerController"), AudioPluginManager_1 = require("./plugin/AudioPluginManager"), AudioPluginRegistry_1 = require("./plugin/AudioPluginRegistry"), XHRTextAsset_1 = require("./asset/XHRTextAsset"), Platform = function() {
            function Platform(param) {
                this.containerView = param.containerView, this.containerController = new ContainerController_1.ContainerController(), 
                this.audioPluginManager = new AudioPluginManager_1.AudioPluginManager(), param.audioPlugins && this.audioPluginManager.tryInstallPlugin(param.audioPlugins), 
                this.audioPluginManager.tryInstallPlugin(AudioPluginRegistry_1.AudioPluginRegistry.getRegisteredAudioPlugins()), 
                this.amflow = param.amflow, this._platformEventHandler = null, this._resourceFactory = param.resourceFactory || new ResourceFactory_1.ResourceFactory({
                    audioPluginManager: this.audioPluginManager,
                    platform: this
                }), this._rendererReq = null, this._disablePreventDefault = !!param.disablePreventDefault;
            }
            return Platform.prototype.setPlatformEventHandler = function(handler) {
                this.containerController && (this.containerController.pointEventTrigger.removeAll(this._platformEventHandler), 
                this.containerController.pointEventTrigger.handle(handler, handler.onPointEvent)), 
                this._platformEventHandler = handler;
            }, Platform.prototype.loadGameConfiguration = function(url, callback) {
                var a = new XHRTextAsset_1.XHRTextAsset("(game.json)", url);
                a._load({
                    _onAssetLoad: function(asset) {
                        callback(null, JSON.parse(a.data));
                    },
                    _onAssetError: function(asset, error) {
                        callback(error, null);
                    }
                });
            }, Platform.prototype.getResourceFactory = function() {
                return this._resourceFactory;
            }, Platform.prototype.setRendererRequirement = function(requirement) {
                if (!requirement) return void (this.containerController && this.containerController.unloadView());
                this._rendererReq = requirement, this._resourceFactory._rendererCandidates = this._rendererReq.rendererCandidates, 
                this.containerController.initialize({
                    rendererRequirement: this._rendererReq,
                    disablePreventDefault: this._disablePreventDefault
                }), this.containerController.setRootView(this.containerView), this._platformEventHandler && this.containerController.pointEventTrigger.handle(this._platformEventHandler, this._platformEventHandler.onPointEvent);
                var parentView = this.containerView.parentElement;
                this.defaultViewMargin = parentView.style.margin, this.defaultViewPadding = parentView.style.padding, 
                this.defaultViewOverflow = parentView.style.overflow;
            }, Platform.prototype.getPrimarySurface = function() {
                return this.containerController.surface;
            }, Platform.prototype.getOperationPluginViewInfo = function() {
                var _this = this;
                return {
                    type: "pdi-browser",
                    view: this.containerController.inputHandlerLayer.view,
                    getScale: function() {
                        return _this.containerController.inputHandlerLayer._inputHandler.getScale();
                    }
                };
            }, Platform.prototype.createLooper = function(fun) {
                return new RafLooper_1.RafLooper(fun);
            }, Platform.prototype.sendToExternal = function(playId, data) {}, Platform.prototype.registerAudioPlugins = function(plugins) {
                return this.audioPluginManager.tryInstallPlugin(plugins);
            }, Platform.prototype.setScale = function(xScale, yScale) {
                this.containerController.changeScale(xScale, yScale);
            }, Platform.prototype.fitToWindow = function(noCenter) {
                if (this.containerController) {
                    var parentView = this.containerView.parentElement;
                    parentView.style.margin = "0px", parentView.style.padding = "0px", parentView.style.overflow = "hidden";
                    var viewportSize = {
                        width: window.innerWidth || document.documentElement.clientWidth,
                        height: window.innerHeight || document.documentElement.clientHeight
                    };
                    this.containerController.fitToSize(viewportSize, noCenter);
                }
            }, Platform.prototype.revertViewSize = function() {
                var parentView = this.containerView.parentElement;
                parentView.style.margin = this.defaultViewMargin, parentView.style.padding = this.defaultViewPadding, 
                parentView.style.overflow = this.defaultViewOverflow, this.containerController.revertSize();
            }, Platform.prototype.notifyViewMoved = function() {
                this.containerController.inputHandlerLayer.notifyViewMoved();
            }, Platform;
        }();
        exports.Platform = Platform;
    }, {
        "./ContainerController": 1,
        "./RafLooper": 4,
        "./ResourceFactory": 5,
        "./asset/XHRTextAsset": 11,
        "./plugin/AudioPluginManager": 34,
        "./plugin/AudioPluginRegistry": 35
    } ],
    4: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var RafLooper = function() {
            function RafLooper(fun) {
                this._fun = fun, this._timerId = void 0, this._prev = 0;
            }
            return RafLooper.prototype.start = function() {
                var _this = this, onAnimationFrame = function(deltaTime) {
                    _this._timerId = requestAnimationFrame(onAnimationFrame), _this._fun(deltaTime - _this._prev), 
                    _this._prev = deltaTime;
                }, onFirstFrame = function(deltaTime) {
                    _this._timerId = requestAnimationFrame(onAnimationFrame), _this._fun(0), _this._prev = deltaTime;
                };
                this._timerId = requestAnimationFrame(onFirstFrame);
            }, RafLooper.prototype.stop = function() {
                cancelAnimationFrame(this._timerId), this._timerId = void 0, this._prev = 0;
            }, RafLooper;
        }();
        exports.RafLooper = RafLooper;
    }, {} ],
    5: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLImageAsset_1 = require("./asset/HTMLImageAsset"), HTMLVideoAsset_1 = require("./asset/HTMLVideoAsset"), XHRTextAsset_1 = require("./asset/XHRTextAsset"), XHRScriptAsset_1 = require("./asset/XHRScriptAsset"), RenderingHelper_1 = require("./canvas/RenderingHelper"), GlyphFactory_1 = require("./canvas/GlyphFactory"), SurfaceAtlas_1 = require("./canvas/SurfaceAtlas"), ResourceFactory = function(_super) {
            function ResourceFactory(param) {
                var _this = _super.call(this) || this;
                return _this._audioPluginManager = param.audioPluginManager, _this._platform = param.platform, 
                _this;
            }
            return __extends(ResourceFactory, _super), ResourceFactory.prototype.createAudioAsset = function(id, assetPath, duration, system, loop, hint) {
                var activePlugin = this._audioPluginManager.getActivePlugin();
                return activePlugin.createAsset(id, assetPath, duration, system, loop, hint);
            }, ResourceFactory.prototype.createAudioPlayer = function(system) {
                var activePlugin = this._audioPluginManager.getActivePlugin();
                return activePlugin.createPlayer(system);
            }, ResourceFactory.prototype.createImageAsset = function(id, assetPath, width, height) {
                return new HTMLImageAsset_1.HTMLImageAsset(id, assetPath, width, height);
            }, ResourceFactory.prototype.createVideoAsset = function(id, assetPath, width, height, system, loop, useRealSize) {
                return new HTMLVideoAsset_1.HTMLVideoAsset(id, assetPath, width, height, system, loop, useRealSize);
            }, ResourceFactory.prototype.createTextAsset = function(id, assetPath) {
                return new XHRTextAsset_1.XHRTextAsset(id, assetPath);
            }, ResourceFactory.prototype.createScriptAsset = function(id, assetPath) {
                return new XHRScriptAsset_1.XHRScriptAsset(id, assetPath);
            }, ResourceFactory.prototype.createSurface = function(width, height) {
                return RenderingHelper_1.RenderingHelper.createBackSurface(width, height, this._platform, this._rendererCandidates);
            }, ResourceFactory.prototype.createGlyphFactory = function(fontFamily, fontSize, baseline, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
                return new GlyphFactory_1.GlyphFactory(fontFamily, fontSize, baseline, RenderingHelper_1.RenderingHelper.usedWebGL(this._rendererCandidates), fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight);
            }, ResourceFactory.prototype.createSurfaceAtlas = function(width, height) {
                return new SurfaceAtlas_1.SurfaceAtlas(this.createSurface(width, height));
            }, ResourceFactory;
        }(g.ResourceFactory);
        exports.ResourceFactory = ResourceFactory;
    }, {
        "./asset/HTMLImageAsset": 7,
        "./asset/HTMLVideoAsset": 8,
        "./asset/XHRScriptAsset": 10,
        "./asset/XHRTextAsset": 11,
        "./canvas/GlyphFactory": 15,
        "./canvas/RenderingHelper": 16,
        "./canvas/SurfaceAtlas": 19,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    6: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var RuntimeInfo;
        !function(RuntimeInfo) {
            function pointerEnabled() {
                return "pointerEnabled" in window.navigator;
            }
            function msPointerEnabled() {
                return "msPointerEnabled" in window.navigator;
            }
            function touchEnabled() {
                return "ontouchstart" in window;
            }
            RuntimeInfo.pointerEnabled = pointerEnabled, RuntimeInfo.msPointerEnabled = msPointerEnabled, 
            RuntimeInfo.touchEnabled = touchEnabled;
        }(RuntimeInfo = exports.RuntimeInfo || (exports.RuntimeInfo = {}));
    }, {} ],
    7: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), ImageAssetSurface = function(_super) {
            function ImageAssetSurface(width, height, drawable) {
                return _super.call(this, width, height, drawable) || this;
            }
            return __extends(ImageAssetSurface, _super), ImageAssetSurface.prototype.renderer = function() {
                throw g.ExceptionFactory.createAssertionError("ImageAssetSurface cannot be rendered.");
            }, ImageAssetSurface.prototype.isPlaying = function() {
                return !1;
            }, ImageAssetSurface;
        }(g.Surface);
        exports.ImageAssetSurface = ImageAssetSurface;
        var HTMLImageAsset = function(_super) {
            function HTMLImageAsset(id, path, width, height) {
                var _this = _super.call(this, id, path, width, height) || this;
                return _this.data = void 0, _this._surface = void 0, _this;
            }
            return __extends(HTMLImageAsset, _super), HTMLImageAsset.prototype.destroy = function() {
                this._surface && !this._surface.destroyed() && this._surface.destroy(), this.data = void 0, 
                this._surface = void 0, _super.prototype.destroy.call(this);
            }, HTMLImageAsset.prototype._load = function(loader) {
                var _this = this, image = new Image();
                image.onerror = function() {
                    loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("HTMLImageAsset unknown loading error"));
                }, image.onload = function() {
                    _this.data = image, loader._onAssetLoad(_this);
                }, image.src = this.path;
            }, HTMLImageAsset.prototype.asSurface = function() {
                if (!this.data) throw g.ExceptionFactory.createAssertionError("ImageAssetImpl#asSurface: not yet loaded.");
                return this._surface ? this._surface : (this._surface = new ImageAssetSurface(this.width, this.height, this.data), 
                this._surface);
            }, HTMLImageAsset;
        }(g.ImageAsset);
        exports.HTMLImageAsset = HTMLImageAsset;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    8: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLVideoPlayer_1 = require("./HTMLVideoPlayer"), VideoAssetSurface = function(_super) {
            function VideoAssetSurface(width, height, drawable) {
                return _super.call(this, width, height, drawable, !0) || this;
            }
            return __extends(VideoAssetSurface, _super), VideoAssetSurface.prototype.renderer = function() {
                throw g.ExceptionFactory.createAssertionError("VideoAssetSurface cannot be rendered.");
            }, VideoAssetSurface.prototype.isPlaying = function() {
                return !1;
            }, VideoAssetSurface;
        }(g.Surface), HTMLVideoAsset = function(_super) {
            function HTMLVideoAsset(id, assetPath, width, height, system, loop, useRealSize) {
                var _this = _super.call(this, id, assetPath, width, height, system, loop, useRealSize) || this;
                return _this._player = new HTMLVideoPlayer_1.HTMLVideoPlayer(), _this._surface = new VideoAssetSurface(width, height, null), 
                _this;
            }
            return __extends(HTMLVideoAsset, _super), HTMLVideoAsset.prototype.inUse = function() {
                return !1;
            }, HTMLVideoAsset.prototype._load = function(loader) {
                var _this = this;
                setTimeout(function() {
                    loader._onAssetLoad(_this);
                }, 0);
            }, HTMLVideoAsset.prototype.getPlayer = function() {
                return this._player;
            }, HTMLVideoAsset.prototype.asSurface = function() {
                return this._surface;
            }, HTMLVideoAsset;
        }(g.VideoAsset);
        exports.HTMLVideoAsset = HTMLVideoAsset;
    }, {
        "./HTMLVideoPlayer": 9,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    9: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLVideoPlayer = function(_super) {
            function HTMLVideoPlayer(loop) {
                var _this = _super.call(this, loop) || this;
                return _this.isDummy = !0, _this;
            }
            return __extends(HTMLVideoPlayer, _super), HTMLVideoPlayer.prototype.play = function(videoAsset) {}, 
            HTMLVideoPlayer.prototype.stop = function() {}, HTMLVideoPlayer.prototype.changeVolume = function(volume) {}, 
            HTMLVideoPlayer;
        }(g.VideoPlayer);
        exports.HTMLVideoPlayer = HTMLVideoPlayer;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    10: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), XHRLoader_1 = require("../utils/XHRLoader"), XHRScriptAsset = function(_super) {
            function XHRScriptAsset(id, path) {
                var _this = _super.call(this, id, path) || this;
                return _this.script = void 0, _this;
            }
            return __extends(XHRScriptAsset, _super), XHRScriptAsset.prototype._load = function(handler) {
                var _this = this, loader = new XHRLoader_1.XHRLoader();
                loader.get(this.path, function(error, responseText) {
                    return error ? void handler._onAssetError(_this, error) : (_this.script = responseText + "\n", 
                    void handler._onAssetLoad(_this));
                });
            }, XHRScriptAsset.prototype.execute = function(execEnv) {
                var func = this._wrap();
                return func(execEnv), execEnv.module.exports;
            }, XHRScriptAsset.prototype._wrap = function() {
                var func = new Function("g", XHRScriptAsset.PRE_SCRIPT + this.script + XHRScriptAsset.POST_SCRIPT);
                return func;
            }, XHRScriptAsset;
        }(g.ScriptAsset);
        XHRScriptAsset.PRE_SCRIPT = "(function(exports, require, module, __filename, __dirname) {", 
        XHRScriptAsset.POST_SCRIPT = "})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);", 
        exports.XHRScriptAsset = XHRScriptAsset;
    }, {
        "../utils/XHRLoader": 43,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    11: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), XHRLoader_1 = require("../utils/XHRLoader"), XHRTextAsset = function(_super) {
            function XHRTextAsset(id, path) {
                var _this = _super.call(this, id, path) || this;
                return _this.data = void 0, _this;
            }
            return __extends(XHRTextAsset, _super), XHRTextAsset.prototype._load = function(handler) {
                var _this = this, loader = new XHRLoader_1.XHRLoader();
                loader.get(this.path, function(error, responseText) {
                    return error ? void handler._onAssetError(_this, error) : (_this.data = responseText, 
                    void handler._onAssetLoad(_this));
                });
            }, XHRTextAsset;
        }(g.TextAsset);
        exports.XHRTextAsset = XHRTextAsset;
    }, {
        "../utils/XHRLoader": 43,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    12: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var AffineTransformer = function() {
            function AffineTransformer(rhs) {
                rhs ? this.matrix = new Float32Array(rhs.matrix) : this.matrix = new Float32Array([ 1, 0, 0, 1, 0, 0 ]);
            }
            return AffineTransformer.prototype.scale = function(x, y) {
                var m = this.matrix;
                return m[0] *= x, m[1] *= x, m[2] *= y, m[3] *= y, this;
            }, AffineTransformer.prototype.translate = function(x, y) {
                var m = this.matrix;
                return m[4] += m[0] * x + m[2] * y, m[5] += m[1] * x + m[3] * y, this;
            }, AffineTransformer.prototype.transform = function(matrix) {
                var m = this.matrix, a = matrix[0] * m[0] + matrix[1] * m[2], b = matrix[0] * m[1] + matrix[1] * m[3], c = matrix[2] * m[0] + matrix[3] * m[2], d = matrix[2] * m[1] + matrix[3] * m[3], e = matrix[4] * m[0] + matrix[5] * m[2] + m[4], f = matrix[4] * m[1] + matrix[5] * m[3] + m[5];
                return m[0] = a, m[1] = b, m[2] = c, m[3] = d, m[4] = e, m[5] = f, this;
            }, AffineTransformer.prototype.copyFrom = function(rhs) {
                return this.matrix.set(rhs.matrix), this;
            }, AffineTransformer;
        }();
        exports.AffineTransformer = AffineTransformer;
    }, {} ],
    13: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), Context2DRenderer_1 = require("./Context2DRenderer"), CanvasSurface = function(_super) {
            function CanvasSurface(width, height, rendererCandidates) {
                var _this = this, canvas = document.createElement("canvas");
                return _this = _super.call(this, width, height, canvas) || this, canvas.width = width, 
                canvas.height = height, _this._originalWidth = width, _this._originalHeight = height, 
                _this.canvas = canvas, _this._rendererCandidates = rendererCandidates, _this._renderer = void 0, 
                _this._imageDataCache = void 0, _this;
            }
            return __extends(CanvasSurface, _super), CanvasSurface.prototype.context = function() {
                return this.canvas.getContext("2d");
            }, CanvasSurface.prototype.renderer = function() {
                return this._renderer || (this._renderer = new Context2DRenderer_1.Context2DRenderer(this)), 
                this._renderer;
            }, CanvasSurface.prototype.destroy = function() {
                this._drawable = void 0, this._imageDataCache = void 0, _super.prototype.destroy.call(this);
            }, CanvasSurface.prototype.setParentElement = function(parent) {
                parent.appendChild(this.canvas);
            }, CanvasSurface.prototype.changeCanvasSize = function(width, height) {
                var context = this.context();
                this.canvas.width = width, this.canvas.height = height, context.scale(width / this._originalWidth, height / this._originalHeight), 
                this.width = width, this.height = height;
            }, CanvasSurface.prototype.changeCanvasScale = function(xScale, yScale, defaultSize) {
                var canvasStyle = this.canvas.style;
                "transform" in canvasStyle ? (canvasStyle.transformOrigin = "0 0", canvasStyle.transform = "scale(" + xScale + "," + yScale + ")") : "webkitTransform" in canvasStyle ? (canvasStyle.webkitTransformOrigin = "0 0", 
                canvasStyle.webkitTransform = "scale(" + xScale + "," + yScale + ")") : (canvasStyle.width = Math.floor(defaultSize.width * xScale) + "px", 
                canvasStyle.height = Math.floor(defaultSize.height * yScale) + "px");
            }, CanvasSurface;
        }(g.Surface);
        exports.CanvasSurface = CanvasSurface;
    }, {
        "./Context2DRenderer": 14,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    14: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), RenderingHelper_1 = require("./RenderingHelper"), Context2DRenderer = function(_super) {
            function Context2DRenderer(surface) {
                var _this = _super.call(this) || this;
                return _this.surface = surface, _this.context = _this.surface.context(), _this;
            }
            return __extends(Context2DRenderer, _super), Context2DRenderer.prototype.clear = function() {
                this.context.clearRect(0, 0, this.surface.width, this.surface.height);
            }, Context2DRenderer.prototype.begin = function() {}, Context2DRenderer.prototype.end = function() {
                this.surface._drawable._texture = void 0;
            }, Context2DRenderer.prototype.drawImage = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY) {
                this.context.drawImage(surface._drawable, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, width, height);
            }, Context2DRenderer.prototype.drawSprites = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, count) {
                for (var i = 0; i < count; ++i) this.drawImage(surface, offsetX[i], offsetY[i], width[i], height[i], canvasOffsetX[i], canvasOffsetY[i]);
            }, Context2DRenderer.prototype.drawSystemText = function(text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly) {
                RenderingHelper_1.RenderingHelper.drawSystemTextByContext2D(this.context, text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly);
            }, Context2DRenderer.prototype.translate = function(x, y) {
                this.context.translate(x, y);
            }, Context2DRenderer.prototype.transform = function(matrix) {
                this.context.transform.apply(this.context, matrix);
            }, Context2DRenderer.prototype.opacity = function(opacity) {
                this.context.globalAlpha *= opacity;
            }, Context2DRenderer.prototype.save = function() {
                this.context.save();
            }, Context2DRenderer.prototype.restore = function() {
                this.context.restore();
            }, Context2DRenderer.prototype.fillRect = function(x, y, width, height, cssColor) {
                var _fillStyle = this.context.fillStyle;
                this.context.fillStyle = cssColor, this.context.fillRect(x, y, width, height), this.context.fillStyle = _fillStyle;
            }, Context2DRenderer.prototype.setCompositeOperation = function(operation) {
                this.context.globalCompositeOperation = RenderingHelper_1.RenderingHelper.toTextFromCompositeOperation(operation);
            }, Context2DRenderer;
        }(g.Renderer);
        exports.Context2DRenderer = Context2DRenderer;
    }, {
        "./RenderingHelper": 16,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        function createGlyphRenderedSurface(code, fontSize, cssFontFamily, baselineHeight, marginW, marginH, needImageData, cacheImageData, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
            var scale = fontSize < GlyphFactory._environmentMinimumFontSize ? fontSize / GlyphFactory._environmentMinimumFontSize : 1, surfaceWidth = Math.ceil((fontSize + 2 * marginW) * scale), surfaceHeight = Math.ceil((fontSize + 2 * marginH) * scale), surface = new CanvasSurface_1.CanvasSurface(surfaceWidth, surfaceHeight), canvas = surface.canvas, context = canvas.getContext("2d"), str = 4294901760 & code ? String.fromCharCode((4294901760 & code) >>> 16, 65535 & code) : String.fromCharCode(code), fontWeightValue = fontWeight === g.FontWeight.Bold ? "bold " : "";
            context.save(), context.font = fontWeightValue + fontSize + "px " + cssFontFamily, 
            context.textAlign = "left", context.textBaseline = "alphabetic", context.lineJoin = "bevel", 
            1 !== scale && context.scale(scale, scale), strokeWidth > 0 && (context.lineWidth = strokeWidth, 
            context.strokeStyle = strokeColor, context.strokeText(str, marginW, marginH + baselineHeight)), 
            strokeOnly || (context.fillStyle = fontColor, context.fillText(str, marginW, marginH + baselineHeight));
            var advanceWidth = context.measureText(str).width;
            context.restore();
            var result = {
                surface: surface,
                advanceWidth: advanceWidth,
                imageData: needImageData ? context.getImageData(0, 0, canvas.width, canvas.height) : void 0
            };
            return cacheImageData && (surface._imageDataCache = result.imageData), result;
        }
        function calcGlyphArea(imageData) {
            for (var sx = imageData.width, sy = imageData.height, ex = 0, ey = 0, currentPos = 0, y = 0, height = imageData.height; y < height; y = y + 1 | 0) for (var x = 0, width = imageData.width; x < width; x = x + 1 | 0) {
                var a = imageData.data[currentPos + 3];
                0 !== a && (x < sx && (sx = x), x > ex && (ex = x), y < sy && (sy = y), y > ey && (ey = y)), 
                currentPos += 4;
            }
            var glyphArea = void 0;
            return glyphArea = sx === imageData.width ? {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            } : {
                x: sx,
                y: sy,
                width: ex - sx + 1,
                height: ey - sy + 1
            };
        }
        function isGlyphAreaEmpty(glyphArea) {
            return 0 === glyphArea.width || 0 === glyphArea.height;
        }
        function fontFamily2FontFamilyName(fontFamily) {
            switch (fontFamily) {
              case g.FontFamily.Monospace:
                return "monospace";

              case g.FontFamily.Serif:
                return "serif";

              default:
                return "sans-serif";
            }
        }
        function quoteIfNotGeneric(name) {
            return genericFontFamilyNames.indexOf(name) !== -1 ? name : '"' + name + '"';
        }
        function fontFamily2CSSFontFamily(fontFamily) {
            return "number" == typeof fontFamily ? fontFamily2FontFamilyName(fontFamily) : "string" == typeof fontFamily ? quoteIfNotGeneric(fontFamily) : fontFamily.map(function(font) {
                return "string" == typeof font ? quoteIfNotGeneric(font) : fontFamily2FontFamilyName(font);
            }).join(",");
        }
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), CanvasSurface_1 = require("./CanvasSurface"), genericFontFamilyNames = [ "serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui" ], GlyphFactory = function(_super) {
            function GlyphFactory(fontFamily, fontSize, baselineHeight, cacheImageData, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) {
                var _this = _super.call(this, fontFamily, fontSize, baselineHeight, fontColor, strokeWidth, strokeColor, strokeOnly, fontWeight) || this;
                _this._cacheImageData = cacheImageData, _this._glyphAreas = {}, _this._cssFontFamily = fontFamily2CSSFontFamily(fontFamily);
                var fallbackFontFamilyName = fontFamily2FontFamilyName(g.FontFamily.SansSerif);
                return _this._cssFontFamily.indexOf(fallbackFontFamilyName) === -1 && (_this._cssFontFamily += "," + fallbackFontFamilyName), 
                _this._marginW = Math.ceil(.3 * _this.fontSize + _this.strokeWidth / 2), _this._marginH = Math.ceil(.3 * _this.fontSize + _this.strokeWidth / 2), 
                void 0 === GlyphFactory._environmentMinimumFontSize && (GlyphFactory._environmentMinimumFontSize = _this.measureMinimumFontSize()), 
                _this;
            }
            return __extends(GlyphFactory, _super), GlyphFactory.prototype.create = function(code) {
                var result, glyphArea = this._glyphAreas[code];
                return glyphArea || (result = createGlyphRenderedSurface(code, this.fontSize, this._cssFontFamily, this.baselineHeight, this._marginW, this._marginH, !0, this._cacheImageData, this.fontColor, this.strokeWidth, this.strokeColor, this.strokeOnly, this.fontWeight), 
                glyphArea = calcGlyphArea(result.imageData), glyphArea.advanceWidth = result.advanceWidth, 
                this._glyphAreas[code] = glyphArea), isGlyphAreaEmpty(glyphArea) ? (result && result.surface.destroy(), 
                new g.Glyph(code, 0, 0, 0, 0, 0, 0, glyphArea.advanceWidth, void 0, !0)) : (result || (result = createGlyphRenderedSurface(code, this.fontSize, this._cssFontFamily, this.baselineHeight, this._marginW, this._marginH, this._cacheImageData, this._cacheImageData, this.fontColor, this.strokeWidth, this.strokeColor, this.strokeOnly, this.fontWeight)), 
                new g.Glyph(code, glyphArea.x, glyphArea.y, glyphArea.width, glyphArea.height, glyphArea.x - this._marginW, glyphArea.y - this._marginH, glyphArea.advanceWidth, result.surface, !0));
            }, GlyphFactory.prototype.measureMinimumFontSize = function() {
                var fontSize = 1, str = "M", canvas = document.createElement("canvas"), context = canvas.getContext("2d");
                context.textAlign = "left", context.textBaseline = "alphabetic", context.lineJoin = "bevel";
                var preWidth;
                context.font = fontSize + "px sans-serif";
                var width = context.measureText(str).width;
                do preWidth = width, fontSize += 1, context.font = fontSize + "px sans-serif", width = context.measureText(str).width; while (preWidth === width || fontSize > 50);
                return fontSize;
            }, GlyphFactory;
        }(g.GlyphFactory);
        exports.GlyphFactory = GlyphFactory;
    }, {
        "./CanvasSurface": 13,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    16: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var RenderingHelper, g = require("@akashic/akashic-engine"), SurfaceFactory_1 = require("./shims/SurfaceFactory");
        !function(RenderingHelper) {
            function toPowerOfTwo(x) {
                if (0 !== (x & x - 1)) {
                    for (var y = 1; y < x; ) y *= 2;
                    return y;
                }
                return x;
            }
            function clamp(x) {
                return Math.min(Math.max(x, 0), 1);
            }
            function toTextFromCompositeOperation(operation) {
                var operationText;
                switch (operation) {
                  case g.CompositeOperation.SourceAtop:
                    operationText = "source-atop";
                    break;

                  case g.CompositeOperation.Lighter:
                    operationText = "lighter";
                    break;

                  case g.CompositeOperation.Copy:
                    operationText = "copy";
                    break;

                  default:
                    operationText = "source-over";
                }
                return operationText;
            }
            function toCompositeOperationFromText(operationText) {
                var operation;
                switch (operationText) {
                  case "source-atop":
                    operation = g.CompositeOperation.SourceAtop;
                    break;

                  case "lighter":
                    operation = g.CompositeOperation.Lighter;
                    break;

                  case "copy":
                    operation = g.CompositeOperation.Copy;
                    break;

                  default:
                    operation = g.CompositeOperation.SourceOver;
                }
                return operation;
            }
            function drawSystemTextByContext2D(context, text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly) {
                var fontFamilyValue, textAlignValue, textBaselineValue;
                switch (context.save(), fontFamily) {
                  case g.FontFamily.Monospace:
                    fontFamilyValue = "monospace";
                    break;

                  case g.FontFamily.Serif:
                    fontFamilyValue = "serif";
                    break;

                  default:
                    fontFamilyValue = "sans-serif";
                }
                switch (context.font = fontSize + "px " + fontFamilyValue, textAlign) {
                  case g.TextAlign.Right:
                    textAlignValue = "right";
                    break;

                  case g.TextAlign.Center:
                    textAlignValue = "center";
                    break;

                  default:
                    textAlignValue = "left";
                }
                switch (context.textAlign = textAlignValue, textBaseline) {
                  case g.TextBaseline.Top:
                    textBaselineValue = "top";
                    break;

                  case g.TextBaseline.Middle:
                    textBaselineValue = "middle";
                    break;

                  case g.TextBaseline.Bottom:
                    textBaselineValue = "bottom";
                    break;

                  default:
                    textBaselineValue = "alphabetic";
                }
                context.textBaseline = textBaselineValue, context.lineJoin = "bevel", strokeWidth > 0 && (context.lineWidth = strokeWidth, 
                context.strokeStyle = strokeColor, "undefined" == typeof maxWidth ? context.strokeText(text, x, y) : context.strokeText(text, x, y, maxWidth)), 
                strokeOnly || (context.fillStyle = textColor, "undefined" == typeof maxWidth ? context.fillText(text, x, y) : context.fillText(text, x, y, maxWidth)), 
                context.restore();
            }
            function usedWebGL(rendererCandidates) {
                var used = !1;
                return rendererCandidates && 0 < rendererCandidates.length && (used = "webgl" === rendererCandidates[0]), 
                used;
            }
            function transformCoordinateSystem(matrix, height) {
                matrix[1] *= -1, matrix[3] *= -1, matrix[5] = -matrix[5] + height;
            }
            function createPrimarySurface(width, height, rendererCandidates) {
                return SurfaceFactory_1.SurfaceFactory.createPrimarySurface(width, height, rendererCandidates);
            }
            function createBackSurface(width, height, platform, rendererCandidates) {
                return SurfaceFactory_1.SurfaceFactory.createBackSurface(width, height, platform, rendererCandidates);
            }
            RenderingHelper.toPowerOfTwo = toPowerOfTwo, RenderingHelper.clamp = clamp, RenderingHelper.toTextFromCompositeOperation = toTextFromCompositeOperation, 
            RenderingHelper.toCompositeOperationFromText = toCompositeOperationFromText, RenderingHelper.drawSystemTextByContext2D = drawSystemTextByContext2D, 
            RenderingHelper.usedWebGL = usedWebGL, RenderingHelper.transformCoordinateSystem = transformCoordinateSystem, 
            RenderingHelper.createPrimarySurface = createPrimarySurface, RenderingHelper.createBackSurface = createBackSurface;
        }(RenderingHelper = exports.RenderingHelper || (exports.RenderingHelper = {}));
    }, {
        "./shims/SurfaceFactory": 30,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    17: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var AffineTransformer_1 = require("./AffineTransformer"), RenderingState = function() {
            function RenderingState(rhs) {
                rhs ? (this.globalAlpha = rhs.globalAlpha, this.globalCompositeOperation = rhs.globalCompositeOperation, 
                this.transformer = new AffineTransformer_1.AffineTransformer(rhs.transformer)) : (this.globalAlpha = 1, 
                this.globalCompositeOperation = "source-over", this.transformer = new AffineTransformer_1.AffineTransformer());
            }
            return RenderingState.prototype.copyFrom = function(rhs) {
                return this.globalAlpha = rhs.globalAlpha, this.globalCompositeOperation = rhs.globalCompositeOperation, 
                this.transformer.copyFrom(rhs.transformer), this;
            }, RenderingState.prototype.updateFrom = function(rhs) {
                return this.globalAlpha *= rhs.globalAlpha, this.globalCompositeOperation = rhs.globalCompositeOperation, 
                this.transformer.transform(Array.prototype.slice.call(rhs.transformer.matrix)), 
                this;
            }, RenderingState;
        }();
        exports.RenderingState = RenderingState;
    }, {
        "./AffineTransformer": 12
    } ],
    18: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), RenderingHelper_1 = require("./RenderingHelper"), RenderingState_1 = require("./RenderingState"), StateHoldingRenderer = function(_super) {
            function StateHoldingRenderer(capacity) {
                var _this = _super.call(this) || this;
                return _this._stateStack = [], _this._stateStackPointer = 0, _this._capacity = 0, 
                _this._reallocation(0 < capacity ? capacity : StateHoldingRenderer.DEFAULT_CAPACITY), 
                _this;
            }
            return __extends(StateHoldingRenderer, _super), StateHoldingRenderer.prototype.save = function() {
                this._pushState();
            }, StateHoldingRenderer.prototype.restore = function() {
                this._popState();
            }, StateHoldingRenderer.prototype.translate = function(x, y) {
                this.currentState().transformer.translate(x, y);
            }, StateHoldingRenderer.prototype.transform = function(matrix) {
                this.currentState().transformer.transform(matrix);
            }, StateHoldingRenderer.prototype.opacity = function(opacity) {
                this.currentState().globalAlpha *= opacity;
            }, StateHoldingRenderer.prototype.setCompositeOperation = function(operation) {
                this.currentState().globalCompositeOperation = RenderingHelper_1.RenderingHelper.toTextFromCompositeOperation(operation);
            }, StateHoldingRenderer.prototype.currentState = function() {
                return this._stateStack[this._stateStackPointer];
            }, StateHoldingRenderer.prototype.capacity = function() {
                return this._capacity;
            }, StateHoldingRenderer.prototype._pushState = function() {
                var old = this.currentState();
                ++this._stateStackPointer, this._isOverCapacity && this._reallocation(this._stateStackPointer + 1), 
                this.currentState().copyFrom(old);
            }, StateHoldingRenderer.prototype._popState = function() {
                if (!(this._stateStackPointer > 0)) throw g.ExceptionFactory.createAssertionError("StateHoldingRenderer#restore: state stack under-flow.");
                --this._stateStackPointer;
            }, StateHoldingRenderer.prototype._isOverCapacity = function() {
                return this._capacity <= this._stateStackPointer;
            }, StateHoldingRenderer.prototype._reallocation = function(newCapacity) {
                var oldCapacity = this._capacity;
                if (oldCapacity < newCapacity) {
                    newCapacity < 2 * oldCapacity ? this._capacity *= 2 : this._capacity = newCapacity;
                    for (var i = oldCapacity; i < this._capacity; ++i) this._stateStack.push(new RenderingState_1.RenderingState());
                }
            }, StateHoldingRenderer;
        }(g.Renderer);
        StateHoldingRenderer.DEFAULT_CAPACITY = 16, exports.StateHoldingRenderer = StateHoldingRenderer;
    }, {
        "./RenderingHelper": 16,
        "./RenderingState": 17,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    19: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), SurfaceAtlas = function(_super) {
            function SurfaceAtlas() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(SurfaceAtlas, _super), SurfaceAtlas.prototype.addSurface = function(surface, rect) {
                var renderer = this._surface.renderer();
                if (surface._imageDataCache && renderer._subImage) {
                    var slot = this._acquireSurfaceAtlasSlot(rect.width, rect.height);
                    if (!slot) return null;
                    var webGLBackSurfaceRenderer = renderer, canvasSurface = surface;
                    return webGLBackSurfaceRenderer._subImage(canvasSurface._imageDataCache, rect.x, rect.y, rect.width, rect.height, slot.x, slot.y), 
                    slot;
                }
                return _super.prototype.addSurface.call(this, surface, rect);
            }, SurfaceAtlas;
        }(g.SurfaceAtlas);
        exports.SurfaceAtlas = SurfaceAtlas;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    20: [ function(require, module, exports) {
        "use strict";
        function getSystemTextOperations(surface) {
            return surface._systemTextOps;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getSystemTextOperations = getSystemTextOperations;
    }, {} ],
    21: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), WebGLBackSurfaceRenderer_1 = require("./WebGLBackSurfaceRenderer"), WebGLBackSurface = function(_super) {
            function WebGLBackSurface(width, height, webGLRenderer) {
                var _this = _super.call(this, width, height) || this;
                _this._systemTextOps = [], _this._webGLRenderer = webGLRenderer;
                var texWidth = Math.ceil(width), texHeight = Math.ceil(height), renderTarget = webGLRenderer.createTextureFrameBuffer(texWidth, texHeight);
                return _this._frameBuffer = renderTarget.frameBuffer, _this._drawable = {}, _this._drawable._texture = renderTarget.texture, 
                _this._drawable._textureOffsetX = 0, _this._drawable._textureOffsetY = 0, _this._drawable._textureWidth = texWidth, 
                _this._drawable._textureHeight = texHeight, _this;
            }
            return __extends(WebGLBackSurface, _super), WebGLBackSurface.prototype.renderer = function() {
                return this._renderer || (this._renderer = new WebGLBackSurfaceRenderer_1.WebGLBackSurfaceRenderer(this)), 
                this._renderer;
            }, WebGLBackSurface.prototype.destroy = function() {
                this._webGLRenderer.context.deleteFramebuffer(this._frameBuffer), this._frameBuffer = void 0, 
                this._webGLRenderer._disposeTexture(this._drawable._texture), this._webGLRenderer.context.deleteTexture(this._drawable._texture), 
                this._drawable._texture = void 0, _super.prototype.destroy.call(this);
            }, WebGLBackSurface;
        }(g.Surface);
        exports.WebGLBackSurface = WebGLBackSurface;
    }, {
        "./WebGLBackSurfaceRenderer": 22,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    22: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), RenderingHelper_1 = require("./RenderingHelper"), RenderingState_1 = require("./RenderingState"), SystemText_1 = require("./SystemText"), WebGLBackSurfaceRenderer = function(_super) {
            function WebGLBackSurfaceRenderer(surface) {
                var _this = _super.call(this) || this;
                return _this._surface = surface, _this._renderer = surface._webGLRenderer, _this;
            }
            return __extends(WebGLBackSurfaceRenderer, _super), WebGLBackSurfaceRenderer.prototype.translate = function(x, y) {
                this._renderer.translate(x, y);
            }, WebGLBackSurfaceRenderer.prototype.transform = function(matrix) {
                this._renderer.transform(matrix);
            }, WebGLBackSurfaceRenderer.prototype.opacity = function(opacity) {
                this._renderer.opacity(opacity);
            }, WebGLBackSurfaceRenderer.prototype.save = function() {
                this._renderer.save();
            }, WebGLBackSurfaceRenderer.prototype.restore = function() {
                this._renderer.restore();
            }, WebGLBackSurfaceRenderer.prototype.setCompositeOperation = function(operation) {
                this._renderer.setCompositeOperation(operation);
            }, WebGLBackSurfaceRenderer.prototype.setTransform = function(matrix) {
                this._renderer.setTransform(matrix);
            }, WebGLBackSurfaceRenderer.prototype.setOpacity = function(opacity) {
                this._renderer.setOpacity(opacity);
            }, WebGLBackSurfaceRenderer.prototype.clear = function() {
                this._renderer.clear(), this._surface._systemTextOps = [];
            }, WebGLBackSurfaceRenderer.prototype.begin = function() {
                _super.prototype.begin.call(this), this._renderer.begin(), this._renderer.pushRenderTarget(this._surface);
            }, WebGLBackSurfaceRenderer.prototype.end = function() {
                this._renderer.popRenderTarget(), this._renderer.end(), _super.prototype.end.call(this);
            }, WebGLBackSurfaceRenderer.prototype.drawSprites = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, count) {
                this._renderer.drawSprites(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, count);
            }, WebGLBackSurfaceRenderer.prototype.drawSystemText = function(text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly) {
                var op = {
                    state: new RenderingState_1.RenderingState(this._renderer.currentState()),
                    parameter: arguments
                };
                RenderingHelper_1.RenderingHelper.transformCoordinateSystem(op.state.transformer.matrix, this._surface.height), 
                this._surface._systemTextOps.push(op);
            }, WebGLBackSurfaceRenderer.prototype.drawImage = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY) {
                this._renderer._drawImageExcludingSystemText(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY);
                var srcOps = SystemText_1.getSystemTextOperations(surface);
                if (srcOps) for (var i = 0; i < srcOps.length; i = i + 1 | 0) {
                    var op = {
                        state: new RenderingState_1.RenderingState(this._renderer.currentState()).updateFrom(srcOps[i].state),
                        parameter: srcOps[i].parameter
                    };
                    RenderingHelper_1.RenderingHelper.transformCoordinateSystem(op.state.transformer.matrix, this._surface.height), 
                    this._surface._systemTextOps.push(op);
                }
            }, WebGLBackSurfaceRenderer.prototype.fillRect = function(x, y, width, height, cssColor) {
                this._renderer.fillRect(x, y, width, height, cssColor);
            }, WebGLBackSurfaceRenderer.prototype._subImage = function(imageData, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY) {
                for (var src = imageData.data, dst = new Uint8Array(width * height * 4), j = 0, d = 0; j < height; j++) for (var s = 4 * (imageData.width * (offsetY + j) + offsetX), i = 0, len = 4 * width; i < len; i++) dst[d++] = src[s++];
                var gl = this._renderer.context;
                gl.bindTexture(gl.TEXTURE_2D, this._surface._drawable._texture), gl.texSubImage2D(gl.TEXTURE_2D, 0, canvasOffsetX, canvasOffsetY, width, height, gl.RGBA, gl.UNSIGNED_BYTE, dst), 
                this._renderer.context.bindTexture(this._renderer.context.TEXTURE_2D, this._renderer._currentTexture);
            }, WebGLBackSurfaceRenderer;
        }(g.Renderer);
        exports.WebGLBackSurfaceRenderer = WebGLBackSurfaceRenderer;
    }, {
        "./RenderingHelper": 16,
        "./RenderingState": 17,
        "./SystemText": 20,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    23: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var WebGLColor, RenderingHelper_1 = require("./RenderingHelper");
        !function(WebGLColor) {
            function get(color) {
                var rgba = "string" == typeof color ? WebGLColor._toColor(color) : [ color[0], color[1], color[2], color[3] ];
                return rgba[3] = RenderingHelper_1.RenderingHelper.clamp(rgba[3]), rgba[0] = RenderingHelper_1.RenderingHelper.clamp(rgba[0]) * rgba[3], 
                rgba[1] = RenderingHelper_1.RenderingHelper.clamp(rgba[1]) * rgba[3], rgba[2] = RenderingHelper_1.RenderingHelper.clamp(rgba[2]) * rgba[3], 
                rgba;
            }
            function _hsl2rgb(hsl) {
                var h = hsl[0] % 360, s = hsl[1], l = hsl[2] > 50 ? 100 - hsl[2] : hsl[2], a = hsl[3], max = l + l * s, min = l - l * s;
                return h < 60 ? [ max, h / 60 * (max - min) + min, min, a ] : h < 120 ? [ (120 - h) / 60 * (max - min) + min, max, min, a ] : h < 180 ? [ min, max, (h - 120) / 60 * (max - min) + min, a ] : h < 240 ? [ min, (240 - h) / 60 * (max - min) + min, max, a ] : h < 300 ? [ (h - 240) / 60 * (max - min) + min, min, max, a ] : [ max, min, (360 - h) / 60 * (max - min) + min, a ];
            }
            function _toColor(cssColor) {
                var ncc = cssColor.toUpperCase().replace(/\s+/g, ""), rgba = WebGLColor.colorMap[ncc];
                if (rgba) return rgba;
                if (ncc.match(/^#([\dA-F])([\dA-F])([\dA-F])$/)) return [ parseInt(RegExp.$1, 16) / 15, parseInt(RegExp.$2, 16) / 15, parseInt(RegExp.$3, 16) / 15, 1 ];
                if (ncc.match(/^#([\dA-F]{2})([\dA-F]{2})([\dA-F]{2})$/)) return [ parseInt(RegExp.$1, 16) / 255, parseInt(RegExp.$2, 16) / 255, parseInt(RegExp.$3, 16) / 255, 1 ];
                if (ncc.match(/^RGB\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/)) return [ parseInt(RegExp.$1, 10) / 255, parseInt(RegExp.$2, 10) / 255, parseInt(RegExp.$3, 10) / 255, 1 ];
                if (ncc.match(/^RGBA\((\d{1,3}),(\d{1,3}),(\d{1,3}),(\d(\.\d*)?)\)$/)) return [ parseInt(RegExp.$1, 10) / 255, parseInt(RegExp.$2, 10) / 255, parseInt(RegExp.$3, 10) / 255, parseFloat(RegExp.$4) ];
                if (ncc.match(/^HSL\((\d{1,3}),(\d{1,3})%,(\d{1,3})%\)$/)) return WebGLColor._hsl2rgb([ parseInt(RegExp.$1, 10), RenderingHelper_1.RenderingHelper.clamp(parseInt(RegExp.$2, 10) / 100), RenderingHelper_1.RenderingHelper.clamp(parseInt(RegExp.$3, 10) / 100), 1 ]);
                if (ncc.match(/^HSLA\((\d{1,3}),(\d{1,3})%,(\d{1,3})%,(\d(\.\d*)?)\)$/)) return WebGLColor._hsl2rgb([ parseInt(RegExp.$1, 10), RenderingHelper_1.RenderingHelper.clamp(parseInt(RegExp.$2, 10) / 100), RenderingHelper_1.RenderingHelper.clamp(parseInt(RegExp.$3, 10) / 100), parseFloat(RegExp.$4) ]);
                throw Error("illigal cssColor format: " + ncc);
            }
            WebGLColor.colorMap = {
                ALICEBLUE: [ 240 / 255, 248 / 255, 1, 1 ],
                ANTIQUEWHITE: [ 250 / 255, 235 / 255, 215 / 255, 1 ],
                AQUA: [ 0, 1, 1, 1 ],
                AQUAMARINE: [ 127 / 255, 1, 212 / 255, 1 ],
                AZURE: [ 240 / 255, 1, 1, 1 ],
                BEIGE: [ 245 / 255, 245 / 255, 220 / 255, 1 ],
                BISQUE: [ 1, 228 / 255, 196 / 255, 1 ],
                BLACK: [ 0, 0, 0, 1 ],
                BLANCHEDALMOND: [ 1, 235 / 255, 205 / 255, 1 ],
                BLUE: [ 0, 0, 1, 1 ],
                BLUEVIOLET: [ 138 / 255, 43 / 255, 226 / 255, 1 ],
                BROWN: [ 165 / 255, 42 / 255, 42 / 255, 1 ],
                BURLYWOOD: [ 222 / 255, 184 / 255, 135 / 255, 1 ],
                CADETBLUE: [ 95 / 255, 158 / 255, 160 / 255, 1 ],
                CHARTREUSE: [ 127 / 255, 1, 0, 1 ],
                CHOCOLATE: [ 210 / 255, 105 / 255, 30 / 255, 1 ],
                CORAL: [ 1, 127 / 255, 80 / 255, 1 ],
                CORNFLOWERBLUE: [ 100 / 255, 149 / 255, 237 / 255, 1 ],
                CORNSILK: [ 1, 248 / 255, 220 / 255, 1 ],
                CRIMSON: [ 220 / 255, 20 / 255, 60 / 255, 1 ],
                CYAN: [ 0, 1, 1, 1 ],
                DARKBLUE: [ 0, 0, 139 / 255, 1 ],
                DARKCYAN: [ 0, 139 / 255, 139 / 255, 1 ],
                DARKGOLDENROD: [ 184 / 255, 134 / 255, 11 / 255, 1 ],
                DARKGRAY: [ 169 / 255, 169 / 255, 169 / 255, 1 ],
                DARKGREEN: [ 0, 100 / 255, 0, 1 ],
                DARKGREY: [ 169 / 255, 169 / 255, 169 / 255, 1 ],
                DARKKHAKI: [ 189 / 255, 183 / 255, 107 / 255, 1 ],
                DARKMAGENTA: [ 139 / 255, 0, 139 / 255, 1 ],
                DARKOLIVEGREEN: [ 85 / 255, 107 / 255, 47 / 255, 1 ],
                DARKORANGE: [ 1, 140 / 255, 0, 1 ],
                DARKORCHID: [ .6, 50 / 255, .8, 1 ],
                DARKRED: [ 139 / 255, 0, 0, 1 ],
                DARKSALMON: [ 233 / 255, 150 / 255, 122 / 255, 1 ],
                DARKSEAGREEN: [ 143 / 255, 188 / 255, 143 / 255, 1 ],
                DARKSLATEBLUE: [ 72 / 255, 61 / 255, 139 / 255, 1 ],
                DARKSLATEGRAY: [ 47 / 255, 79 / 255, 79 / 255, 1 ],
                DARKSLATEGREY: [ 47 / 255, 79 / 255, 79 / 255, 1 ],
                DARKTURQUOISE: [ 0, 206 / 255, 209 / 255, 1 ],
                DARKVIOLET: [ 148 / 255, 0, 211 / 255, 1 ],
                DEEPPINK: [ 1, 20 / 255, 147 / 255, 1 ],
                DEEPSKYBLUE: [ 0, 191 / 255, 1, 1 ],
                DIMGRAY: [ 105 / 255, 105 / 255, 105 / 255, 1 ],
                DIMGREY: [ 105 / 255, 105 / 255, 105 / 255, 1 ],
                DODGERBLUE: [ 30 / 255, 144 / 255, 1, 1 ],
                FIREBRICK: [ 178 / 255, 34 / 255, 34 / 255, 1 ],
                FLORALWHITE: [ 1, 250 / 255, 240 / 255, 1 ],
                FORESTGREEN: [ 34 / 255, 139 / 255, 34 / 255, 1 ],
                FUCHSIA: [ 1, 0, 1, 1 ],
                GAINSBORO: [ 220 / 255, 220 / 255, 220 / 255, 1 ],
                GHOSTWHITE: [ 248 / 255, 248 / 255, 1, 1 ],
                GOLD: [ 1, 215 / 255, 0, 1 ],
                GOLDENROD: [ 218 / 255, 165 / 255, 32 / 255, 1 ],
                GRAY: [ 128 / 255, 128 / 255, 128 / 255, 1 ],
                GREEN: [ 0, 128 / 255, 0, 1 ],
                GREENYELLOW: [ 173 / 255, 1, 47 / 255, 1 ],
                GREY: [ 128 / 255, 128 / 255, 128 / 255, 1 ],
                HONEYDEW: [ 240 / 255, 1, 240 / 255, 1 ],
                HOTPINK: [ 1, 105 / 255, 180 / 255, 1 ],
                INDIANRED: [ 205 / 255, 92 / 255, 92 / 255, 1 ],
                INDIGO: [ 75 / 255, 0, 130 / 255, 1 ],
                IVORY: [ 1, 1, 240 / 255, 1 ],
                KHAKI: [ 240 / 255, 230 / 255, 140 / 255, 1 ],
                LAVENDER: [ 230 / 255, 230 / 255, 250 / 255, 1 ],
                LAVENDERBLUSH: [ 1, 240 / 255, 245 / 255, 1 ],
                LAWNGREEN: [ 124 / 255, 252 / 255, 0, 1 ],
                LEMONCHIFFON: [ 1, 250 / 255, 205 / 255, 1 ],
                LIGHTBLUE: [ 173 / 255, 216 / 255, 230 / 255, 1 ],
                LIGHTCORAL: [ 240 / 255, 128 / 255, 128 / 255, 1 ],
                LIGHTCYAN: [ 224 / 255, 1, 1, 1 ],
                LIGHTGOLDENRODYELLOW: [ 250 / 255, 250 / 255, 210 / 255, 1 ],
                LIGHTGRAY: [ 211 / 255, 211 / 255, 211 / 255, 1 ],
                LIGHTGREEN: [ 144 / 255, 238 / 255, 144 / 255, 1 ],
                LIGHTGREY: [ 211 / 255, 211 / 255, 211 / 255, 1 ],
                LIGHTPINK: [ 1, 182 / 255, 193 / 255, 1 ],
                LIGHTSALMON: [ 1, 160 / 255, 122 / 255, 1 ],
                LIGHTSEAGREEN: [ 32 / 255, 178 / 255, 170 / 255, 1 ],
                LIGHTSKYBLUE: [ 135 / 255, 206 / 255, 250 / 255, 1 ],
                LIGHTSLATEGRAY: [ 119 / 255, 136 / 255, .6, 1 ],
                LIGHTSLATEGREY: [ 119 / 255, 136 / 255, .6, 1 ],
                LIGHTSTEELBLUE: [ 176 / 255, 196 / 255, 222 / 255, 1 ],
                LIGHTYELLOW: [ 1, 1, 224 / 255, 1 ],
                LIME: [ 0, 1, 0, 1 ],
                LIMEGREEN: [ 50 / 255, 205 / 255, 50 / 255, 1 ],
                LINEN: [ 250 / 255, 240 / 255, 230 / 255, 1 ],
                MAGENTA: [ 1, 0, 1, 1 ],
                MAROON: [ 128 / 255, 0, 0, 1 ],
                MEDIUMAQUAMARINE: [ .4, 205 / 255, 170 / 255, 1 ],
                MEDIUMBLUE: [ 0, 0, 205 / 255, 1 ],
                MEDIUMORCHID: [ 186 / 255, 85 / 255, 211 / 255, 1 ],
                MEDIUMPURPLE: [ 147 / 255, 112 / 255, 219 / 255, 1 ],
                MEDIUMSEAGREEN: [ 60 / 255, 179 / 255, 113 / 255, 1 ],
                MEDIUMSLATEBLUE: [ 123 / 255, 104 / 255, 238 / 255, 1 ],
                MEDIUMSPRINGGREEN: [ 0, 250 / 255, 154 / 255, 1 ],
                MEDIUMTURQUOISE: [ 72 / 255, 209 / 255, .8, 1 ],
                MEDIUMVIOLETRED: [ 199 / 255, 21 / 255, 133 / 255, 1 ],
                MIDNIGHTBLUE: [ 25 / 255, 25 / 255, 112 / 255, 1 ],
                MINTCREAM: [ 245 / 255, 1, 250 / 255, 1 ],
                MISTYROSE: [ 1, 228 / 255, 225 / 255, 1 ],
                MOCCASIN: [ 1, 228 / 255, 181 / 255, 1 ],
                NAVAJOWHITE: [ 1, 222 / 255, 173 / 255, 1 ],
                NAVY: [ 0, 0, 128 / 255, 1 ],
                OLDLACE: [ 253 / 255, 245 / 255, 230 / 255, 1 ],
                OLIVE: [ 128 / 255, 128 / 255, 0, 1 ],
                OLIVEDRAB: [ 107 / 255, 142 / 255, 35 / 255, 1 ],
                ORANGE: [ 1, 165 / 255, 0, 1 ],
                ORANGERED: [ 1, 69 / 255, 0, 1 ],
                ORCHID: [ 218 / 255, 112 / 255, 214 / 255, 1 ],
                PALEGOLDENROD: [ 238 / 255, 232 / 255, 170 / 255, 1 ],
                PALEGREEN: [ 152 / 255, 251 / 255, 152 / 255, 1 ],
                PALETURQUOISE: [ 175 / 255, 238 / 255, 238 / 255, 1 ],
                PALEVIOLETRED: [ 219 / 255, 112 / 255, 147 / 255, 1 ],
                PAPAYAWHIP: [ 1, 239 / 255, 213 / 255, 1 ],
                PEACHPUFF: [ 1, 218 / 255, 185 / 255, 1 ],
                PERU: [ 205 / 255, 133 / 255, 63 / 255, 1 ],
                PINK: [ 1, 192 / 255, 203 / 255, 1 ],
                PLUM: [ 221 / 255, 160 / 255, 221 / 255, 1 ],
                POWDERBLUE: [ 176 / 255, 224 / 255, 230 / 255, 1 ],
                PURPLE: [ 128 / 255, 0, 128 / 255, 1 ],
                RED: [ 1, 0, 0, 1 ],
                ROSYBROWN: [ 188 / 255, 143 / 255, 143 / 255, 1 ],
                ROYALBLUE: [ 65 / 255, 105 / 255, 225 / 255, 1 ],
                SADDLEBROWN: [ 139 / 255, 69 / 255, 19 / 255, 1 ],
                SALMON: [ 250 / 255, 128 / 255, 114 / 255, 1 ],
                SANDYBROWN: [ 244 / 255, 164 / 255, 96 / 255, 1 ],
                SEAGREEN: [ 46 / 255, 139 / 255, 87 / 255, 1 ],
                SEASHELL: [ 1, 245 / 255, 238 / 255, 1 ],
                SIENNA: [ 160 / 255, 82 / 255, 45 / 255, 1 ],
                SILVER: [ 192 / 255, 192 / 255, 192 / 255, 1 ],
                SKYBLUE: [ 135 / 255, 206 / 255, 235 / 255, 1 ],
                SLATEBLUE: [ 106 / 255, 90 / 255, 205 / 255, 1 ],
                SLATEGRAY: [ 112 / 255, 128 / 255, 144 / 255, 1 ],
                SLATEGREY: [ 112 / 255, 128 / 255, 144 / 255, 1 ],
                SNOW: [ 1, 250 / 255, 250 / 255, 1 ],
                SPRINGGREEN: [ 0, 1, 127 / 255, 1 ],
                STEELBLUE: [ 70 / 255, 130 / 255, 180 / 255, 1 ],
                TAN: [ 210 / 255, 180 / 255, 140 / 255, 1 ],
                TEAL: [ 0, 128 / 255, 128 / 255, 1 ],
                THISTLE: [ 216 / 255, 191 / 255, 216 / 255, 1 ],
                TOMATO: [ 1, 99 / 255, 71 / 255, 1 ],
                TURQUOISE: [ 64 / 255, 224 / 255, 208 / 255, 1 ],
                VIOLET: [ 238 / 255, 130 / 255, 238 / 255, 1 ],
                WHEAT: [ 245 / 255, 222 / 255, 179 / 255, 1 ],
                WHITE: [ 1, 1, 1, 1 ],
                WHITESMOKE: [ 245 / 255, 245 / 255, 245 / 255, 1 ],
                YELLOW: [ 1, 1, 0, 1 ],
                YELLOWGREEN: [ 154 / 255, 205 / 255, 50 / 255, 1 ]
            }, WebGLColor.get = get, WebGLColor._hsl2rgb = _hsl2rgb, WebGLColor._toColor = _toColor;
        }(WebGLColor = exports.WebGLColor || (exports.WebGLColor = {}));
    }, {
        "./RenderingHelper": 16
    } ],
    24: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var CanvasSurface_1 = require("./CanvasSurface"), WebGLPrimarySurfaceRenderer_1 = require("./WebGLPrimarySurfaceRenderer"), WebGLPrimarySurface = function(_super) {
            function WebGLPrimarySurface(width, height, zIndexes) {
                var _this = _super.call(this, width, height, [ "webgl" ]) || this;
                return _this._upperSurface = new CanvasSurface_1.CanvasSurface(width, height), _this.setCanvasStyle(zIndexes), 
                _this;
            }
            return __extends(WebGLPrimarySurface, _super), WebGLPrimarySurface.prototype.renderer = function() {
                return this._renderer || (this._renderer = new WebGLPrimarySurfaceRenderer_1.WebGLPrimarySurfaceRenderer(this)), 
                this._renderer;
            }, WebGLPrimarySurface.prototype.setParentElement = function(parent) {
                _super.prototype.setParentElement.call(this, parent), parent.appendChild(this._upperSurface.canvas);
            }, WebGLPrimarySurface.prototype.changeCanvasSize = function(width, height) {
                var xScale = width / this.width, yScale = height / this.height, defaultSize = {
                    width: this.width,
                    height: this.height
                };
                _super.prototype.changeCanvasScale.call(this, xScale, yScale, defaultSize), this._upperSurface.changeCanvasScale(xScale, yScale, defaultSize);
            }, WebGLPrimarySurface.prototype.setCanvasStyle = function(zIndexes) {
                this._upperSurface.canvas.style.position = "absolute", this.canvas.style.position = "absolute", 
                zIndexes ? (this.canvas.style.zIndex = zIndexes.base || "0", this._upperSurface.canvas.style.zIndex = zIndexes.upper || "1") : (this.canvas.style.zIndex = "0", 
                this._upperSurface.canvas.style.zIndex = "1");
            }, WebGLPrimarySurface;
        }(CanvasSurface_1.CanvasSurface);
        exports.WebGLPrimarySurface = WebGLPrimarySurface;
    }, {
        "./CanvasSurface": 13,
        "./WebGLPrimarySurfaceRenderer": 25
    } ],
    25: [ function(require, module, exports) {
        "use strict";
        function applyRenderingState(renderer, state) {
            renderer.transform(Array.prototype.slice.call(state.transformer.matrix)), renderer.opacity(state.globalAlpha), 
            renderer.setCompositeOperation(RenderingHelper_1.RenderingHelper.toCompositeOperationFromText(state.globalCompositeOperation));
        }
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var WebGLRenderer_1 = require("./WebGLRenderer"), RenderingHelper_1 = require("./RenderingHelper"), SystemText_1 = require("./SystemText"), WebGLPrimarySurfaceRenderer = function(_super) {
            function WebGLPrimarySurfaceRenderer(surface) {
                var _this = _super.call(this, surface) || this;
                return _this._upperRenderer = surface._upperSurface.renderer(), _this;
            }
            return __extends(WebGLPrimarySurfaceRenderer, _super), WebGLPrimarySurfaceRenderer.prototype.clear = function() {
                _super.prototype.clear.call(this), this._upperRenderer.clear();
            }, WebGLPrimarySurfaceRenderer.prototype._drawImageExcludingSystemText = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY) {
                _super.prototype.drawImage.call(this, surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY);
            }, WebGLPrimarySurfaceRenderer.prototype.drawImage = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY) {
                _super.prototype.drawImage.call(this, surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY);
                var srcOps = SystemText_1.getSystemTextOperations(surface);
                if (srcOps) for (var i = 0; i < srcOps.length; i = i + 1 | 0) {
                    this._upperRenderer.save(), applyRenderingState(this._upperRenderer, this.currentState()), 
                    applyRenderingState(this._upperRenderer, srcOps[i].state);
                    var parameter = srcOps[i].parameter;
                    this._upperRenderer.drawSystemText.apply(this._upperRenderer, parameter), this._upperRenderer.restore();
                }
            }, WebGLPrimarySurfaceRenderer.prototype.drawSystemText = function(text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly) {
                this._upperRenderer.save(), applyRenderingState(this._upperRenderer, this.currentState()), 
                this._upperRenderer.drawSystemText(text, x, y, maxWidth, fontSize, textAlign, textBaseline, textColor, fontFamily, strokeWidth, strokeColor, strokeOnly), 
                this._upperRenderer.restore();
            }, WebGLPrimarySurfaceRenderer;
        }(WebGLRenderer_1.WebGLRenderer);
        exports.WebGLPrimarySurfaceRenderer = WebGLPrimarySurfaceRenderer;
    }, {
        "./RenderingHelper": 16,
        "./SystemText": 20,
        "./WebGLRenderer": 26
    } ],
    26: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), StateHoldingRenderer_1 = require("./StateHoldingRenderer"), RenderingHelper_1 = require("./RenderingHelper"), WebGLColor_1 = require("./WebGLColor"), WebGLShaderProgram_1 = require("./WebGLShaderProgram"), WebGLTextureAtlas_1 = require("./WebGLTextureAtlas"), RenderingState_1 = require("./RenderingState"), RenderTargetStack = function(_super) {
            function RenderTargetStack(width, height) {
                var _this = _super.call(this) || this;
                return _this.push({
                    width: width,
                    height: height,
                    _frameBuffer: null
                }), _this;
            }
            return __extends(RenderTargetStack, _super), RenderTargetStack.prototype.top = function() {
                return this[this.length - 1];
            }, RenderTargetStack;
        }(Array), WebGLRenderer = function(_super) {
            function WebGLRenderer(surface) {
                var _this = _super.call(this) || this;
                if (_this.surface = surface, _this.context = surface.canvas.getContext("webgl", {
                    depth: !1,
                    preserveDrawingBuffer: !0
                }), !_this.context) throw g.ExceptionFactory.createAssertionError("WebGLRenderer#constructor: could not initialize WebGLRenderingContext");
                return _this._init(), _this;
            }
            return __extends(WebGLRenderer, _super), WebGLRenderer.prototype.pushRenderTarget = function(surface) {
                this._commit(), this._renderTargetStack.push(surface), this.save();
                var rs = new RenderingState_1.RenderingState();
                RenderingHelper_1.RenderingHelper.transformCoordinateSystem(rs.transformer.matrix, surface.height), 
                this.currentState().copyFrom(rs), this.context.viewport(0, 0, surface.width, surface.height), 
                this._width = surface.width, this._height = surface.height, this.context.bindFramebuffer(this.context.FRAMEBUFFER, surface._frameBuffer);
            }, WebGLRenderer.prototype.popRenderTarget = function() {
                this._commit(), this._renderTargetStack.pop();
                var renderTarget = this._renderTargetStack.top();
                this.context.bindFramebuffer(this.context.FRAMEBUFFER, renderTarget._frameBuffer), 
                this._width = renderTarget.width, this._height = renderTarget.height, this.context.viewport(0, 0, this._width, this._height), 
                this.restore();
            }, WebGLRenderer.prototype.clear = function() {
                this.context.clear(this.context.COLOR_BUFFER_BIT);
            }, WebGLRenderer.prototype.begin = function() {
                ++this._beginCount, 1 === this._beginCount && (this._commitCount = 0, this.clear(), 
                this._program.use(), this._enableLighting ? (this._program.set_uLightType(this._lightTypes), 
                this._program.set_uLightColor(this._lightColors)) : (this._program.set_uLightType(this._lightTypesDisabled), 
                this._program.set_uLightColor(this._lightColorsDisabled)), this._program.set_uLightDirection(this._lightDirections), 
                this._program.set_uLightPosition(this._lightPositions), this._program.set_uLightDistanceAttenuation(this._lightDistanceAttenuation), 
                this._program.set_uLightAngleAttenuation(this._lightAngleAttenuation), this._inRendering = !0);
            }, WebGLRenderer.prototype.end = function() {
                --this._beginCount, 0 === this._beginCount && (this._inRendering = !1, this._commit(), 
                this._program.unuse());
            }, WebGLRenderer.prototype.setLighting = function(enable) {
                this._enableLighting = enable, this._inRendering && (this._commit(), enable ? (this._program.set_uLightType(this._lightTypes), 
                this._program.set_uLightColor(this._lightColors)) : (this._program.set_uLightType(this._lightTypesDisabled), 
                this._program.set_uLightColor(this._lightColorsDisabled)));
            }, WebGLRenderer.prototype.setNullLight = function(lightId) {
                lightId < 0 || lightId >= this._program.maxLightCount || (this._lightTypes[lightId] = 0);
            }, WebGLRenderer.prototype.setAmbientLight = function(lightId, lightColor) {
                lightId < 0 || lightId >= this._program.maxLightCount || (this._lightTypes[lightId] = 1, 
                this._setLightColor(lightId, lightColor));
            }, WebGLRenderer.prototype.setDirectionalLight = function(lightId, lightColor, lightDirection) {
                lightId < 0 || lightId >= this._program.maxLightCount || (this._lightTypes[lightId] = 2, 
                this._setLightColor(lightId, lightColor), this._setLightDirection(lightId, lightDirection));
            }, WebGLRenderer.prototype.setPointLight = function(lightId, lightColor, lightPosition, att0, att1, att2) {
                lightId < 0 || lightId >= this._program.maxLightCount || (this._lightTypes[lightId] = 3, 
                this._setLightColor(lightId, lightColor), this._setLightPosition(lightId, lightPosition), 
                this._setLightDistanceAttenuation(lightId, att0, att1, att2));
            }, WebGLRenderer.prototype.setSpotLight = function(lightId, lightColor, lightPosition, lightDirection, att0, att1, att2, theta, phi, falloff) {
                lightId < 0 || lightId >= this._program.maxLightCount || (this._lightTypes[lightId] = 4, 
                this._setLightColor(lightId, lightColor), this._setLightPosition(lightId, lightPosition), 
                this._setLightDirection(lightId, lightDirection), this._setLightDistanceAttenuation(lightId, att0, att1, att2), 
                this._setLightAngleAttenuation(lightId, theta, phi, falloff));
            }, WebGLRenderer.prototype.drawSprites = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, count) {
                for (var i = 0; i < count; ++i) this.drawImage(surface, offsetX[i], offsetY[i], width[i], height[i], canvasOffsetX[i], canvasOffsetY[i]);
            }, WebGLRenderer.prototype.drawImage = function(surface, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY) {
                if (!surface._drawable) throw g.ExceptionFactory.createAssertionError("WebGLRenderer#drawImage: no drawable surface.");
                if (surface._drawable._texture instanceof WebGLTexture || this._textureAtlas._makeTextureForSurface(this, surface), 
                !surface._drawable._texture) throw g.ExceptionFactory.createAssertionError("WebGLRenderer#drawImage: could not create a texture.");
                var image = surface._drawable, tw = 1 / image._textureWidth, th = 1 / image._textureHeight, ox = image._textureOffsetX, oy = image._textureOffsetY, s = tw * (ox + offsetX + width), t = th * (oy + offsetY + height), u = tw * (ox + offsetX), v = th * (oy + offsetY);
                this._drawImage(image._texture, canvasOffsetX, canvasOffsetY, width, height, [ u, v, s, v, s, t, u, v, s, t, u, t ], this._drawImageColor);
            }, WebGLRenderer.prototype.fillRect = function(x, y, width, height, cssColor) {
                this._drawImage(this._fillRectTexture, x, y, width, height, [ 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1 ], WebGLColor_1.WebGLColor.get(cssColor));
            }, WebGLRenderer.prototype.createTextureFrameBuffer = function(width, height) {
                var context = this.context, frameBuffer = context.createFramebuffer();
                context.bindFramebuffer(context.FRAMEBUFFER, frameBuffer);
                var texture = context.createTexture();
                context.bindTexture(context.TEXTURE_2D, texture), context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.LINEAR), 
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR), 
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE), 
                context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE), 
                context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, width, height, 0, context.RGBA, context.UNSIGNED_BYTE, null), 
                context.framebufferTexture2D(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0, context.TEXTURE_2D, texture, 0), 
                context.bindTexture(context.TEXTURE_2D, this._currentTexture);
                var renderTarget = this._renderTargetStack.top();
                return context.bindFramebuffer(context.FRAMEBUFFER, renderTarget._frameBuffer), 
                {
                    frameBuffer: frameBuffer,
                    texture: texture
                };
            }, WebGLRenderer.prototype._makeTextureForSurface = function(surface) {
                var image = surface._drawable, w = RenderingHelper_1.RenderingHelper.toPowerOfTwo(image.width), h = RenderingHelper_1.RenderingHelper.toPowerOfTwo(image.height);
                if (w !== image.width || h !== image.height) {
                    var canvas = document.createElement("canvas");
                    canvas.width = w, canvas.height = h;
                    var context = canvas.getContext("2d");
                    context.globalCompositeOperation = "copy", context.drawImage(image, 0, 0), image = context.getImageData(0, 0, w, h);
                }
                surface._drawable._texture = this._makeTexture(image), surface._drawable._textureOffsetX = 0, 
                surface._drawable._textureOffsetY = 0, surface._drawable._textureWidth = w, surface._drawable._textureHeight = h;
            }, WebGLRenderer.prototype._makeTextureRaw = function(width, height, pixels) {
                void 0 === pixels && (pixels = null);
                var texture = this.context.createTexture();
                return this.context.bindTexture(this.context.TEXTURE_2D, texture), this.context.pixelStorei(this.context.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), 
                this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_WRAP_S, this.context.CLAMP_TO_EDGE), 
                this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_WRAP_T, this.context.CLAMP_TO_EDGE), 
                this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MAG_FILTER, this.context.NEAREST), 
                this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MIN_FILTER, this.context.NEAREST), 
                this.context.texImage2D(this.context.TEXTURE_2D, 0, this.context.RGBA, width, height, 0, this.context.RGBA, this.context.UNSIGNED_BYTE, pixels), 
                this.context.bindTexture(this.context.TEXTURE_2D, this._currentTexture), texture;
            }, WebGLRenderer.prototype._disposeTexture = function(texture) {
                this._currentTexture === texture && this._commit();
            }, WebGLRenderer.prototype._assignTexture = function(image, x, y, texture) {
                if (this.context.bindTexture(this.context.TEXTURE_2D, texture), image instanceof HTMLVideoElement) throw g.ExceptionFactory.createAssertionError("WebGLRenderer#_assignTexture: HTMLVideoElement is not supported.");
                this.context.texSubImage2D(this.context.TEXTURE_2D, 0, x, y, this.context.RGBA, this.context.UNSIGNED_BYTE, image), 
                this.context.bindTexture(this.context.TEXTURE_2D, this._currentTexture);
            }, WebGLRenderer.prototype._clearTexture = function(texturePixels, width, height, texture) {
                this.context.bindTexture(this.context.TEXTURE_2D, texture), this.context.texSubImage2D(this.context.TEXTURE_2D, 0, 0, 0, width, height, this.context.RGBA, this.context.UNSIGNED_BYTE, texturePixels), 
                this.context.bindTexture(this.context.TEXTURE_2D, this._currentTexture);
            }, WebGLRenderer.prototype._init = function() {
                this._width = this.surface.width, this._height = this.surface.height, this._renderTargetStack = new RenderTargetStack(this._width, this._height), 
                this._beginCount = 0, this._program = new WebGLShaderProgram_1.WebGLShaderProgram(this.context), 
                this._textureAtlas = new WebGLTextureAtlas_1.WebGLTextureAtlas(), this._fillRectTexture = this._makeTextureRaw(1, 1, new Uint8Array([ 255, 255, 255, 255 ])), 
                this._drawImageColor = WebGLColor_1.WebGLColor.get("white"), this._maxSpriteCount = 1024, 
                this._vertices = this._makeBuffer(24 * this._maxSpriteCount * 4), this._verticesCache = new Float32Array(24 * this._maxSpriteCount), 
                this._numSprites = 0, this._inRendering = !1, this._enableLighting = !1, this._lightTypesDisabled = new Int32Array([ 1, 0, 0, 0 ]), 
                this._lightColorsDisabled = new Float32Array([ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]), 
                this._lightTypes = new Int32Array([ 1, 0, 0, 0 ]), this._lightColors = new Float32Array([ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]), 
                this._lightDirections = new Float32Array([ 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1 ]), 
                this._lightPositions = new Float32Array([ 0, 0, 100, 0, 0, 100, 0, 0, 100, 0, 0, 100 ]), 
                this._lightDistanceAttenuation = new Float32Array([ .1, .005, 25e-6, .1, .005, 25e-6, .1, .005, 25e-6, .1, .005, 25e-6 ]), 
                this._lightAngleAttenuation = new Float32Array([ Math.cos(Math.PI / 4), Math.cos(Math.PI / 2), Math.cos(Math.PI / 4) - Math.cos(Math.PI / 2), 2, Math.cos(Math.PI / 4), Math.cos(Math.PI / 2), Math.cos(Math.PI / 4) - Math.cos(Math.PI / 2), 2, Math.cos(Math.PI / 4), Math.cos(Math.PI / 2), Math.cos(Math.PI / 4) - Math.cos(Math.PI / 2), 2, Math.cos(Math.PI / 4), Math.cos(Math.PI / 2), Math.cos(Math.PI / 4) - Math.cos(Math.PI / 2), 2 ]);
                var state = this.currentState();
                this._currentTexture = this._fillRectTexture, this._currentColor = this._drawImageColor, 
                this._currentAlpha = 1, this._currentCompositeOperation = state.globalCompositeOperation, 
                this._program.use();
                try {
                    this._program.set_aVertex(this._vertices), this._program.set_uColor(this._currentColor), 
                    this._program.set_uAlpha(this._currentAlpha), this._program.set_uSampler(0), this._program.set_uLightType(this._lightTypesDisabled), 
                    this._program.set_uLightColor(this._lightColorsDisabled);
                } finally {
                    this._program.unuse();
                }
                this.context.viewport(0, 0, this.surface.width, this.surface.height), this.context.enable(this.context.BLEND), 
                this.context.activeTexture(this.context.TEXTURE0), this.context.bindTexture(this.context.TEXTURE_2D, this._fillRectTexture), 
                this._compositeOps = {
                    "source-atop": [ this.context.DST_ALPHA, this.context.ONE_MINUS_SRC_ALPHA ],
                    "source-in": [ this.context.DST_ALPHA, this.context.ZERO ],
                    "source-out": [ this.context.ONE_MINUS_DST_ALPHA, this.context.ZERO ],
                    "source-over": [ this.context.ONE, this.context.ONE_MINUS_SRC_ALPHA ],
                    "destination-atop": [ this.context.ONE_MINUS_DST_ALPHA, this.context.SRC_ALPHA ],
                    "destination-in": [ this.context.ZERO, this.context.SRC_ALPHA ],
                    "destination-out": [ this.context.ZERO, this.context.ONE_MINUS_SRC_ALPHA ],
                    "destination-over": [ this.context.ONE_MINUS_DST_ALPHA, this.context.ONE ],
                    lighter: [ this.context.ONE, this.context.ONE ],
                    copy: [ this.context.ONE, this.context.ZERO ],
                    xor: [ this.context.ONE_MINUS_DST_ALPHA, this.context.ONE_MINUS_SRC_ALPHA ]
                };
                var compositeOperation = this._compositeOps[this._currentCompositeOperation];
                this.context.blendFunc(compositeOperation[0], compositeOperation[1]);
            }, WebGLRenderer.prototype._setLightColor = function(lightId, lightColor) {
                this._lightColors[3 * lightId + 0] = lightColor[0], this._lightColors[3 * lightId + 1] = lightColor[1], 
                this._lightColors[3 * lightId + 2] = lightColor[2];
            }, WebGLRenderer.prototype._setLightDirection = function(lightId, lightDirection) {
                this._lightDirections[3 * lightId + 0] = lightDirection[0], this._lightDirections[3 * lightId + 1] = -lightDirection[1], 
                this._lightDirections[3 * lightId + 2] = lightDirection[2];
            }, WebGLRenderer.prototype._setLightPosition = function(lightId, lightPosition) {
                this._lightPositions[3 * lightId + 0] = lightPosition[0], this._lightPositions[3 * lightId + 1] = this._height - lightPosition[1], 
                this._lightPositions[3 * lightId + 2] = lightPosition[2];
            }, WebGLRenderer.prototype._setLightDistanceAttenuation = function(lightId, att0, att1, att2) {
                this._lightDistanceAttenuation[3 * lightId + 0] = att0, this._lightDistanceAttenuation[3 * lightId + 1] = att1, 
                this._lightDistanceAttenuation[3 * lightId + 2] = att2;
            }, WebGLRenderer.prototype._setLightAngleAttenuation = function(lightId, theta, phi, falloff) {
                var cosTheta = Math.cos(.5 * theta), cosPhi = Math.cos(.5 * phi);
                this._lightAngleAttenuation[4 * lightId + 0] = cosTheta, this._lightAngleAttenuation[4 * lightId + 1] = cosPhi, 
                this._lightAngleAttenuation[4 * lightId + 2] = cosTheta - cosPhi, this._lightAngleAttenuation[4 * lightId + 3] = falloff;
            }, WebGLRenderer.prototype._drawImage = function(texture, x, y, w, h, texCoord, color) {
                this._numSprites >= this._maxSpriteCount && this._commit(), this._currentTexture !== texture && (this._currentTexture = texture, 
                this._commit(), this.context.bindTexture(this.context.TEXTURE_2D, texture)), this._currentColor[0] === color[0] && this._currentColor[1] === color[1] && this._currentColor[2] === color[2] && this._currentColor[3] === color[3] || (this._currentColor = color, 
                this._commit(), this._program.set_uColor(color));
                var state = this.currentState();
                if (this._currentAlpha !== state.globalAlpha && (this._currentAlpha = state.globalAlpha, 
                this._commit(), this._program.set_uAlpha(state.globalAlpha)), this._currentCompositeOperation !== state.globalCompositeOperation) {
                    this._currentCompositeOperation = state.globalCompositeOperation, this._commit();
                    var compositeOperation = this._compositeOps[this._currentCompositeOperation];
                    this.context.blendFunc(compositeOperation[0], compositeOperation[1]);
                }
                this._register(this._transformVertex(x, y, w, h, state.transformer), texCoord);
            }, WebGLRenderer.prototype._transformVertex = function(x, y, w, h, transformer) {
                var cw = 2 / this._width, ch = -2 / this._height, m = transformer.matrix, a = cw * w * m[0], b = ch * w * m[1], c = cw * h * m[2], d = ch * h * m[3], e = cw * (x * m[0] + y * m[2] + m[4]) - 1, f = ch * (x * m[1] + y * m[3] + m[5]) + 1;
                return [ e, f, a + e, b + f, a + c + e, b + d + f, e, f, a + c + e, b + d + f, c + e, d + f ];
            }, WebGLRenderer.prototype._register = function(vertex, texCoord) {
                var offset = 6 * this._numSprites;
                ++this._numSprites;
                for (var i = 0; i < 6; ++i) this._verticesCache[4 * (i + offset) + 0] = vertex[2 * i + 0], 
                this._verticesCache[4 * (i + offset) + 1] = vertex[2 * i + 1], this._verticesCache[4 * (i + offset) + 2] = texCoord[2 * i + 0], 
                this._verticesCache[4 * (i + offset) + 3] = texCoord[2 * i + 1];
            }, WebGLRenderer.prototype._commit = function() {
                this._numSprites > 0 && (this.context.bindBuffer(this.context.ARRAY_BUFFER, this._vertices), 
                this.context.bufferSubData(this.context.ARRAY_BUFFER, 0, this._verticesCache.subarray(0, 24 * this._numSprites)), 
                this.context.drawArrays(this.context.TRIANGLES, 0, 6 * this._numSprites), this._numSprites = 0, 
                ++this._commitCount);
            }, WebGLRenderer.prototype._makeTexture = function(data) {
                var texture = this.context.createTexture();
                return this.context.bindTexture(this.context.TEXTURE_2D, texture), this.context.pixelStorei(this.context.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), 
                this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_WRAP_S, this.context.CLAMP_TO_EDGE), 
                this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_WRAP_T, this.context.CLAMP_TO_EDGE), 
                this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MAG_FILTER, this.context.NEAREST), 
                this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MIN_FILTER, this.context.NEAREST), 
                data instanceof HTMLImageElement ? this.context.texImage2D(this.context.TEXTURE_2D, 0, this.context.RGBA, this.context.RGBA, this.context.UNSIGNED_BYTE, data) : data instanceof HTMLCanvasElement ? this.context.texImage2D(this.context.TEXTURE_2D, 0, this.context.RGBA, this.context.RGBA, this.context.UNSIGNED_BYTE, data) : data instanceof ImageData && this.context.texImage2D(this.context.TEXTURE_2D, 0, this.context.RGBA, this.context.RGBA, this.context.UNSIGNED_BYTE, data), 
                this.context.bindTexture(this.context.TEXTURE_2D, this._currentTexture), texture;
            }, WebGLRenderer.prototype._makeBuffer = function(data) {
                var buffer = this.context.createBuffer();
                return this.context.bindBuffer(this.context.ARRAY_BUFFER, buffer), this.context.bufferData(this.context.ARRAY_BUFFER, data, this.context.DYNAMIC_DRAW), 
                buffer;
            }, WebGLRenderer;
        }(StateHoldingRenderer_1.StateHoldingRenderer);
        exports.WebGLRenderer = WebGLRenderer;
    }, {
        "./RenderingHelper": 16,
        "./RenderingState": 17,
        "./StateHoldingRenderer": 18,
        "./WebGLColor": 23,
        "./WebGLShaderProgram": 27,
        "./WebGLTextureAtlas": 28,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    27: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var WebGLShaderProgram = function() {
            function WebGLShaderProgram(context) {
                this.maxLightCount = 4;
                var vSrc = "#version 100\nattribute vec4 aVertex;\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\nuniform vec4 uColor;\nuniform float uAlpha;\nvoid main() {gl_Position = vec4(aVertex.xy, 0.0, 1.0);vTexCoord = aVertex.zw;vColor = uColor * uAlpha;}", fSrc = "#version 100\nprecision mediump float;\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\nuniform sampler2D uSampler;\nuniform int uLightType[4];\nuniform vec3 uLightColor[4];\nuniform vec3 uLightDirection[4];\nuniform vec3 uLightPosition[4];\nuniform vec3 uLightDistanceAttenuation[4];\nuniform vec4 uLightAngleAttenuation[4];\nvoid main() {gl_FragColor = texture2D(uSampler, vTexCoord) * vColor;}";
                this._context = context, this._program = WebGLShaderProgram._makeShaderProgram(context, vSrc, fSrc), 
                this._aVertex = context.getAttribLocation(this._program, "aVertex"), this._uColor = context.getUniformLocation(this._program, "uColor"), 
                this._uAlpha = context.getUniformLocation(this._program, "uAlpha"), this._uSampler = context.getUniformLocation(this._program, "uSampler"), 
                this._uLightType = context.getUniformLocation(this._program, "uLightType"), this._uLightColor = context.getUniformLocation(this._program, "uLightColor"), 
                this._uLightDirection = context.getUniformLocation(this._program, "uLightDirection"), 
                this._uLightPosition = context.getUniformLocation(this._program, "uLightPosition"), 
                this._uLightDistanceAttenuation = context.getUniformLocation(this._program, "uLightDistanceAttenuation"), 
                this._uLightAngleAttenuation = context.getUniformLocation(this._program, "uLightAngleAttenuation");
            }
            return WebGLShaderProgram._makeShader = function(gl, typ, src) {
                var shader = gl.createShader(typ);
                if (gl.shaderSource(shader, src), gl.compileShader(shader), !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    var msg = gl.getShaderInfoLog(shader);
                    throw gl.deleteShader(shader), new Error(msg);
                }
                return shader;
            }, WebGLShaderProgram._makeShaderProgram = function(gl, vSrc, fSrc) {
                var program = gl.createProgram(), vShader = WebGLShaderProgram._makeShader(gl, gl.VERTEX_SHADER, vSrc);
                gl.attachShader(program, vShader), gl.deleteShader(vShader);
                var fShader = WebGLShaderProgram._makeShader(gl, gl.FRAGMENT_SHADER, fSrc);
                if (gl.attachShader(program, fShader), gl.deleteShader(fShader), gl.linkProgram(program), 
                !gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    var msg = gl.getProgramInfoLog(program);
                    throw gl.deleteProgram(program), new Error(msg);
                }
                return program;
            }, WebGLShaderProgram.prototype.set_aVertex = function(buffer) {
                this._context.bindBuffer(this._context.ARRAY_BUFFER, buffer), this._context.enableVertexAttribArray(this._aVertex), 
                this._context.vertexAttribPointer(this._aVertex, 4, this._context.FLOAT, !1, 0, 0);
            }, WebGLShaderProgram.prototype.set_uColor = function(rgba) {
                this._context.uniform4f(this._uColor, rgba[0], rgba[1], rgba[2], rgba[3]);
            }, WebGLShaderProgram.prototype.set_uAlpha = function(alpha) {
                this._context.uniform1f(this._uAlpha, alpha);
            }, WebGLShaderProgram.prototype.set_uSampler = function(value) {
                this._context.uniform1i(this._uSampler, value);
            }, WebGLShaderProgram.prototype.set_uLightType = function(value) {
                this._context.uniform1iv(this._uLightType, value);
            }, WebGLShaderProgram.prototype.set_uLightColor = function(value) {
                this._context.uniform3fv(this._uLightColor, value);
            }, WebGLShaderProgram.prototype.set_uLightDirection = function(value) {
                this._context.uniform3fv(this._uLightDirection, value);
            }, WebGLShaderProgram.prototype.set_uLightPosition = function(value) {
                this._context.uniform3fv(this._uLightPosition, value);
            }, WebGLShaderProgram.prototype.set_uLightDistanceAttenuation = function(value) {
                this._context.uniform3fv(this._uLightDistanceAttenuation, value);
            }, WebGLShaderProgram.prototype.set_uLightAngleAttenuation = function(value) {
                this._context.uniform4fv(this._uLightAngleAttenuation, value);
            }, WebGLShaderProgram.prototype.use = function() {
                this._context.useProgram(this._program);
            }, WebGLShaderProgram.prototype.unuse = function() {
                this._context.useProgram(null);
            }, WebGLShaderProgram;
        }();
        exports.WebGLShaderProgram = WebGLShaderProgram;
    }, {} ],
    28: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var WebGLTextureMap_1 = require("./WebGLTextureMap"), WebGLTextureAtlas = function() {
            function WebGLTextureAtlas() {
                this._maps = [], this._insertPos = 0, this.emptyTexturePixels = new Uint8Array(WebGLTextureAtlas.TEXTURE_SIZE * WebGLTextureAtlas.TEXTURE_SIZE * 4);
            }
            return WebGLTextureAtlas.prototype.clear = function() {
                for (var i = 0; i < this._maps.length; ++i) this._maps[i].dispose();
            }, WebGLTextureAtlas.prototype.showOccupancy = function() {
                for (var i = 0; i < this._maps.length; ++i) console.log("occupancy[" + i + "]: " + this._maps[i].occupancy());
            }, WebGLTextureAtlas.prototype._makeTextureForSurface = function(renderer, surface) {
                var image = surface._drawable;
                if (image && !image._texture) {
                    var width = image.width, height = image.height;
                    return width >= WebGLTextureAtlas.TEXTURE_SIZE || height >= WebGLTextureAtlas.TEXTURE_SIZE ? void renderer._makeTextureForSurface(surface) : void this._assign(renderer, surface, this._maps);
                }
            }, WebGLTextureAtlas.prototype._assign = function(renderer, surface, maps) {
                for (var map, i = 0; i < maps.length; ++i) if (map = maps[(i + this._insertPos) % maps.length].insert(surface)) return this._register(renderer, map, surface._drawable), 
                void (this._insertPos = i);
                map = null, maps.length >= WebGLTextureAtlas.TEXTURE_COUNT && (map = maps.shift(), 
                renderer._disposeTexture(map.texture), map.dispose(), renderer._clearTexture(this.emptyTexturePixels, WebGLTextureAtlas.TEXTURE_SIZE, WebGLTextureAtlas.TEXTURE_SIZE, map.texture)), 
                map || (map = new WebGLTextureMap_1.WebGLTextureMap(renderer._makeTextureRaw(WebGLTextureAtlas.TEXTURE_SIZE, WebGLTextureAtlas.TEXTURE_SIZE), 0, 0, WebGLTextureAtlas.TEXTURE_SIZE, WebGLTextureAtlas.TEXTURE_SIZE)), 
                maps.push(map), map = map.insert(surface), this._register(renderer, map, surface._drawable);
            }, WebGLTextureAtlas.prototype._register = function(renderer, map, image) {
                image._texture = map.texture, image._textureOffsetX = map.offsetX, image._textureOffsetY = map.offsetY, 
                image._textureWidth = WebGLTextureAtlas.TEXTURE_SIZE, image._textureHeight = WebGLTextureAtlas.TEXTURE_SIZE, 
                renderer._assignTexture(image, map.offsetX, map.offsetY, map.texture);
            }, WebGLTextureAtlas;
        }();
        WebGLTextureAtlas.TEXTURE_SIZE = 1024, WebGLTextureAtlas.TEXTURE_COUNT = 16, exports.WebGLTextureAtlas = WebGLTextureAtlas;
    }, {
        "./WebGLTextureMap": 29
    } ],
    29: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var WebGLTextureMap = function() {
            function WebGLTextureMap(texture, offsetX, offsetY, width, height) {
                this.texture = texture, this.offsetX = offsetX, this.offsetY = offsetY, this._width = width, 
                this._height = height;
            }
            return WebGLTextureMap.prototype.dispose = function() {
                this._left && (this._left.dispose(), this._left = null), this._right && (this._right.dispose(), 
                this._right = null), this._surface && (this._surface._drawable && (this._surface._drawable._texture = null), 
                this._surface = null);
            }, WebGLTextureMap.prototype.capacity = function() {
                return this._width * this._height;
            }, WebGLTextureMap.prototype.area = function() {
                if (!this._surface) return 0;
                var image = this._surface._drawable, a = image.width * image.height;
                return this._left && (a += this._left.area()), this._right && (a += this._right.area()), 
                a;
            }, WebGLTextureMap.prototype.occupancy = function() {
                return this.area() / this.capacity();
            }, WebGLTextureMap.prototype.insert = function(surface) {
                var image = surface._drawable, width = image.width + WebGLTextureMap.TEXTURE_MARGIN, height = image.height + WebGLTextureMap.TEXTURE_MARGIN;
                if (this._surface) {
                    if (this._left) {
                        var left = this._left.insert(surface);
                        if (left) return left;
                    }
                    if (this._right) {
                        var right = this._right.insert(surface);
                        if (right) return right;
                    }
                    return null;
                }
                if (this._width < width || this._height < height) return null;
                var remainWidth = this._width - width, remainHeight = this._height - height;
                return remainWidth <= remainHeight ? (this._left = new WebGLTextureMap(this.texture, this.offsetX + width, this.offsetY, remainWidth, height), 
                this._right = new WebGLTextureMap(this.texture, this.offsetX, this.offsetY + height, this._width, remainHeight)) : (this._left = new WebGLTextureMap(this.texture, this.offsetX, this.offsetY + height, width, remainHeight), 
                this._right = new WebGLTextureMap(this.texture, this.offsetX + width, this.offsetY, remainWidth, this._height)), 
                this._surface = surface, this;
            }, WebGLTextureMap;
        }();
        WebGLTextureMap.TEXTURE_MARGIN = 1, exports.WebGLTextureMap = WebGLTextureMap;
    }, {} ],
    30: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var SurfaceFactory, RenderingHelper_1 = require("../RenderingHelper"), CanvasSurface_1 = require("../CanvasSurface"), WebGLPrimarySurface_1 = require("../WebGLPrimarySurface"), WebGLBackSurface_1 = require("../WebGLBackSurface");
        !function(SurfaceFactory) {
            function createPrimarySurface(width, height, rendererCandidates) {
                return RenderingHelper_1.RenderingHelper.usedWebGL(rendererCandidates) ? new WebGLPrimarySurface_1.WebGLPrimarySurface(width, height) : new CanvasSurface_1.CanvasSurface(width, height, rendererCandidates);
            }
            function createBackSurface(width, height, platform, rendererCandidates) {
                if (RenderingHelper_1.RenderingHelper.usedWebGL(rendererCandidates)) {
                    var renderer = platform.getPrimarySurface().renderer();
                    return new WebGLBackSurface_1.WebGLBackSurface(width, height, renderer);
                }
                return new CanvasSurface_1.CanvasSurface(width, height, rendererCandidates);
            }
            SurfaceFactory.createPrimarySurface = createPrimarySurface, SurfaceFactory.createBackSurface = createBackSurface;
        }(SurfaceFactory = exports.SurfaceFactory || (exports.SurfaceFactory = {}));
    }, {
        "../CanvasSurface": 13,
        "../RenderingHelper": 16,
        "../WebGLBackSurface": 21,
        "../WebGLPrimarySurface": 24
    } ],
    31: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), InputAbstractHandler = (require("@akashic/akashic-pdi"), 
        function() {
            function InputAbstractHandler(inputView, disablePreventDefault) {
                if (Object.getPrototypeOf && Object.getPrototypeOf(this) === InputAbstractHandler.prototype) throw new Error("InputAbstractHandler is abstract and should not be directly instantiated");
                this.inputView = inputView, this.pointerEventLock = {}, this._calculateOffsetForLazy = !0, 
                this._xScale = 1, this._yScale = 1, this._offset = {
                    x: 0,
                    y: 0
                }, this._disablePreventDefault = !!disablePreventDefault, this.pointTrigger = new g.Trigger();
            }
            return InputAbstractHandler.isSupported = function() {
                return !1;
            }, InputAbstractHandler.prototype.start = function() {
                throw new Error("This method is abstract");
            }, InputAbstractHandler.prototype.stop = function() {
                throw new Error("This method is abstract");
            }, InputAbstractHandler.prototype.setOffset = function(value) {
                this._offset = value;
            }, InputAbstractHandler.prototype.setScale = function(xScale, yScale) {
                void 0 === yScale && (yScale = xScale), this._xScale = xScale, this._yScale = yScale;
            }, InputAbstractHandler.prototype.pointDown = function(identifier, pagePosition) {
                this.pointTrigger.fire({
                    type: 0,
                    identifier: identifier,
                    offset: this.getOffsetFromEvent(pagePosition)
                }), this.pointerEventLock[identifier] = !0;
            }, InputAbstractHandler.prototype.pointMove = function(identifier, pagePosition) {
                identifier in this.pointerEventLock && this.pointTrigger.fire({
                    type: 1,
                    identifier: identifier,
                    offset: this.getOffsetFromEvent(pagePosition)
                });
            }, InputAbstractHandler.prototype.pointUp = function(identifier, pagePosition) {
                identifier in this.pointerEventLock && (this.pointTrigger.fire({
                    type: 2,
                    identifier: identifier,
                    offset: this.getOffsetFromEvent(pagePosition)
                }), delete this.pointerEventLock[identifier]);
            }, InputAbstractHandler.prototype.getOffsetFromEvent = function(e) {
                if (this._calculateOffsetForLazy) {
                    var bounding = this.inputView.getBoundingClientRect(), offsetOfWindow = {
                        x: Math.round(window.pageXOffset + bounding.left),
                        y: Math.round(window.pageYOffset + bounding.top)
                    };
                    this._offset = offsetOfWindow, this._calculateOffsetForLazy = !1;
                }
                return {
                    x: (e.pageX - this._offset.x) / this._xScale,
                    y: (e.pageY - this._offset.y) / this._yScale
                };
            }, InputAbstractHandler.prototype.getScale = function() {
                return {
                    x: this._xScale,
                    y: this._yScale
                };
            }, InputAbstractHandler.prototype.notifyViewMoved = function() {
                this._calculateOffsetForLazy = !0;
            }, InputAbstractHandler;
        }());
        exports.InputAbstractHandler = InputAbstractHandler;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine",
        "@akashic/akashic-pdi": 44
    } ],
    32: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var InputAbstractHandler_1 = require("./InputAbstractHandler"), MouseHandler = function(_super) {
            function MouseHandler(inputView, disablePreventDefault) {
                var _this = _super.call(this, inputView, disablePreventDefault) || this, identifier = 1;
                return _this.onPointDown = function(e) {
                    0 === e.button && (_this.pointDown(identifier, e), window.addEventListener("mousemove", _this.onPointMove, !1), 
                    window.addEventListener("mouseup", _this.onPointUp, !1), _this._disablePreventDefault || (e.stopPropagation(), 
                    e.preventDefault()));
                }, _this.onPointMove = function(e) {
                    _this.pointMove(identifier, e), _this._disablePreventDefault || (e.stopPropagation(), 
                    e.preventDefault());
                }, _this.onPointUp = function(e) {
                    _this.pointUp(identifier, e), window.removeEventListener("mousemove", _this.onPointMove, !1), 
                    window.removeEventListener("mouseup", _this.onPointUp, !1), _this._disablePreventDefault || (e.stopPropagation(), 
                    e.preventDefault());
                }, _this;
            }
            return __extends(MouseHandler, _super), MouseHandler.isSupported = function() {
                return !0;
            }, MouseHandler.prototype.start = function() {
                this.inputView.addEventListener("mousedown", this.onPointDown, !1);
            }, MouseHandler.prototype.stop = function() {
                this.inputView.removeEventListener("mousedown", this.onPointDown, !1);
            }, MouseHandler;
        }(InputAbstractHandler_1.InputAbstractHandler);
        exports.MouseHandler = MouseHandler;
    }, {
        "./InputAbstractHandler": 31
    } ],
    33: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var InputAbstractHandler_1 = require("./InputAbstractHandler"), RuntimeInfo_1 = require("../RuntimeInfo"), TouchHandler = function(_super) {
            function TouchHandler(inputView, disablePreventDefault) {
                var _this = _super.call(this, inputView, disablePreventDefault) || this;
                return _this.onPointDown = function(e) {
                    for (var touches = e.changedTouches, i = 0, len = touches.length; i < len; i++) {
                        var touch = touches[i];
                        _this.pointDown(touch.identifier, touch);
                    }
                    _this._disablePreventDefault || (e.stopPropagation(), e.preventDefault());
                }, _this.onPointMove = function(e) {
                    for (var touches = e.changedTouches, i = 0, len = touches.length; i < len; i++) {
                        var touch = touches[i];
                        _this.pointMove(touch.identifier, touch);
                    }
                    _this._disablePreventDefault || (e.stopPropagation(), e.preventDefault());
                }, _this.onPointUp = function(e) {
                    for (var touches = e.changedTouches, i = 0, len = touches.length; i < len; i++) {
                        var touch = touches[i];
                        _this.pointUp(touch.identifier, touch);
                    }
                    _this._disablePreventDefault || (e.stopPropagation(), e.preventDefault());
                }, _this;
            }
            return __extends(TouchHandler, _super), TouchHandler.isSupported = function() {
                return RuntimeInfo_1.RuntimeInfo.touchEnabled();
            }, TouchHandler.prototype.start = function() {
                this.inputView.addEventListener("touchstart", this.onPointDown), this.inputView.addEventListener("touchmove", this.onPointMove), 
                this.inputView.addEventListener("touchend", this.onPointUp);
            }, TouchHandler.prototype.stop = function() {
                this.inputView.removeEventListener("touchstart", this.onPointDown), this.inputView.removeEventListener("touchmove", this.onPointMove), 
                this.inputView.removeEventListener("touchend", this.onPointUp);
            }, TouchHandler;
        }(InputAbstractHandler_1.InputAbstractHandler);
        exports.TouchHandler = TouchHandler;
    }, {
        "../RuntimeInfo": 6,
        "./InputAbstractHandler": 31
    } ],
    34: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var AudioPluginManager = function() {
            function AudioPluginManager() {
                this._activePlugin = void 0;
            }
            return AudioPluginManager.prototype.getActivePlugin = function() {
                return void 0 === this._activePlugin ? null : this._activePlugin;
            }, AudioPluginManager.prototype.tryInstallPlugin = function(plugins) {
                var PluginConstructor = this.findFirstAvailablePlugin(plugins);
                return !!PluginConstructor && (this._activePlugin = new PluginConstructor(), !0);
            }, AudioPluginManager.prototype.findFirstAvailablePlugin = function(plugins) {
                for (var i = 0, len = plugins.length; i < len; i++) {
                    var plugin = plugins[i];
                    if (plugin.isSupported()) return plugin;
                }
            }, AudioPluginManager;
        }();
        exports.AudioPluginManager = AudioPluginManager;
    }, {} ],
    35: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var audioPlugins = [];
        exports.AudioPluginRegistry = {
            addPlugin: function(plugin) {
                audioPlugins.indexOf(plugin) === -1 && audioPlugins.push(plugin);
            },
            getRegisteredAudioPlugins: function() {
                return audioPlugins;
            },
            clear: function() {
                audioPlugins = [];
            }
        };
    }, {} ],
    36: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLAudioAsset = function(_super) {
            function HTMLAudioAsset() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(HTMLAudioAsset, _super), HTMLAudioAsset.prototype._load = function(loader) {
                var _this = this, audio = new Audio(), startLoadingAudio = function(path, handlers) {
                    audio.autoplay = !1, audio.preload = "none", audio.src = path, _this._attachAll(audio, handlers), 
                    audio.preload = "auto", setAudioLoadInterval(audio, handlers), audio.load();
                }, handlers = {
                    success: function() {
                        _this._detachAll(audio, handlers), _this.data = audio, loader._onAssetLoad(_this), 
                        window.clearInterval(_this._intervalId);
                    },
                    error: function() {
                        _this._detachAll(audio, handlers), _this.data = audio, loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("HTMLAudioAsset loading error")), 
                        window.clearInterval(_this._intervalId);
                    }
                }, setAudioLoadInterval = function(audio, handlers) {
                    _this._intervalCount = 0, _this._intervalId = window.setInterval(function() {
                        4 === audio.readyState ? handlers.success() : (++_this._intervalCount, 600 === _this._intervalCount && handlers.error());
                    }, 100);
                };
                if (".mp4" === this.path.slice(-4) && HTMLAudioAsset.supportedFormats.indexOf("aac") !== -1) {
                    var altHandlers = {
                        success: handlers.success,
                        error: function() {
                            _this._detachAll(audio, altHandlers), window.clearInterval(_this._intervalId);
                            var altPath = _this.path.slice(0, _this.path.length - 4) + ".aac";
                            startLoadingAudio(altPath, handlers);
                        }
                    };
                    return void startLoadingAudio(this.path, altHandlers);
                }
                startLoadingAudio(this.path, handlers);
            }, HTMLAudioAsset.prototype.createInstance = function() {
                var audio = new Audio(this.data.src), ret = new HTMLAudioAsset(this.id, this.path, this.duration, this._system, this.loop, this.hint);
                return ret.data = audio, ret;
            }, HTMLAudioAsset.prototype._assetPathFilter = function(path) {
                return HTMLAudioAsset.supportedFormats.indexOf("ogg") !== -1 ? g.PathUtil.addExtname(path, "ogg") : HTMLAudioAsset.supportedFormats.indexOf("mp4") !== -1 ? g.PathUtil.addExtname(path, "mp4") : void 0;
            }, HTMLAudioAsset.prototype._attachAll = function(audio, handlers) {
                handlers.success && audio.addEventListener("canplaythrough", handlers.success, !1), 
                handlers.error && (audio.addEventListener("stalled", handlers.error, !1), audio.addEventListener("error", handlers.error, !1), 
                audio.addEventListener("abort", handlers.error, !1));
            }, HTMLAudioAsset.prototype._detachAll = function(audio, handlers) {
                handlers.success && audio.removeEventListener("canplaythrough", handlers.success, !1), 
                handlers.error && (audio.removeEventListener("stalled", handlers.error, !1), audio.removeEventListener("error", handlers.error, !1), 
                audio.removeEventListener("abort", handlers.error, !1));
            }, HTMLAudioAsset;
        }(g.AudioAsset);
        exports.HTMLAudioAsset = HTMLAudioAsset;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    37: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), HTMLAudioPlayer = function(_super) {
            function HTMLAudioPlayer(system) {
                var _this = _super.call(this, system) || this;
                return _this._endedEventHandler = function() {
                    _this._onAudioEnded();
                }, _this;
            }
            return __extends(HTMLAudioPlayer, _super), HTMLAudioPlayer.prototype.play = function(asset) {
                this.currentAudio && this.stop();
                var instance = asset.createInstance(), audio = instance.data;
                audio.volume = this.volume, audio.play(), audio.loop = asset.loop, audio.addEventListener("ended", this._endedEventHandler, !1), 
                this._audioInstance = audio, _super.prototype.play.call(this, asset);
            }, HTMLAudioPlayer.prototype.stop = function() {
                this.currentAudio && (this._clearEndedEventHandler(), this._audioInstance.pause(), 
                this._audioInstance.currentTime = 0, _super.prototype.stop.call(this));
            }, HTMLAudioPlayer.prototype.changeVolume = function(volume) {
                this.currentAudio && (this._audioInstance.volume = volume), _super.prototype.changeVolume.call(this, volume);
            }, HTMLAudioPlayer.prototype._onAudioEnded = function() {
                this._clearEndedEventHandler(), _super.prototype.stop.call(this);
            }, HTMLAudioPlayer.prototype._clearEndedEventHandler = function() {
                this._audioInstance.removeEventListener("ended", this._endedEventHandler, !1);
            }, HTMLAudioPlayer;
        }(g.AudioPlayer);
        exports.HTMLAudioPlayer = HTMLAudioPlayer;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    38: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var HTMLAudioAsset_1 = require("./HTMLAudioAsset"), HTMLAudioPlayer_1 = require("./HTMLAudioPlayer"), HTMLAudioPlugin = function() {
            function HTMLAudioPlugin() {
                this._supportedFormats = this._detectSupportedFormats(), HTMLAudioAsset_1.HTMLAudioAsset.supportedFormats = this.supportedFormats;
            }
            return HTMLAudioPlugin.isSupported = function() {
                var audioElement = document.createElement("audio"), result = !1;
                try {
                    result = void 0 !== audioElement.canPlayType;
                } catch (e) {}
                return result;
            }, Object.defineProperty(HTMLAudioPlugin.prototype, "supportedFormats", {
                get: function() {
                    return this._supportedFormats;
                },
                set: function(supportedFormats) {
                    this._supportedFormats = supportedFormats, HTMLAudioAsset_1.HTMLAudioAsset.supportedFormats = supportedFormats;
                },
                enumerable: !0,
                configurable: !0
            }), HTMLAudioPlugin.prototype.createAsset = function(id, assetPath, duration, system, loop, hint) {
                return new HTMLAudioAsset_1.HTMLAudioAsset(id, assetPath, duration, system, loop, hint);
            }, HTMLAudioPlugin.prototype.createPlayer = function(system) {
                return new HTMLAudioPlayer_1.HTMLAudioPlayer(system);
            }, HTMLAudioPlugin.prototype._detectSupportedFormats = function() {
                var audioElement = document.createElement("audio"), supportedFormats = [];
                try {
                    for (var supportedExtensions = [ "ogg", "mp4", "aac" ], i = 0, len = supportedExtensions.length; i < len; i++) {
                        var ext = supportedExtensions[i], supported = "no" !== audioElement.canPlayType("audio/" + ext) && "" !== audioElement.canPlayType("audio/" + ext);
                        supported && supportedFormats.push(ext);
                    }
                } catch (e) {}
                return supportedFormats;
            }, HTMLAudioPlugin;
        }();
        exports.HTMLAudioPlugin = HTMLAudioPlugin;
    }, {
        "./HTMLAudioAsset": 36,
        "./HTMLAudioPlayer": 37
    } ],
    39: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), XHRLoader_1 = require("../../utils/XHRLoader"), helper = require("./WebAudioHelper"), WebAudioAsset = function(_super) {
            function WebAudioAsset() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return __extends(WebAudioAsset, _super), WebAudioAsset.prototype._load = function(loader) {
                var _this = this, successHandler = function(decodedAudio) {
                    _this.data = decodedAudio, loader._onAssetLoad(_this);
                }, errorHandler = function() {
                    loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("WebAudioAsset unknown loading error"));
                }, onLoadArrayBufferHandler = function(response) {
                    var audioContext = helper.getAudioContext();
                    audioContext.decodeAudioData(response, successHandler, errorHandler);
                }, xhrLoader = new XHRLoader_1.XHRLoader(), loadArrayBuffer = function(path, onSuccess, onFailed) {
                    xhrLoader.getArrayBuffer(path, function(error, response) {
                        error ? onFailed(error) : onSuccess(response);
                    });
                };
                return ".mp4" === this.path.slice(-4) ? void loadArrayBuffer(this.path, onLoadArrayBufferHandler, function(error) {
                    var altPath = _this.path.slice(0, _this.path.length - 4) + ".aac";
                    loadArrayBuffer(altPath, function(response) {
                        _this.path = altPath, onLoadArrayBufferHandler(response);
                    }, errorHandler);
                }) : void loadArrayBuffer(this.path, onLoadArrayBufferHandler, errorHandler);
            }, WebAudioAsset.prototype._assetPathFilter = function(path) {
                if (WebAudioAsset.supportedFormats.indexOf("ogg") !== -1) return g.PathUtil.addExtname(path, "ogg");
                if (WebAudioAsset.supportedFormats.indexOf("mp4") !== -1) return g.PathUtil.addExtname(path, "mp4");
                throw new Error("not available ogg or aac, The UA supported formats are " + WebAudioAsset.supportedFormats);
            }, WebAudioAsset;
        }(g.AudioAsset);
        WebAudioAsset.supportedFormats = [], exports.WebAudioAsset = WebAudioAsset;
    }, {
        "../../utils/XHRLoader": 43,
        "./WebAudioHelper": 40,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    40: [ function(require, module, exports) {
        (function(global) {
            "use strict";
            var WebAudioHelper, AudioContext = global.AudioContext || global.webkitAudioContext, singleContext = null;
            !function(WebAudioHelper) {
                function getAudioContext() {
                    return singleContext || (singleContext = new AudioContext()), singleContext;
                }
                function createGainNode(context) {
                    return context.createGain ? context.createGain() : context.createGainNode();
                }
                function createBufferNode(context) {
                    var sourceNode = context.createBufferSource();
                    return sourceNode.start ? sourceNode : (sourceNode.start = sourceNode.noteOn, sourceNode.stop = sourceNode.noteOff, 
                    sourceNode);
                }
                WebAudioHelper.getAudioContext = getAudioContext, WebAudioHelper.createGainNode = createGainNode, 
                WebAudioHelper.createBufferNode = createBufferNode;
            }(WebAudioHelper || (WebAudioHelper = {})), module.exports = WebAudioHelper;
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {} ],
    41: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            };
            return function(d, b) {
                function __() {
                    this.constructor = d;
                }
                extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
                new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), helper = require("./WebAudioHelper"), WebAudioPlayer = function(_super) {
            function WebAudioPlayer(system) {
                var _this = _super.call(this, system) || this;
                return _this._audioContext = helper.getAudioContext(), _this._gainNode = helper.createGainNode(_this._audioContext), 
                _this._gainNode.connect(_this._audioContext.destination), _this._gainNode.gain.value = system.volume, 
                _this._sourceNode = void 0, _this._endedEventHandler = function() {
                    _this._onAudioEnded();
                }, _this;
            }
            return __extends(WebAudioPlayer, _super), WebAudioPlayer.prototype.changeVolume = function(volume) {
                this._gainNode.gain.value = volume, _super.prototype.changeVolume.call(this, volume);
            }, WebAudioPlayer.prototype.play = function(asset) {
                this.currentAudio && this.stop();
                var bufferNode = helper.createBufferNode(this._audioContext);
                bufferNode.loop = asset.loop, bufferNode.buffer = asset.data, bufferNode.connect(this._gainNode), 
                this._sourceNode = bufferNode, this._sourceNode.onended = this._endedEventHandler, 
                this._sourceNode.start(0), _super.prototype.play.call(this, asset);
            }, WebAudioPlayer.prototype.stop = function() {
                this.currentAudio && (this._clearEndedEventHandler(), this._sourceNode.stop(0), 
                _super.prototype.stop.call(this));
            }, WebAudioPlayer.prototype._onAudioEnded = function() {
                this._clearEndedEventHandler(), _super.prototype.stop.call(this);
            }, WebAudioPlayer.prototype._clearEndedEventHandler = function() {
                this._sourceNode.onended = null;
            }, WebAudioPlayer;
        }(g.AudioPlayer);
        exports.WebAudioPlayer = WebAudioPlayer;
    }, {
        "./WebAudioHelper": 40,
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    42: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var WebAudioAsset_1 = require("./WebAudioAsset"), WebAudioPlayer_1 = require("./WebAudioPlayer"), WebAudioPlugin = function() {
            function WebAudioPlugin() {
                this.supportedFormats = this._detectSupportedFormats();
            }
            return WebAudioPlugin.isSupported = function() {
                return "AudioContext" in window || "webkitAudioContext" in window;
            }, Object.defineProperty(WebAudioPlugin.prototype, "supportedFormats", {
                get: function() {
                    return this._supportedFormats;
                },
                set: function(supportedFormats) {
                    this._supportedFormats = supportedFormats, WebAudioAsset_1.WebAudioAsset.supportedFormats = supportedFormats;
                },
                enumerable: !0,
                configurable: !0
            }), WebAudioPlugin.prototype.createAsset = function(id, assetPath, duration, system, loop, hint) {
                return new WebAudioAsset_1.WebAudioAsset(id, assetPath, duration, system, loop, hint);
            }, WebAudioPlugin.prototype.createPlayer = function(system) {
                return new WebAudioPlayer_1.WebAudioPlayer(system);
            }, WebAudioPlugin.prototype._detectSupportedFormats = function() {
                var audioElement = document.createElement("audio"), supportedFormats = [];
                try {
                    for (var supportedExtensions = [ "ogg", "mp4", "aac" ], i = 0, len = supportedExtensions.length; i < len; i++) {
                        var ext = supportedExtensions[i], supported = "no" !== audioElement.canPlayType("audio/" + ext) && "" !== audioElement.canPlayType("audio/" + ext);
                        supported && supportedFormats.push(ext);
                    }
                } catch (e) {}
                return supportedFormats;
            }, WebAudioPlugin;
        }();
        exports.WebAudioPlugin = WebAudioPlugin;
    }, {
        "./WebAudioAsset": 39,
        "./WebAudioPlayer": 41
    } ],
    43: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var g = require("@akashic/akashic-engine"), XHRLoader = function() {
            function XHRLoader(options) {
                void 0 === options && (options = {}), this.timeout = options.timeout || 15e3;
            }
            return XHRLoader.prototype.get = function(url, callback) {
                this._getRequestObject({
                    url: url,
                    responseType: "text"
                }, callback);
            }, XHRLoader.prototype.getArrayBuffer = function(url, callback) {
                this._getRequestObject({
                    url: url,
                    responseType: "arraybuffer"
                }, callback);
            }, XHRLoader.prototype._getRequestObject = function(requestObject, callback) {
                var request = new XMLHttpRequest();
                request.open("GET", requestObject.url, !0), request.responseType = requestObject.responseType, 
                request.timeout = this.timeout, request.addEventListener("timeout", function() {
                    callback(g.ExceptionFactory.createAssetLoadError("loading timeout"));
                }, !1), request.addEventListener("load", function() {
                    if (request.status >= 200 && request.status < 300) {
                        var response = "text" === requestObject.responseType ? request.responseText : request.response;
                        callback(null, response);
                    } else callback(g.ExceptionFactory.createAssetLoadError("loading error. status: " + request.status));
                }, !1), request.addEventListener("error", function() {
                    callback(g.ExceptionFactory.createAssetLoadError("loading error. status: " + request.status));
                }, !1), request.send();
            }, XHRLoader;
        }();
        exports.XHRLoader = XHRLoader;
    }, {
        "@akashic/akashic-engine": "@akashic/akashic-engine"
    } ],
    44: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    }, {} ]
}, {}, []);</script>

<script>
if (! ("optionProps" in window)) {
	window.optionProps = {};
}
window.optionProps.magnify = true
window.g = require("@akashic/akashic-engine");
</script>
<script>
if (! ("gLocalAssetContainer" in window)) {
	window.gLocalAssetContainer = {};
}

			window.gLocalAssetContainer["game.json"] = "%7B%0A%09%22width%22%3A%20512%2C%0A%09%22height%22%3A%20384%2C%0A%09%22fps%22%3A%2030%2C%0A%09%22assets%22%3A%20%7B%0A%09%09%22mainScene%22%3A%20%7B%0A%09%09%09%22type%22%3A%20%22script%22%2C%0A%09%09%09%22path%22%3A%20%22script%2FmainScene.js%22%2C%0A%09%09%09%22global%22%3A%20true%0A%09%09%7D%2C%0A%09%09%22map%22%3A%20%7B%0A%09%09%09%22type%22%3A%20%22image%22%2C%0A%09%09%09%22width%22%3A%20512%2C%0A%09%09%09%22height%22%3A%20512%2C%0A%09%09%09%22path%22%3A%20%22image%2Fmap.png%22%0A%09%09%7D%0A%09%7D%2C%0A%09%22environment%22%3A%20%7B%0A%09%09%22sandbox-runtime%22%3A%20%221%22%0A%09%7D%0A%7D";
				window.gLocalAssetContainer["mainScene"] = function(g) {
			(function(exports, require, module, __filename, __dirname) {
var game = g.game;

module.exports = function() {
    var scene = new g.Scene({game: game, assetIds:["map"]});
    scene.loaded.handle(function() {
        var tile = new g.Tile({
            scene: scene,
            src: scene.assets["map"],
            tileWidth: 32,
            tileHeight: 32,
            //
            // 
            //
            tileData: [
                [ -1, -1, 84, 85, -1, -1, -1, -1,122,123,164, -1, -1, -1, -1,125, 88, 89, -1, -1, -1, -1, -1, -1, -1, -1, -1,182,180, -1, -1, 76],
                [151,189,100,101,170,190,191,168,138,139, 77, -1,157,158,159,141,104,105,169,204,172,205,112,113,114,206, 10, 11, 12, 60, -1,201],
                [ 49, 49, 49, 49, 49, 49, 49, 49, 50, 83, 78,115, 55, 56, 56, 56, 56, 56, 56, 56, 56, 57,128,129,130, 58, 42, 43, 44,145, -1,202],
                [ 33, 34,165, 32, 34, -1, -1, -1,173, 99, 78,131,121, 90, 91, -1, -1, -1, 72,192,126,166, 58, 59, 59, 60,167,  5,  6,161, -1,202],
                [198, -1, 86, 87, -1,122,123, -1, 48, 50, 78,131,137,106,107,175,150, -1, 72,193,142, -1,201, 37, 38,201, -1, 21, 22, 74,184,202],
                [199,149,102,103,152,154,155,153,156,179, 78, 61, 62, 62, 62, 62, 63,115, 72,194, 71,207,202, 53, 54,203, -1, 69, 70, 75, 74,202],
                [199, 48, 49, 49, 49, 49, 49, 49, 49, 50, 79,195, -1, 45, 46, 47, -1,131, 72,  7,  8,  9,203, -1,183, -1, -1, -1, -1, 76, 75,202],
                [199, -1, -1, 66, -1,124,146,119, -1, 94, 95,196,127, 92, 93,147,144,131, 72, 23, 24, 25, 19, 20, 58, 60,115, 58, 60, -1, 76,202],
                [199,148, 80, 81, 82,140,162,135,171,110,111,197,143,108,109,163,160,131, 72, 39, 40, 41, 67, 68,120, -1,131, -1, -1, 58, 60,202],
                [199, 64, 96, 97, 98,  0,  1,  2, 97, 13, 14, 15,115, 61, 62, 62, 62, 63, 73,176,177, -1, 58, 60,136,178,131,  3,  4,174, -1,203],
                [200, 65,116,116,116, 16, 17, 18,116, 29, 30, 31,131,185,187,186,188,181, -1, 10, 12,118,118,118, 10, 11, 12, 35, 36, 77,117,117],
                [116, 65,132,132,132, 16, 17, 18,132, 29, 30, 31, 14, 14, 14, 14, 14, 15,118, 26, 28,134,134,134, 26, 27, 28, 51, 52, 78,133,133],
            ],
            touchable: true
        });

        var dw = tile.width - game.width;
        if (dw > 0) {
            //
            // 
            //
            var vx = -1;

            var scroll = false;
            tile.pointDown.handle(function() {
                scroll = !scroll;
            });
            tile.update.handle(function() {
                if (!scroll) {
                    return;
                }
                tile.x += vx;
                if (tile.x < -dw) {
                    tile.x = -dw;
                    vx *= -1;
                } else if (tile.x > 0) {
                    tile.x = 0;
                    vx *= -1;
                }
                tile.modified();
            });
        }
        scene.append(tile);
    });

    return scene;
}

})(g.module.exports, g.module.require, g.module, g.filename, g.dirname);
		};
	</script>

<script>
	var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var LocalScriptAsset = (function (_super) {
    __extends(LocalScriptAsset, _super);
    function LocalScriptAsset(id, path) {
        var _this = _super.call(this, id, path) || this;
        _this.func = window.gLocalAssetContainer[id]; // gLocalScriptContainer  index.ect script 
        return _this;
    }
    LocalScriptAsset.prototype._load = function (loader) {
        var _this = this;
        if (this.func !== undefined) {
            setTimeout(function () {
                loader._onAssetLoad(_this);
            }, 0);
        }
        else {
            setTimeout(function () {
                loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("can not load script asset"));
            }, 0);
        }
    };
    LocalScriptAsset.prototype.execute = function (execEnv) {
        this.func(execEnv);
        return execEnv.module.exports;
    };
    return LocalScriptAsset;
}(g.ScriptAsset));
	var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var LocalTextAsset = (function (_super) {
    __extends(LocalTextAsset, _super);
    function LocalTextAsset(id, path) {
        var _this = _super.call(this, id, path) || this;
        _this.data = decodeURIComponent(window.gLocalAssetContainer[id]);
        return _this;
    }
    LocalTextAsset.prototype._load = function (loader) {
        var _this = this;
        if (this.data !== undefined) {
            setTimeout(function () {
                loader._onAssetLoad(_this);
            }, 0);
        }
        else {
            setTimeout(function () {
                loader._onAssetError(_this, g.ExceptionFactory.createAssetLoadError("can not load text asset"));
            }, 0);
        }
    };
    return LocalTextAsset;
}(g.TextAsset));
	!function(f) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = f(); else if ("function" == typeof define && define.amd) define([], f); else {
        var g;
        g = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, 
        g.gameStorage = f();
    }
}(function() {
    return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = "function" == typeof require && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f;
                }
                var l = n[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var n = t[o][1][e];
                    return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }
            return n[o].exports;
        }
        for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
        return s;
    }({
        1: [ function(require, module, exports) {
            "use strict";
            var g = require("@akashic/akashic-engine"), validator = require("./validator"), KEY_PREFIX = "akst:", GameStorage = function() {
                function GameStorage(localStorage, metaData) {
                    this._localStorage = localStorage, this._metaData = metaData;
                }
                return GameStorage.prototype.set = function(key, value, option) {
                    validator.validateStorageKey(key), this.expandVariables(key);
                    var strKey = this.storageKeyToStringKey(key), current = this.getValue(strKey), newValue = null;
                    switch (key.region) {
                      case g.StorageRegion.Values:
                        newValue = this.createValuesValue(current, value, option);
                        break;

                      case g.StorageRegion.Counts:
                        newValue = this.createCountsValue(current, value, option);
                        break;

                      case g.StorageRegion.Scores:
                        newValue = this.createScoresValue(current, value, option);
                        break;

                      case g.StorageRegion.Slots:
                        throw new Error("Slots is not supported.");

                      default:
                        throw new Error("Unknown region.");
                    }
                    if (newValue) {
                        var finalValue = null, date = new Date();
                        finalValue = current ? {
                            data: newValue.data,
                            tag: newValue.tag,
                            createdAt: current.createdAt,
                            updatedAt: date
                        } : {
                            data: newValue.data,
                            tag: newValue.tag,
                            createdAt: date,
                            updatedAt: date
                        }, this.setValue(strKey, finalValue);
                    }
                }, GameStorage.prototype.load = function(readKeys) {
                    var _this = this, allValues = {};
                    Object.keys(this._localStorage).forEach(function(key) {
                        if (0 === key.indexOf(KEY_PREFIX)) {
                            var k = key.slice(KEY_PREFIX.length);
                            allValues[k] = _this.getValue(k);
                        }
                    });
                    var results = [];
                    return readKeys.forEach(function(readKey) {
                        validator.validateStorageReadKey(readKey), _this.expandVariables(readKey);
                        var values = [];
                        if (readKey.regionKey.indexOf("*") !== -1 || "*" === readKey.userId) {
                            var regexp = _this.storageReadKeyToRegExp(readKey);
                            Object.keys(allValues).forEach(function(key) {
                                if (regexp.test(key)) {
                                    var lv = allValues[key], sv = {
                                        data: lv.data,
                                        storageKey: _this.stringKeyToStorageKey(key)
                                    };
                                    null != lv.tag && (sv.tag = lv.tag), values.push(sv);
                                }
                            }), readKey.option && (void 0 !== readKey.option.valueOrder && _this.sortByValue(values, readKey.option.valueOrder), 
                            void 0 !== readKey.option.keyOrder && _this.sortByRegionKey(values, readKey.option.keyOrder));
                        } else {
                            var readStrKey = _this.storageKeyToStringKey(readKey), v = allValues[readStrKey];
                            if (v) {
                                var sv = {
                                    data: v.data,
                                    storageKey: {
                                        region: readKey.region,
                                        regionKey: readKey.regionKey,
                                        userId: readKey.userId,
                                        gameId: readKey.gameId
                                    }
                                };
                                null != v.tag && (sv.tag = v.tag), values.push(sv);
                            }
                        }
                        results.push(values);
                    }), results;
                }, GameStorage.prototype.clearAll = function() {
                    var _this = this;
                    Object.keys(this._localStorage).forEach(function(key) {
                        0 === key.indexOf(KEY_PREFIX) && _this._localStorage.removeItem(key);
                    });
                }, GameStorage.prototype.createValuesValue = function(current, value, option) {
                    if (!value) return null;
                    if (option && null != option.condition && null != option.comparisonValue && current && null != current.data) {
                        if (option.condition !== g.StorageCondition.Equal) throw new Error("Invalid condition.");
                        if (current.data !== option.comparisonValue) return null;
                    }
                    var result = {
                        data: value.data
                    };
                    return null != value.tag ? result.tag = value.tag : current && null != current.tag && (result.tag = current.tag), 
                    result;
                }, GameStorage.prototype.createScoresValue = function(current, value, option) {
                    if (!value) return null;
                    if (option && null != option.condition && null != option.comparisonValue && current && null != current.data) switch (option.condition) {
                      case g.StorageCondition.Equal:
                        if (current.data !== option.comparisonValue) return null;
                        break;

                      case g.StorageCondition.GreaterThan:
                        if (!(current.data > option.comparisonValue)) return null;
                        break;

                      case g.StorageCondition.LessThan:
                        if (!(current.data < option.comparisonValue)) return null;
                    }
                    var result = {
                        data: value.data
                    };
                    return null != value.tag ? result.tag = value.tag : current && null != current.tag && (result.tag = current.tag), 
                    result;
                }, GameStorage.prototype.createCountsIncrDecrValue = function(current, value, option) {
                    var result = {
                        data: 0
                    }, currentCount = 0;
                    if (current && (currentCount = Number(current.data)), null != option.condition && null != option.comparisonValue) switch (option.condition) {
                      case g.StorageCondition.Equal:
                        if (currentCount !== option.comparisonValue) return current ? null : result;
                        break;

                      case g.StorageCondition.GreaterThan:
                        if (!(currentCount > option.comparisonValue)) return current ? null : result;
                        break;

                      case g.StorageCondition.LessThan:
                        if (!(currentCount < option.comparisonValue)) return current ? null : result;
                    }
                    if (option.operation === g.StorageCountsOperation.Incr) value && null != value.data ? result.data = currentCount + Number(value.data) : result.data = currentCount + 1; else {
                        if (option.operation !== g.StorageCountsOperation.Decr) throw new Error("Unknown StorageCountsOperation");
                        value && null != value.data ? result.data = currentCount - Number(value.data) : result.data = currentCount - 1;
                    }
                    return value && null != value.tag ? result.tag = value.tag : current && null != current.tag && (result.tag = current.tag), 
                    result;
                }, GameStorage.prototype.createCountsValue = function(current, value, option) {
                    if (option) {
                        if (option.operation === g.StorageCountsOperation.Incr || option.operation === g.StorageCountsOperation.Decr) return this.createCountsIncrDecrValue(current, value, option);
                        if (null != option.condition && null != option.comparisonValue && current && null != current.data) switch (option.condition) {
                          case g.StorageCondition.Equal:
                            if (current.data !== option.comparisonValue) return null;
                            break;

                          case g.StorageCondition.GreaterThan:
                            if (!(current.data > option.comparisonValue)) return null;
                            break;

                          case g.StorageCondition.LessThan:
                            if (!(current.data < option.comparisonValue)) return null;
                        }
                    }
                    var result = {
                        data: value.data
                    };
                    return value && null != value.tag ? result.tag = value.tag : current && null != current.tag && (result.tag = current.tag), 
                    result;
                }, GameStorage.prototype.setValue = function(key, value) {
                    this._localStorage.setItem("" + KEY_PREFIX + key, JSON.stringify(value));
                }, GameStorage.prototype.getValue = function(key) {
                    var v = JSON.parse(this._localStorage.getItem("" + KEY_PREFIX + key));
                    return v;
                }, GameStorage.prototype.storageKeyToStringKey = function(key) {
                    var region = key.region || "", gameId = null != key.gameId ? String(key.gameId) : "", userId = null != key.userId ? String(key.userId) : "", regionKey = key.regionKey || "";
                    return region + "/" + gameId + "/" + userId + "/" + regionKey;
                }, GameStorage.prototype.stringKeyToStorageKey = function(key) {
                    var s = key.split("/"), res = {
                        region: Number(s[0]),
                        regionKey: s[3]
                    };
                    return s[1] && (res.gameId = s[1]), s[2] && (res.userId = s[2]), res;
                }, GameStorage.prototype.storageReadKeyToRegExp = function(key) {
                    var region = key.region || "", gameId = null != key.gameId ? String(key.gameId) : "", userId = null != key.userId ? String(key.userId) : "", regionKey = "";
                    if ("*" === userId && (userId = "[0-9]+"), key.regionKey.indexOf("*") !== -1) {
                        var layerKeys = key.regionKey.split(".");
                        layerKeys.forEach(function(layerKey, index) {
                            regionKey += "*" === layerKey ? "[.a-z0-9]*" : layerKey.indexOf("*") !== -1 ? layerKey.replace("*", "[a-z0-9]*") : layerKey, 
                            index !== layerKeys.length - 1 && (regionKey += ".");
                        });
                    } else regionKey = key.regionKey.replace(".", ".");
                    return new RegExp("^" + region + "/" + gameId + "/" + userId + "/" + regionKey + "$");
                }, GameStorage.prototype.sortByValue = function(values, order) {
                    values.sort(function(a, b) {
                        var va = a.data, vb = b.data;
                        if (order === g.StorageOrder.Asc) {
                            if (va < vb) return -1;
                            if (va > vb) return 1;
                        } else if (order === g.StorageOrder.Desc) {
                            if (va < vb) return 1;
                            if (va > vb) return -1;
                        }
                        return 0;
                    });
                }, GameStorage.prototype.sortByRegionKey = function(values, order) {
                    values.sort(function(a, b) {
                        var ka = a.storageKey.regionKey, kb = b.storageKey.regionKey;
                        if (order === g.StorageOrder.Asc) {
                            if (ka < kb) return -1;
                            if (ka > kb) return 1;
                        } else if (order === g.StorageOrder.Desc) {
                            if (ka < kb) return 1;
                            if (ka > kb) return -1;
                        }
                        return 0;
                    });
                }, GameStorage.prototype.expandVariables = function(key) {
                    key.gameId && key.gameId.indexOf("$gameId") !== -1 && this._metaData.gameId && (key.gameId = key.gameId.replace(/\$gameId/g, this._metaData.gameId));
                }, GameStorage;
            }();
            exports.GameStorage = GameStorage;
        }, {
            "./validator": 3,
            "@akashic/akashic-engine": "@akashic/akashic-engine"
        } ],
        2: [ function(require, module, exports) {
            "use strict";
            var gs = require("./GameStorage");
            exports.GameStorage = gs.GameStorage;
        }, {
            "./GameStorage": 1
        } ],
        3: [ function(require, module, exports) {
            "use strict";
            function validateRegionKey(regionKey, forReading) {
                assert(regionKey.length > 0, "regionKey is empty.");
                var layerKeys = regionKey.split(".");
                assert(layerKeys.length <= REGIONKEY_MAX_LAYER_NUM, "The maximum number of layers in the region key is " + REGIONKEY_MAX_LAYER_NUM + ".");
                for (var hasWildcard = !1, i = 0; i < layerKeys.length; ++i) forReading ? "*" === layerKeys[i] ? (assert(!hasWildcard, "The only one layer of the region key for reading consists of a wildcard character."), 
                hasWildcard = !0) : assert(/^(\*|[a-z])[a-z0-9]{0,31}\*?$/.test(layerKeys[i]), "The layer of the region key for reading must match '^(*|[a-z])[a-z0-9]{0,31}*?$'.") : assert(/^[a-z][a-z0-9]{0,31}$/.test(layerKeys[i]), "The layer of the region key for writing must match '^[a-z][a-z0-9]{0,31}$'.");
            }
            function validateStorageKey(key, forReading) {
                void 0 === forReading && (forReading = !1), assert(key.region === g.StorageRegion.Counts || key.region === g.StorageRegion.Scores || key.region === g.StorageRegion.Values, "Invalid region."), 
                assert(key.regionKey, "regionKey must be set."), validateRegionKey(key.regionKey, forReading), 
                assert(key.gameId || key.userId, "StorageKey must have any one at least from gameId and userId."), 
                null != key.gameId && (assert.equal(typeof key.gameId, "string", "gameId must be a string type."), 
                assert(key.gameId.length > 0, "gameId is empty.")), null != key.userId && (assert.equal(typeof key.userId, "string", "userId must be a string type."), 
                assert(key.userId.length > 0, "userId is empty."), forReading ? "*" === key.userId && (assert(key.gameId, 'gameId for reading must be set when userId is "*".'), 
                assert(key.regionKey.indexOf("*") === -1, 'regionKey for reading must not include "*" when userId is "*".')) : assert("*" !== key.userId, 'userId for writing must not include "*".'));
            }
            function validateStorageReadKey(key) {
                if (validateStorageKey(key, !0), null != key.option) {
                    var opt = key.option;
                    null != opt.keyOrder && assert(opt.keyOrder === g.StorageOrder.Asc || opt.keyOrder === g.StorageOrder.Desc, "Invalid keyOrder."), 
                    null != opt.valueOrder && assert(opt.valueOrder === g.StorageOrder.Asc || opt.valueOrder === g.StorageOrder.Desc, "Invalid valueOrder.");
                }
            }
            function validateStorageWriteOption(option) {}
            var assert = require("assert"), g = require("@akashic/akashic-engine"), REGIONKEY_MAX_LAYER_NUM = 4;
            exports.validateRegionKey = validateRegionKey, exports.validateStorageKey = validateStorageKey, 
            exports.validateStorageReadKey = validateStorageReadKey, exports.validateStorageWriteOption = validateStorageWriteOption;
        }, {
            "@akashic/akashic-engine": "@akashic/akashic-engine",
            assert: 4
        } ],
        4: [ function(require, module, exports) {
            (function(global) {
                "use strict";
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
                function compare(a, b) {
                    if (a === b) return 0;
                    for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
                        x = a[i], y = b[i];
                        break;
                    }
                    return x < y ? -1 : y < x ? 1 : 0;
                }
                function isBuffer(b) {
                    return global.Buffer && "function" == typeof global.Buffer.isBuffer ? global.Buffer.isBuffer(b) : !(null == b || !b._isBuffer);
                }
                function pToString(obj) {
                    return Object.prototype.toString.call(obj);
                }
                function isView(arrbuf) {
                    return !isBuffer(arrbuf) && ("function" == typeof global.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(arrbuf) : !!arrbuf && (arrbuf instanceof DataView || !!(arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer))));
                }
                function getName(func) {
                    if (util.isFunction(func)) {
                        if (functionsHaveNames) return func.name;
                        var str = func.toString(), match = str.match(regex);
                        return match && match[1];
                    }
                }
                function truncate(s, n) {
                    return "string" == typeof s ? s.length < n ? s : s.slice(0, n) : s;
                }
                function inspect(something) {
                    if (functionsHaveNames || !util.isFunction(something)) return util.inspect(something);
                    var rawname = getName(something), name = rawname ? ": " + rawname : "";
                    return "[Function" + name + "]";
                }
                function getMessage(self) {
                    return truncate(inspect(self.actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128);
                }
                function fail(actual, expected, message, operator, stackStartFunction) {
                    throw new assert.AssertionError({
                        message: message,
                        actual: actual,
                        expected: expected,
                        operator: operator,
                        stackStartFunction: stackStartFunction
                    });
                }
                function ok(value, message) {
                    value || fail(value, !0, message, "==", assert.ok);
                }
                function _deepEqual(actual, expected, strict, memos) {
                    if (actual === expected) return !0;
                    if (isBuffer(actual) && isBuffer(expected)) return 0 === compare(actual, expected);
                    if (util.isDate(actual) && util.isDate(expected)) return actual.getTime() === expected.getTime();
                    if (util.isRegExp(actual) && util.isRegExp(expected)) return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
                    if (null !== actual && "object" == typeof actual || null !== expected && "object" == typeof expected) {
                        if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) return 0 === compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer));
                        if (isBuffer(actual) !== isBuffer(expected)) return !1;
                        memos = memos || {
                            actual: [],
                            expected: []
                        };
                        var actualIndex = memos.actual.indexOf(actual);
                        return actualIndex !== -1 && actualIndex === memos.expected.indexOf(expected) || (memos.actual.push(actual), 
                        memos.expected.push(expected), objEquiv(actual, expected, strict, memos));
                    }
                    return strict ? actual === expected : actual == expected;
                }
                function isArguments(object) {
                    return "[object Arguments]" == Object.prototype.toString.call(object);
                }
                function objEquiv(a, b, strict, actualVisitedObjects) {
                    if (null === a || void 0 === a || null === b || void 0 === b) return !1;
                    if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
                    if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return !1;
                    var aIsArgs = isArguments(a), bIsArgs = isArguments(b);
                    if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return !1;
                    if (aIsArgs) return a = pSlice.call(a), b = pSlice.call(b), _deepEqual(a, b, strict);
                    var key, i, ka = objectKeys(a), kb = objectKeys(b);
                    if (ka.length !== kb.length) return !1;
                    for (ka.sort(), kb.sort(), i = ka.length - 1; i >= 0; i--) if (ka[i] !== kb[i]) return !1;
                    for (i = ka.length - 1; i >= 0; i--) if (key = ka[i], !_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return !1;
                    return !0;
                }
                function notDeepStrictEqual(actual, expected, message) {
                    _deepEqual(actual, expected, !0) && fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
                }
                function expectedException(actual, expected) {
                    if (!actual || !expected) return !1;
                    if ("[object RegExp]" == Object.prototype.toString.call(expected)) return expected.test(actual);
                    try {
                        if (actual instanceof expected) return !0;
                    } catch (e) {}
                    return !Error.isPrototypeOf(expected) && expected.call({}, actual) === !0;
                }
                function _tryBlock(block) {
                    var error;
                    try {
                        block();
                    } catch (e) {
                        error = e;
                    }
                    return error;
                }
                function _throws(shouldThrow, block, expected, message) {
                    var actual;
                    if ("function" != typeof block) throw new TypeError('"block" argument must be a function');
                    "string" == typeof expected && (message = expected, expected = null), actual = _tryBlock(block), 
                    message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : "."), 
                    shouldThrow && !actual && fail(actual, expected, "Missing expected exception" + message);
                    var userProvidedMessage = "string" == typeof message, isUnwantedException = !shouldThrow && util.isError(actual), isUnexpectedException = !shouldThrow && actual && !expected;
                    if ((isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) && fail(actual, expected, "Got unwanted exception" + message), 
                    shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) throw actual;
                }
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                var util = require("util/"), hasOwn = Object.prototype.hasOwnProperty, pSlice = Array.prototype.slice, functionsHaveNames = function() {
                    return "foo" === function() {}.name;
                }(), assert = module.exports = ok, regex = /\s*function\s+([^\(\s]*)\s*/;
                assert.AssertionError = function(options) {
                    this.name = "AssertionError", this.actual = options.actual, this.expected = options.expected, 
                    this.operator = options.operator, options.message ? (this.message = options.message, 
                    this.generatedMessage = !1) : (this.message = getMessage(this), this.generatedMessage = !0);
                    var stackStartFunction = options.stackStartFunction || fail;
                    if (Error.captureStackTrace) Error.captureStackTrace(this, stackStartFunction); else {
                        var err = new Error();
                        if (err.stack) {
                            var out = err.stack, fn_name = getName(stackStartFunction), idx = out.indexOf("\n" + fn_name);
                            if (idx >= 0) {
                                var next_line = out.indexOf("\n", idx + 1);
                                out = out.substring(next_line + 1);
                            }
                            this.stack = out;
                        }
                    }
                }, util.inherits(assert.AssertionError, Error), assert.fail = fail, assert.ok = ok, 
                assert.equal = function(actual, expected, message) {
                    actual != expected && fail(actual, expected, message, "==", assert.equal);
                }, assert.notEqual = function(actual, expected, message) {
                    actual == expected && fail(actual, expected, message, "!=", assert.notEqual);
                }, assert.deepEqual = function(actual, expected, message) {
                    _deepEqual(actual, expected, !1) || fail(actual, expected, message, "deepEqual", assert.deepEqual);
                }, assert.deepStrictEqual = function(actual, expected, message) {
                    _deepEqual(actual, expected, !0) || fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
                }, assert.notDeepEqual = function(actual, expected, message) {
                    _deepEqual(actual, expected, !1) && fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
                }, assert.notDeepStrictEqual = notDeepStrictEqual, assert.strictEqual = function(actual, expected, message) {
                    actual !== expected && fail(actual, expected, message, "===", assert.strictEqual);
                }, assert.notStrictEqual = function(actual, expected, message) {
                    actual === expected && fail(actual, expected, message, "!==", assert.notStrictEqual);
                }, assert.throws = function(block, error, message) {
                    _throws(!0, block, error, message);
                }, assert.doesNotThrow = function(block, error, message) {
                    _throws(!1, block, error, message);
                }, assert.ifError = function(err) {
                    if (err) throw err;
                };
                var objectKeys = Object.keys || function(obj) {
                    var keys = [];
                    for (var key in obj) hasOwn.call(obj, key) && keys.push(key);
                    return keys;
                };
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {
            "util/": 8
        } ],
        5: [ function(require, module, exports) {
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
                setTimeout(fun, 0);
                try {
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }
            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
                clearTimeout(marker);
                try {
                    return cachedClearTimeout(marker);
                } catch (e) {
                    try {
                        return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                        return cachedClearTimeout.call(this, marker);
                    }
                }
            }
            function cleanUpNextTick() {
                draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
                queue.length && drainQueue());
            }
            function drainQueue() {
                if (!draining) {
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = !0;
                    for (var len = queue.length; len; ) {
                        for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                        queueIndex = -1, len = queue.length;
                    }
                    currentQueue = null, draining = !1, runClearTimeout(timeout);
                }
            }
            function Item(fun, array) {
                this.fun = fun, this.array = array;
            }
            function noop() {}
            var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
            !function() {
                try {
                    cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }();
            var currentQueue, queue = [], draining = !1, queueIndex = -1;
            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
                queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
            }, Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
            process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
            process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
            process.emit = noop, process.binding = function(name) {
                throw new Error("process.binding is not supported");
            }, process.cwd = function() {
                return "/";
            }, process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
            }, process.umask = function() {
                return 0;
            };
        }, {} ],
        6: [ function(require, module, exports) {
            "function" == typeof Object.create ? module.exports = function(ctor, superCtor) {
                ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                });
            } : module.exports = function(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
            };
        }, {} ],
        7: [ function(require, module, exports) {
            module.exports = function(arg) {
                return arg && "object" == typeof arg && "function" == typeof arg.copy && "function" == typeof arg.fill && "function" == typeof arg.readUInt8;
            };
        }, {} ],
        8: [ function(require, module, exports) {
            (function(process, global) {
                function inspect(obj, opts) {
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), 
                    isBoolean(opts) ? ctx.showHidden = opts : opts && exports._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), 
                    isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), 
                    isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), 
                    formatValue(ctx, obj, ctx.depth);
                }
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    return style ? "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m" : str;
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    return array.forEach(function(val, idx) {
                        hash[val] = !0;
                    }), hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && (!value.constructor || value.constructor.prototype !== value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;
                    }
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) return primitive;
                    var keys = Object.keys(value), visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)), isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError(value);
                    if (0 === keys.length) {
                        if (isFunction(value)) {
                            var name = value.name ? ": " + value.name : "";
                            return ctx.stylize("[Function" + name + "]", "special");
                        }
                        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
                        if (isError(value)) return formatError(value);
                    }
                    var base = "", array = !1, braces = [ "{", "}" ];
                    if (isArray(value) && (array = !0, braces = [ "[", "]" ]), isFunction(value)) {
                        var n = value.name ? ": " + value.name : "";
                        base = " [Function" + n + "]";
                    }
                    if (isRegExp(value) && (base = " " + RegExp.prototype.toString.call(value)), isDate(value) && (base = " " + Date.prototype.toUTCString.call(value)), 
                    isError(value) && (base = " " + formatError(value)), 0 === keys.length && (!array || 0 == value.length)) return braces[0] + base + braces[1];
                    if (recurseTimes < 0) return isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special");
                    ctx.seen.push(value);
                    var output;
                    return output = array ? formatArray(ctx, value, recurseTimes, visibleKeys, keys) : keys.map(function(key) {
                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                    }), ctx.seen.pop(), reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                    if (isString(value)) {
                        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return ctx.stylize(simple, "string");
                    }
                    return isNumber(value) ? ctx.stylize("" + value, "number") : isBoolean(value) ? ctx.stylize("" + value, "boolean") : isNull(value) ? ctx.stylize("null", "null") : void 0;
                }
                function formatError(value) {
                    return "[" + Error.prototype.toString.call(value) + "]";
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    for (var output = [], i = 0, l = value.length; i < l; ++i) hasOwnProperty(value, String(i)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0)) : output.push("");
                    return keys.forEach(function(key) {
                        key.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));
                    }), output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    if (desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    }, desc.get ? str = desc.set ? ctx.stylize("[Getter/Setter]", "special") : ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), 
                    hasOwnProperty(visibleKeys, key) || (name = "[" + key + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? (str = isNull(recurseTimes) ? formatValue(ctx, desc.value, null) : formatValue(ctx, desc.value, recurseTimes - 1), 
                    str.indexOf("\n") > -1 && (str = array ? str.split("\n").map(function(line) {
                        return "  " + line;
                    }).join("\n").substr(2) : "\n" + str.split("\n").map(function(line) {
                        return "   " + line;
                    }).join("\n"))) : str = ctx.stylize("[Circular]", "special")), isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) return str;
                        name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), 
                        name = ctx.stylize(name, "name")) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), 
                        name = ctx.stylize(name, "string"));
                    }
                    return name + ": " + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0, length = output.reduce(function(prev, cur) {
                        return numLinesEst++, cur.indexOf("\n") >= 0 && numLinesEst++, prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0);
                    return length > 60 ? braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1] : braces[0] + base + " " + output.join(", ") + " " + braces[1];
                }
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                function isBoolean(arg) {
                    return "boolean" == typeof arg;
                }
                function isNull(arg) {
                    return null === arg;
                }
                function isNullOrUndefined(arg) {
                    return null == arg;
                }
                function isNumber(arg) {
                    return "number" == typeof arg;
                }
                function isString(arg) {
                    return "string" == typeof arg;
                }
                function isSymbol(arg) {
                    return "symbol" == typeof arg;
                }
                function isUndefined(arg) {
                    return void 0 === arg;
                }
                function isRegExp(re) {
                    return isObject(re) && "[object RegExp]" === objectToString(re);
                }
                function isObject(arg) {
                    return "object" == typeof arg && null !== arg;
                }
                function isDate(d) {
                    return isObject(d) && "[object Date]" === objectToString(d);
                }
                function isError(e) {
                    return isObject(e) && ("[object Error]" === objectToString(e) || e instanceof Error);
                }
                function isFunction(arg) {
                    return "function" == typeof arg;
                }
                function isPrimitive(arg) {
                    return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || "undefined" == typeof arg;
                }
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? "0" + n.toString(10) : n.toString(10);
                }
                function timestamp() {
                    var d = new Date(), time = [ pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds()) ].join(":");
                    return [ d.getDate(), months[d.getMonth()], time ].join(" ");
                }
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var formatRegExp = /%[sdj%]/g;
                exports.format = function(f) {
                    if (!isString(f)) {
                        for (var objects = [], i = 0; i < arguments.length; i++) objects.push(inspect(arguments[i]));
                        return objects.join(" ");
                    }
                    for (var i = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x) {
                        if ("%%" === x) return "%";
                        if (i >= len) return x;
                        switch (x) {
                          case "%s":
                            return String(args[i++]);

                          case "%d":
                            return Number(args[i++]);

                          case "%j":
                            try {
                                return JSON.stringify(args[i++]);
                            } catch (_) {
                                return "[Circular]";
                            }

                          default:
                            return x;
                        }
                    }), x = args[i]; i < len; x = args[++i]) str += isNull(x) || !isObject(x) ? " " + x : " " + inspect(x);
                    return str;
                }, exports.deprecate = function(fn, msg) {
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) throw new Error(msg);
                            process.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0;
                        }
                        return fn.apply(this, arguments);
                    }
                    if (isUndefined(global.process)) return function() {
                        return exports.deprecate(fn, msg).apply(this, arguments);
                    };
                    if (process.noDeprecation === !0) return fn;
                    var warned = !1;
                    return deprecated;
                };
                var debugEnviron, debugs = {};
                exports.debuglog = function(set) {
                    if (isUndefined(debugEnviron) && (debugEnviron = process.env.NODE_DEBUG || ""), 
                    set = set.toUpperCase(), !debugs[set]) if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                        var pid = process.pid;
                        debugs[set] = function() {
                            var msg = exports.format.apply(exports, arguments);
                            console.error("%s %d: %s", set, pid, msg);
                        };
                    } else debugs[set] = function() {};
                    return debugs[set];
                }, exports.inspect = inspect, inspect.colors = {
                    bold: [ 1, 22 ],
                    italic: [ 3, 23 ],
                    underline: [ 4, 24 ],
                    inverse: [ 7, 27 ],
                    white: [ 37, 39 ],
                    grey: [ 90, 39 ],
                    black: [ 30, 39 ],
                    blue: [ 34, 39 ],
                    cyan: [ 36, 39 ],
                    green: [ 32, 39 ],
                    magenta: [ 35, 39 ],
                    red: [ 31, 39 ],
                    yellow: [ 33, 39 ]
                }, inspect.styles = {
                    special: "cyan",
                    number: "yellow",
                    boolean: "yellow",
                    undefined: "grey",
                    null: "bold",
                    string: "green",
                    date: "magenta",
                    regexp: "red"
                }, exports.isArray = isArray, exports.isBoolean = isBoolean, exports.isNull = isNull, 
                exports.isNullOrUndefined = isNullOrUndefined, exports.isNumber = isNumber, exports.isString = isString, 
                exports.isSymbol = isSymbol, exports.isUndefined = isUndefined, exports.isRegExp = isRegExp, 
                exports.isObject = isObject, exports.isDate = isDate, exports.isError = isError, 
                exports.isFunction = isFunction, exports.isPrimitive = isPrimitive, exports.isBuffer = require("./support/isBuffer");
                var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
                exports.log = function() {
                    console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
                }, exports.inherits = require("inherits"), exports._extend = function(origin, add) {
                    if (!add || !isObject(add)) return origin;
                    for (var keys = Object.keys(add), i = keys.length; i--; ) origin[keys[i]] = add[keys[i]];
                    return origin;
                };
            }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {
            "./support/isBuffer": 7,
            _process: 5,
            inherits: 6
        } ]
    }, {}, [ 2 ])(2);
});	function enableLogger(game) {
	if (! "console" in window) {
		// polyfill
		window.console = {
			log: function(x) {
			},
			error: function(x) {
			},
			info: function(x) {
			},
			warn: function(x) {
			}
		};
	}
	var logLevel = g.LogLevel.Debug;
	var loggerMap = {};
	loggerMap[g.LogLevel.Debug] = console.log;
	loggerMap[g.LogLevel.Warn] = console.warn;
	loggerMap[g.LogLevel.Info] = console.info;
	loggerMap[g.LogLevel.Error] = console.error;
	function onLogging(log) {
		if (log.level > logLevel) return;
		var prefix = log.level in g.LogLevel ? "[" + g.LogLevel[log.level].toUpperCase() + "]\t" : "";
		var method = loggerMap[log.level] ? loggerMap[log.level] : console.log;
		method.call(console, prefix + log.message);
		if (log.cause)
			method.call(console, log.cause);
	}
	game.logger.logging.handle(onLogging);
}
	window.addEventListener("load", function() {

	start("exportHTML");

	function start(gamePath) {
		// TODO WebGL
		// // webgl=1RendererWebGL
		// if (getParameterByName("webgl")) {
		// 	conf.renderers = ["webgl"];
		// }

		// gameIdBIGINTexport htmlgamePath
		var sandboxGameId = gamePath;
		var sandboxPlayer = { id: "9999", name: "sandbox-player" };
		var sandboxPlayId = "sandboxDummyPlayId";
		var storage = new gameStorage.GameStorage(window.localStorage, { gameId: sandboxGameId });

		var pdiBrowser = require("@akashic/pdi-browser");
		var gdr = require("@akashic/game-driver");

		var amflowClient = new gdr.MemoryAmflowClient({
			playId: sandboxPlayId,
			putStorageDataSyncFunc: storage.set.bind(storage),
			getStorageDataSyncFunc: function (readKeys) {
				var svs = storage.load(readKeys);
				// StorageValue[][]StorageData[]
				// TODO: StorageValue[][]game-storage
				return readKeys.map(function (k, i) { return { readKey: k, values: svs[i] }; });
			}
		});

		var pf = new pdiBrowser.Platform({
			amflow: amflowClient,
			containerView: document.getElementById("container"),
			audioPlugins: [pdiBrowser.HTMLAudioPlugin],
		});

		pf.loadGameConfiguration = function(url, callback) {
			try {
				var gameJsonText = window.gLocalAssetContainer["game.json"];
				gameJsonText = decodeURIComponent(gameJsonText);
				callback(null, JSON.parse(gameJsonText));
			} catch(error) {
				callback(error, null);
			}
		};

		pf._resourceFactory.createScriptAsset = function(id, assetPath) {
			return new LocalScriptAsset(id, assetPath);
		};

		pf._resourceFactory.createTextAsset = function(id, assetPath) {
			return new LocalTextAsset(id, assetPath);
		};

		driver = new gdr.GameDriver({
			platform: pf,
			player: sandboxPlayer,
			errorHandler: function (e) { console.log("ERRORHANDLER:", e); }
		});

		driver.gameCreatedTrigger.handle(function () {
			if (window.optionProps.magnify) pf.fitToWindow(true);
		});

		driver.initialize({
			configurationUrl: "game.json",
			assetBase: "./",
			driverConfiguration: {
				playId: sandboxPlayId,
				playToken: "dummyToken",
				executionMode: gdr.ExecutionMode.Active
			},
			loopConfiguration: {
				loopMode: gdr.LoopMode.Realtime
			}
		}, function (e) {
			if (e) {
				throw e;
			}
			driver.startGame();
		});
	}
});
	window.g = require("@akashic/akashic-engine");

if (! ("gLocalAssetContainer" in window)) {
	window.gLocalAssetContainer = {};
}
</script>
<link rel="stylesheet" href="../common-demo.css">
</head>
<body>
<div id="container"></div>
</body>
</html>