"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Collider = require("./Collider");
var BoxVolume = require("./BoxVolume");
function multiply(m1, m2) {
    var m10 = m1[0];
    var m11 = m1[1];
    var m12 = m1[2];
    var m13 = m1[3];
    m1[0] = m10 * m2[0] + m12 * m2[1];
    m1[1] = m11 * m2[0] + m13 * m2[1];
    m1[2] = m10 * m2[2] + m12 * m2[3];
    m1[3] = m11 * m2[2] + m13 * m2[3];
    m1[4] = m10 * m2[4] + m12 * m2[5] + m1[4];
    m1[5] = m11 * m2[4] + m13 * m2[5] + m1[5];
}
/**
 * CellAttachmentをアタリ判定に用いるコライダー
 */
var CellAttachmentCollider = (function (_super) {
    __extends(CellAttachmentCollider, _super);
    function CellAttachmentCollider(cellAttachment, name, aabbFirst) {
        var _this = _super.call(this, aabbFirst) || this;
        _this.name = name;
        _this.dirty = true;
        _this.cellAttachment = cellAttachment;
        return _this;
    }
    CellAttachmentCollider.prototype.getVolume = function () {
        if (!this.enabled || !this.cellAttachment || !this.cellAttachment.posture) {
            return undefined;
        }
        if (this.dirty) {
            this.dirty = false;
            if (!this._volume) {
                // 以下は静的な値であるとみなす
                this._volume = new BoxVolume();
                this._volume.matrix = new g.PlainMatrix();
                this._volume.origin.x = 0;
                this._volume.origin.y = 0;
                this._volume.size.width = this.cellAttachment.cell.size.width;
                this._volume.size.height = this.cellAttachment.cell.size.height;
            }
            this._volume.aabbFirst = this.aabbFirst;
            var m = [].concat(this.cellAttachment.posture.m._matrix);
            if (this.cellAttachment.matrix) {
                multiply(m, this.cellAttachment.matrix._matrix);
            }
            if (this.cellAttachment.pivotTransform) {
                multiply(m, this.cellAttachment.pivotTransform);
            }
            // 矩形の位置を変えない鏡像のマトリクスなので無用
            // multiply(m, this.cellAttachment.mirrorTransform);
            this._volume.matrix._matrix = m;
            this._volume.dirty = true; // trigger to update aabb
        }
        return this._volume;
    };
    return CellAttachmentCollider;
}(Collider));
module.exports = CellAttachmentCollider;
