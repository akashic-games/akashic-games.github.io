"use strict";
var Posture = require("./Posture");
var AttrId = require("./AttrId");
var AnimeParams_1 = require("./AnimeParams");
// 属性初期値テーブル
//
// akashic-animationの扱える属性の一覧でもある
// ここに無いものにアクセスすると undefined となる
// ss2asa の SpriteStudio.ts にも扱える属性に関するテーブルが存在する
// 機能を追加する際は両方に食い違いがないようにすること
var attributeInitialValues = {
    tx: 0,
    ty: 0,
    rz: 0,
    sx: 1.0,
    sy: 1.0,
    alpha: 1.0,
    cv: undefined,
    pvtx: 1.0,
    pvty: 1.0,
    tu: 1.0,
    tv: 1.0,
    prio: 0,
    visibility: true,
    ccr: 0.0,
    flipH: false,
    flipV: false,
    userData: undefined
};
function makeLinearKey(time, value) {
    var r = new AnimeParams_1.KeyFrame();
    r.time = time;
    r.value = value;
    r.ipType = "linear";
    r.ipCurve = undefined;
    return r;
}
function makeLastKey(time, value) {
    var r = new AnimeParams_1.KeyFrame();
    r.time = time;
    r.value = value;
    r.ipType = undefined;
    r.ipCurve = undefined;
    return r;
}
function makeDefaultKey(attribute) {
    var r = new AnimeParams_1.KeyFrame();
    r.time = 0;
    r.value = attributeInitialValues[attribute];
    r.ipType = undefined; // no interpolation
    r.ipCurve = undefined;
    return r;
}
/*
 * 与えられた時刻に関係する２つのキーを取り出す
 *
 * アニメーションから値を導くには２つのキーが必要になる
 *
 * ２つのキーが得られない状況
 * 1. 最初のキーが（ゼロでなく）１フレーム目以降に打たれている
 * 2. 最後のキーが最終フレームより前に打たれている
 *
 * それぞれ次のように扱う
 * 1. 初期値を持ったキーが０フレーム目に打たれているとみなす
 * 2. 最後のキーと全く同じものが最終フレームにも打たれているとみなす
 *
 * そのようにキーが外挿される
 *
 * 返り値: 以下の２要素の配列
 * 1. 開始キー
 * 2. 終了キー
 *
 * @param keyFrames キーフレーム配列
 * @param time 現在時刻
 * @param frameCount keyFramesを格納するAnimationの定義するアニメーション全体の長さ（時間）
 * @param attribute この関数の返すキーフレームペアを用いる属性
 */
function pickKeyFramePairByTime(keyFrames, time, frameCount, attribute) {
    var kFrom = undefined;
    var kTo = undefined;
    // ループアニメーション用の処理
    // ループアニメーションではこの区間が存在する。この時キーを補う
    if (frameCount - 1 < time && time < frameCount) {
        kFrom = makeLinearKey(frameCount - 1, keyFrames[keyFrames.length - 1].value); // 外挿
        kTo = makeLinearKey(frameCount, keyFrames[0].value); // 外挿
        return [kFrom, kTo];
    }
    if (time < keyFrames[0].time) {
        kFrom = makeDefaultKey(attribute); // 外挿
        kTo = keyFrames[0];
        // kFromは"補間なし"設定。結果この区間ではkFrom.valueが採用される
        return [kFrom, kTo];
    }
    for (var k = 1; k < keyFrames.length; k++) {
        if (time < keyFrames[k].time) {
            kTo = keyFrames[k];
            kFrom = keyFrames[k - 1];
            return [kFrom, kTo];
        }
    }
    kFrom = keyFrames[keyFrames.length - 1];
    kTo = makeLastKey(frameCount - 1, kFrom.value); // 外挿
    return [kFrom, kTo];
}
function interpolateLinear(kFrom, kTo, time) {
    var t = (time - kFrom.time) / (kTo.time - kFrom.time);
    return kFrom.value * (1 - t) + kTo.value * t;
}
// kFrom.time, kTo.timeをベジェ補間した結果 key.time === time となるような 媒介変数を逆算する
// SSに倣った
// https://github.com/SpriteStudio/SpriteStudio5-SDK/blob/master/Common/Loader/ssInterpolation.cpp#L52
function calcBackParameter(kFrom, kTo, time) {
    // ２分探索。探索回数次第で精度が決まる.
    // 探索回数８はSpriteStudioに従った
    // 30FPSから考えると、８回なら誤差は1フレーム(0.033sec)に満たない
    var t = 0.5;
    var stride = 0.25;
    var values = kFrom.ipCurve.values;
    var p1 = kFrom.time;
    var p2 = kFrom.time + values[0];
    var p3 = kTo.time + values[2];
    var p4 = kTo.time;
    for (var i = 0; i < 8; i = (i + 1) | 0) {
        var s = 1 - t;
        var s2 = s * s;
        var t2 = t * t;
        var interpolated = s * s2 * p1 +
            3 * t * s2 * p2 +
            3 * s * t2 * p3 +
            t * t2 * p4;
        if (interpolated > time) {
            t -= stride;
        }
        else {
            t += stride;
        }
        stride /= 2;
    }
    return t;
}
function interpolateBezier(kFrom, kTo, time) {
    var t = calcBackParameter(kFrom, kTo, time);
    var values = kFrom.ipCurve.values;
    var s = 1 - t;
    var s2 = s * s;
    var t2 = t * t;
    return (s * s2 * kFrom.value +
        3 * t * s2 * (kFrom.value + values[1]) +
        3 * s * t2 * (kTo.value + values[3]) +
        t * t2 * kTo.value);
}
// see: https://github.com/SpriteStudio/SpriteStudio5-SDK/blob/master/Common/Loader/ssInterpolation.cpp#L112
function interpolateHermite(kFrom, kTo, time) {
    var t = (time - kFrom.time) / (kTo.time - kFrom.time);
    var values = kFrom.ipCurve.values;
    var from = kFrom.value;
    var to = kTo.value;
    var t2 = t * t;
    var t3 = t2 * t;
    return ((2 * t3 - 3 * t2 + 1) * from +
        (-2 * t3 + 3 * t2) * to +
        (t3 - 2 * t2 + t) * (values[1] - from) +
        (t3 - t2) * (values[3] - to));
}
// SSの実装は次の通り
// https://github.com/SpriteStudio/SpriteStudio5-SDK/blob/master/Common/Animator/ssplayer_animedecode.cpp
// https://github.com/SpriteStudio/SpriteStudio5-SDK/blob/master/Common/Loader/ssInterpolation.cpp
function interpolate(kFrom, kTo, time) {
    // 非numberの補間は最初のキーの値を採用する（ステップ関数）
    // ipType===undefinedは「補間しない」を表す有効な値である
    // ２つのキーが同時刻を指すとき最初のキーの値を採用する
    if (typeof kFrom.value !== "number" || typeof kFrom.ipType === "undefined" || kFrom.time === kTo.time) {
        return kFrom.value;
    }
    else {
        switch (kFrom.ipType) {
            case "linear": return interpolateLinear(kFrom, kTo, time);
            case "bezier": return interpolateBezier(kFrom, kTo, time);
            case "hermite": return interpolateHermite(kFrom, kTo, time);
            // case "acceleration": // SpriteStuioのサポートする方式。一般的でないかもしれないので対応保留
            // case "deceleration": // SpriteStuioのサポートする方式。一般的でないかもしれないので対応保留
            default:
                // 未知の補間方法は不正なデータである
                g.game.logger.warn("Unknown interpolation: " + kFrom.ipType);
                // 補間できない。最初のキーの値を採用する
                return kFrom.value;
        }
    }
}
/**
 * スケルトンクラス
 *
 * スケルトンクラスはアニメーションの計算と結果の保持を行う。
 */
var Skeleton = (function () {
    /**
     * Skeletonのインスタンスを生成する。
     *
     * @param bones ボーン配列
     * @param matrixFunc ルートボーンに前から乗算されるマトリクスを返す関数オブジェクト
     */
    function Skeleton(bones, matrixFunc) {
        this.bones = bones;
        this.matrixFunc = matrixFunc;
        this._triggeringBones = [];
        this.caches = new Array(bones.length);
        for (var i = 0; i < this.caches.length; i++) {
            this.caches[i] = new Posture();
            this.caches[i].index = i;
        }
        this.composedCaches = new Array(bones.length);
        for (var i = 0; i < this.composedCaches.length; i++) {
            this.composedCaches[i] = new Posture();
            this.composedCaches[i].index = i;
        }
    }
    Skeleton.prototype.getPostureByName = function (name) {
        for (var i = 0; i < this.bones.length; i = (i + 1) | 0) {
            if (this.bones[i].name === name) {
                return this.caches[this.bones[i].arrayIndex];
            }
        }
        return undefined;
    };
    /**
     * アタッチメントを取り付ける
     *
     * 通常ゲーム開発者はこのメソッドを直接呼び出す必要はない。
     *
     * @param attachment アタッチメント
     * @param boneName 取り付ける先のボーン名
     */
    Skeleton.prototype.attach = function (attachment, boneName) {
        var _this = this;
        this.bones.some(function (bone) {
            if (bone.name === boneName) {
                _this.caches[bone.arrayIndex].attachments.push(attachment);
                attachment.posture = _this.composedCaches[bone.arrayIndex];
                return true;
            }
            return false;
        });
    };
    /**
     * アタッチメントを取り外す。
     *
     * @param attachment 取り外すアタッチメント
     */
    Skeleton.prototype.removeAttachment = function (attachment) {
        var _this = this;
        this.bones.some(function (bone) {
            var posture = _this.caches[bone.arrayIndex];
            var index = posture.attachments.indexOf(attachment);
            if (index === -1) {
                return false;
            }
            var removed = posture.attachments.splice(index, 1);
            removed[0].posture = undefined;
            return true;
        });
    };
    /**
     * アニメーションの計算と描画の準備を行う。
     *
     * 通常ゲーム開発者はこのメソッドを直接呼び出す必要はない。
     *
     * @param time 現在のフレーム
     * @param anim 計算に用いるアニメーション
     */
    Skeleton.prototype.update = function (time, anim) {
        // アニメーションを計算。結果をcacheに収める
        this.updateCache(time, anim);
        // キャッシュの中身を接続
        this.traverse(this.bones[0]); // 0 番目にrootがあること
    };
    Skeleton.prototype._getBoneByName = function (boneName) {
        var bones = this.bones;
        for (var i = 0; i < bones.length; i = (i + 1) | 0) {
            if (bones[i].name === boneName) {
                return bones[i];
            }
        }
        return undefined;
    };
    /**
     * ボーンからアニメーションハンドラのためのg.Triggerインスタンスを取得する。
     *
     * @param boneName ボーン名
     * @param createIfNotExists 無ければg.Triggerインスタンスを生成するならtrueを与える
     */
    Skeleton.prototype._getTrigger = function (boneName, createIfNotExists) {
        var bone = this._getBoneByName(boneName);
        if (!bone) {
            return undefined;
        }
        var posture = this.caches[bone.arrayIndex];
        if (!posture) {
            return undefined;
        }
        if (!posture._trigger && createIfNotExists) {
            posture._trigger = new g.Trigger();
            this._triggeringBones.push(bone);
        }
        return posture._trigger;
    };
    /**
     * アニメーション計算ハンドラを実行する。
     */
    Skeleton.prototype._handleUserEvent = function (startFrame, elapse, anim) {
        for (var i = 0; i < this._triggeringBones.length; i++) {
            var bone = this._triggeringBones[i];
            var cache = this.caches[bone.arrayIndex];
            // skip if there's no handler
            if (!cache._trigger.hasHandler()) {
                continue;
            }
            // skip if there's no curve for the bone
            var ct = anim.curveTies[bone.name];
            if (ct === undefined) {
                continue;
            }
            // NOTE: データ読み込み時にuserDataがあるかどうか目印を付けて実行時の探索を軽減可能では
            for (var j = 0; j < ct.curves.length; j++) {
                var curve = ct.curves[j];
                if (curve.attrId === AttrId.userData && curve.keyFrames.length > 0) {
                    if (elapse > 0) {
                        this.fastForward(cache, curve.keyFrames, startFrame, elapse, anim.frameCount);
                    }
                    else {
                        this.fastBackward(cache, curve.keyFrames, startFrame, elapse, anim.frameCount);
                    }
                }
            }
        }
    };
    Skeleton.prototype.fastForward = function (cache, keyFrames, startFrame, elapse, animFrameCount) {
        var i = 0;
        var nLoop = 0;
        var endFrame = startFrame + elapse;
        while (true) {
            var keyFrame = keyFrames[i];
            var time = keyFrame.time + animFrameCount * nLoop;
            if (time >= endFrame) {
                break;
            }
            if (startFrame < time) {
                cache._trigger.fire({
                    left: { time: keyFrame.time, userData: keyFrame.value },
                    currentFrame: keyFrame.time,
                    frameCount: animFrameCount
                });
            }
            if (++i === keyFrames.length) {
                i = 0;
                nLoop++;
            }
        }
    };
    Skeleton.prototype.fastBackward = function (cache, keyFrames, startFrame, elapse, animFrameCount) {
        var i = keyFrames.length - 1;
        var nLoop = 0;
        var endFrame = startFrame + elapse;
        while (true) {
            var keyFrame = keyFrames[i];
            var time = keyFrame.time - animFrameCount * nLoop;
            if (time <= endFrame) {
                break;
            }
            if (time < startFrame) {
                cache._trigger.fire({
                    left: { time: keyFrame.time, userData: keyFrame.value },
                    currentFrame: keyFrame.time,
                    frameCount: animFrameCount
                });
            }
            if (--i === -1) {
                i = keyFrames.length - 1;
                nLoop++;
            }
        }
    };
    Skeleton.prototype.updateCache = function (time, anim) {
        for (var i = 0; i < this.bones.length; i++) {
            var bone = this.bones[i];
            var cache = this.caches[bone.arrayIndex];
            cache.reset();
            var ct = anim.curveTies[bone.name];
            if (ct === undefined) {
                continue;
            }
            var left = void 0;
            var right = void 0;
            for (var j = 0; j < ct.curves.length; j++) {
                var c = ct.curves[j];
                // pick key frame pair
                var pair = pickKeyFramePairByTime(c.keyFrames, time, anim.frameCount, c.attribute);
                var kFrom = pair[0];
                var kTo = pair[1];
                var attrId = c.attrId;
                if (attrId === AttrId.userData) {
                    left = { time: kFrom.time, userData: kFrom.value };
                    right = { time: kTo.time, userData: kTo.value };
                }
                // interpolation
                cache.attrs[attrId] = interpolate(kFrom, kTo, time);
            }
            if (cache._trigger && cache._trigger.hasHandler()) {
                // handler should call cache.updateMatrix()
                cache._trigger.fire({
                    posture: cache,
                    left: left,
                    right: right,
                    currentFrame: time,
                    frameCount: anim.frameCount
                });
            }
            else {
                cache.updateMatrix();
            }
        }
    };
    Skeleton.prototype.traverse = function (bone) {
        var cache = this.caches[bone.arrayIndex];
        var composedCache = this.composedCaches[bone.arrayIndex];
        // compose
        if (bone.parent) {
            var parentComposedCache = this.composedCaches[bone.parent.arrayIndex];
            if (parentComposedCache === undefined) {
                g.game.logger.warn("Invalid array index for " + bone.parent.name);
            }
            else {
                var m0 = composedCache.m._matrix;
                var m1 = parentComposedCache.m._matrix;
                var m2 = cache.m._matrix;
                // m0 = m1 * m2
                m0[0] = m1[0] * m2[0] + m1[2] * m2[1];
                m0[1] = m1[1] * m2[0] + m1[3] * m2[1];
                m0[2] = m1[0] * m2[2] + m1[2] * m2[3];
                m0[3] = m1[1] * m2[2] + m1[3] * m2[3];
                m0[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
                m0[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
                composedCache.attrs[AttrId.alpha] = parentComposedCache.attrs[AttrId.alpha] * cache.attrs[AttrId.alpha];
            }
        }
        else {
            var m1 = composedCache.m._matrix;
            if (this.matrixFunc) {
                var m2 = this.matrixFunc()._matrix;
                m1[0] = m2[0];
                m1[1] = m2[1];
                m1[2] = m2[2];
                m1[3] = m2[3];
                m1[4] = m2[4];
                m1[5] = m2[5];
            }
            else {
                m1[0] = 1;
                m1[1] = 0;
                m1[2] = 0;
                m1[3] = 1;
                m1[4] = 0;
                m1[5] = 0;
            }
            composedCache.m.multiply(cache.m);
            composedCache.attrs[AttrId.alpha] = 1.0;
        }
        // copy
        var src = cache.attrs;
        var dst = composedCache.attrs;
        dst[AttrId.cv] = src[AttrId.cv];
        dst[AttrId.pvtx] = src[AttrId.pvtx];
        dst[AttrId.pvty] = src[AttrId.pvty];
        dst[AttrId.tu] = src[AttrId.tu];
        dst[AttrId.tv] = src[AttrId.tv];
        dst[AttrId.prio] = src[AttrId.prio];
        dst[AttrId.visibility] = src[AttrId.visibility];
        composedCache.attachments = cache.attachments;
        dst[AttrId.ccr] = src[AttrId.ccr];
        dst[AttrId.flipH] = src[AttrId.flipH];
        dst[AttrId.flipV] = src[AttrId.flipV];
        // go down well.
        if (bone.children) {
            for (var i = 0; i < bone.children.length; i++) {
                this.traverse(bone.children[i]);
            }
        }
    };
    return Skeleton;
}());
module.exports = Skeleton;
