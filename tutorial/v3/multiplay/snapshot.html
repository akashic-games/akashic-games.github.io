<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="UTF-8">
<meta name="viewport"    content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<meta name="description" content="Akashic EngineはJavaScriptで動作する、無償利用が可能なマルチプラットフォーム対応ゲーム開発エンジンです">
<meta name="theme-color" content="#0F1F26">
<title>スキップ時間を短縮する</title>
<link rel="icon"       href="/favicon.ico" type="image/vnd.microsoft.icon">
<link rel="stylesheet" href="/css/common.css?0bf2ea8a">
<link rel="stylesheet" href="/css/header.css?0bf2ea8a">
<link rel="stylesheet" href="/css/footer.css?0bf2ea8a">


<link rel="stylesheet" href="/css/akashic-document.css?0bf2ea8a">

<link rel="stylesheet" href="/css/railscasts.css?0bf2ea8a">


<script src="/lib/jquery-3.2.1.min.js"></script>
<script src="/lib/common.js?0bf2ea8a"></script>



<script src="/lib/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>

<div class="head--spacer"></div>
<div class="SP--head--menu--show"></div>
<div class="SP--head--menu--hide"></div>

<div class="head--menu--outer">
	<ul class="head--menu">
		<li class="head--menu--item">
			<p class="head--menu--item--tab"></p>
			<ul class="head--menu--item--list">
				<li><a href="/tutorial/v3/">Akashic Engine入門</a></li>
				<li><a href="/reverse-reference/v3/">Akashic Engine逆引きリファレンス</a></li>
				<li><a href="/shin-ichiba/">ニコ生ゲームを作ろう</a></li>
				<li><a href="/recent-changes/">Akashic Engine 更新情報</a></li>
				<!--li><a href="/tutorial/akashic-info.html">Akashic Engine関連情報一覧</a></li-->
			</ul>
		</li>
		<li class="head--menu--item">
			<p class="head--menu--item--tab"></p>
			<ul class="head--menu--item--list">
				<li><a href="/guide/akashic-cli.html">akashic-cli利用ガイド</a></li>
				<li><a href="/guide/bmpfont-generator.html">bmpfont-generator の仕様</a></li>
				<li><a href="/guide/game-json.html">game.jsonの仕様</a></li>
				<li><a href="/guide/sandbox-config.html">sandbox.config.jsの仕様</a></li>
				<li><a href="/guide/akashic-lib.html">akashic-lib.jsonの仕様</a></li>
				<li><a href="/guide/atsumaru.html">ゲームアツマールで遊べるゲームの作成</a></li>
				<li><a href="/guide/shin-ichiba/index.html">ニコニコ生放送で遊べるゲームの作成</a></li>
				<li><a href="/guide/asset-load-error.html">アセットロードエラーについて</a></li>
				<li><a href="/guide/shader.html">シェーダの利用</a></li>
				<li><a href="/guide/asset-recommended-spec.html">素材の推奨仕様</a></li>
				<li><a href="/guide/template-guide.html">akashic initテンプレート利用ガイド</a></li>
				<li><a href="/guide/common-pitfalls.html">よくある落とし穴</a></li>
				<li><a href="/guide/acceleration-tips.html">高速化TIPS</a></li>
				<!--li><a href="/guide/storage.html">ストレージについて</a></li-->
			</ul>
		</li>
		<li class="head--menu--item"><a class="head--logo" href="/" title="ホーム"></a></li>
		<li class="head--menu--item">
			<p class="head--menu--item--tab"></p>
			<ul class="head--menu--item--list">
				<li><a href="https://akashic-games.github.io/akashic-engine/v3/">akashic-engine v3.x</a></li>
				<li><a href="https://akashic-games.github.io/akashic-timeline/api/">akashic-timeline</a></li>
				<li><a href="https://akashic-games.github.io/akashic-animation/api/">akashic-animation</a></li>
				<li><a href="https://akashic-games.github.io/akashic-label/api/">akashic-label</a></li>
				<li><a href="https://akashic-games.github.io/akashic-tile/api/">akashic-tile</a></li>
				<li><a href="https://akashic-games.github.io/akashic-box2d/api/">akashic-box2d</a></li>
				<li><a href="https://akashic-games.github.io/coe/api/">coe framework</a></li>
				<li><a href="https://akashic-games.github.io/raycaster-js/api/">raycaster-js</a></li>
				<li><a href="https://akashic-games.github.io/collision-js/api/">collision-js</a></li>
				<li><a href="https://akashic-games.github.io/aimgui/api/">AimGui</a></li>
				<li><a href="https://akashic-games.github.io/akashic-engine/v2/modules/_lib_main_d_.g.html">akashic-engine v2.x (旧版)</a></li>
				<li><a href="https://akashic-games.github.io/akashic-engine/v1/modules/_lib_main_d_.g.html">akashic-engine v1.x (旧版)</a></li>
			</ul>
		</li>
		<li class="head--menu--item" id="demo">
			<a  class="demo-link" href="/demo/?title=helloworld" >サンプルデモ</a>
			<!-- 以下 sp 用のメニュ -->
			<p class="head--menu--item--tab" id="demo"></p>
			<ul class="head--menu--item--list" id="demo">
				<li><a href="/demo/?title=helloworld">Hello World</a></li>
				<li><a href="/demo/?title=scale-rotate-opacity">拡縮・回転・透明度</a></li>
				<li><a href="/demo/?title=bitmap-font">ビットマップフォント</a></li>
				<li><a href="/demo/?title=framesprite">フレームアニメーション</a></li>
				<li><a href="/demo/?title=demo-touchevent">タッチイベント</a></li>
				<li><a href="/demo/?title=demo-tile">タイル</a></li>
				<li><a href="/demo/?title=svg-sample">SVGサンプル</a></li>
				<li><a href="/demo/?title=label-sample">ラベル</a></li>
				<li><a href="/demo/?title=box2d-sample">2D 物理演算</a></li>
				<li><a href="/demo/?title=animation-showcase">アニメーション制御</a></li>
				<li><a href="/demo/?title=timeline-sample">トゥイーン制御</a></li>
				<li><a href="/demo/?title=timeline-easing-sample">イージング一覧</a></li>
				<li><a href="/demo/?title=simpleShot">アブストラクトシューティング</a></li>
				<li><a href="/demo/?title=HoppingWitch">HOPPING WITCH</a></li>
				<li><a href="/demo/?title=GalaxyWars">GALAXY WARS</a></li>
				<li><a href="/demo/?title=cannontv">いくぜ！ 超会議</a></li>
				<li><a href="/demo/?title=collision-js">collision-js</a></li>
				<li><a href="/demo/?title=aimgui">AimGui</a></li>
				<li><a href="/demo/?title=tsurikkuma-style-game">つりっくま風ゲーム</a></li>
				<li><a href="/demo/?title=oekaki">おえかき</a></li>
				<li><a href="/demo/?title=software-keyboard-sample">ソフトウェアキーボード</a></li>
				<li><a href="/demo/?title=hello-box2d">箱を落とす</a></li>
				<li><a href="/demo/?title=drag-throw">ドラッグして飛ばす</a></li>
				<li><a href="/demo/?title=hit-break">ぶつかると散る</a></li>
				<li><a href="/demo/?title=spring">バネ</a></li>
				<li><a href="/demo/?title=hajiki">おはじき</a></li>
				<li><a href="/demo/?title=newtons-cradle">ニュートンのゆりかご</a></li>
				<li><a href="/demo/?title=draw-polygon">多角形を描く</a></li>
				<li><a href="/demo/?title=machine-gun">マシンガン</a></li>
				<li><a href="/asset/material.html">サンプルデモの素材</a></li>
			</ul>
		</li>
	</ul>
</div>

<header id="akashic-page-header">
	<div class="SP--head--logo--box"><a class="head--logo" href="/" title="ホーム"></a></div>
</header>

<div id="BodyInner">
	<section class="akashic--document safearea--LR twocol">
		<div class="twocol-side">
			<h3>
	<a href="../">Akashic Engine 入門</a>
</h3>


	
	
	<label class="accordion-label" for="accordion_state_0">akashic を試してみる</label>
	<input type="checkbox" class="accordion-state" id="accordion_state_0" checked></input>
	<ul>
		
			<li>
				
					<a href="../getting-started.html">まずは動かしてみよう</a>
				
			</li>
		
	</ul>

	
	
	<label class="accordion-label" for="accordion_state_1">導入</label>
	<input type="checkbox" class="accordion-state" id="accordion_state_1" checked></input>
	<ul>
		
			<li>
				
					<a href="../v3-migration-guide.html">v2 からの移行</a>
				
			</li>
		
			<li>
				
					<a href="../introduction.html">akashic の導入</a>
				
			</li>
		
	</ul>

	
	
	<label class="accordion-label" for="accordion_state_2">シングルプレイのゲーム作成</label>
	<input type="checkbox" class="accordion-state" id="accordion_state_2" checked></input>
	<ul>
		
			<li>
				
					<a href="../basic.html">コンテンツ作成の基本</a>
				
			</li>
		
			<li>
				
					<a href="../display-order.html">表示順の制御</a>
				
			</li>
		
			<li>
				
					<a href="../animation.html">アニメーションさせる</a>
				
			</li>
		
			<li>
				
					<a href="../click.html">クリックできるようにする</a>
				
			</li>
		
			<li>
				
					<a href="../audio.html">音を鳴らす</a>
				
			</li>
		
			<li>
				
					<a href="../scale-anchor.html">拡縮とアンカーポイント</a>
				
			</li>
		
			<li>
				
					<a href="../text.html">文字列を表示する</a>
				
			</li>
		
			<li>
				
					<a href="../bitmap-font.html">ビットマップフォントを使う</a>
				
			</li>
		
			<li>
				
					<a href="../clipping.html">クリッピングする</a>
				
			</li>
		
			<li>
				
					<a href="../export.html">ゲームを公開する</a>
				
			</li>
		
	</ul>

	
	
	<label class="accordion-label" for="accordion_state_3">より大規模なゲームに向けて</label>
	<input type="checkbox" class="accordion-state" id="accordion_state_3" checked></input>
	<ul>
		
			<li>
				
					<a href="../scene.html">シーンを切り替える</a>
				
			</li>
		
			<li>
				
					<a href="../require.html">スクリプトを分割する</a>
				
			</li>
		
			<li>
				
					<a href="../assetPaths.html">複数アセットをまとめて扱う</a>
				
			</li>
		
			<li>
				
					<a href="../library.html">拡張ライブラリを使う</a>
				
			</li>
		
	</ul>

	
	
	<label class="accordion-label" for="accordion_state_4">マルチプレイのゲーム作成</label>
	<input type="checkbox" class="accordion-state" id="accordion_state_4" ></input>
	<ul>
		
			<li>
				
					<a href="../multiplay/introduction.html">マルチプレイの基礎</a>
				
			</li>
		
			<li>
				
					<a href="../multiplay/each-player.html">プレイヤーごとに異なる描画を行う</a>
				
			</li>
		
			<li>
				
					<a href="../multiplay/camera.html">プレイヤーごとに異なる位置を表示する</a>
				
			</li>
		
			<li>
				
					<a href="../multiplay/join.html">Join と Leave</a>
				
			</li>
		
			<li>
				
					<a href="../multiplay/release-multiplay.html">マルチプレイゲームを公開する</a>
				
			</li>
		
			<li>
				
					<b>スキップ時間を短縮する</b>
				
			</li>
		
	</ul>


		</div>
		<div class="twocol-main">
			<div class="inner responsive--width--twocol">
				<h1>スキップ時間を短縮する</h1>
<h2><a name="skip"></a> スキップ</h2>
<p>Akashic のマルチプレイでは、ゲームの途中で画面を開くと、最初にビデオ映像を早送りするような画面が表示されます。
<a href="./introduction.html#architecture-intro">マルチプレイの基礎</a> でも触れたとおり、これはゲームの最新状態に追いつくために、
それまでの操作 (イベント) を高速で消化することによるものです。
この早送り動作を <strong>スキップ</strong> と呼びます。</p>
<p>このスキップ処理によって、「他プレイヤーとの実行状態の共有」を意識することなくゲームを作成することができます。
他方この仕組みには <strong>プレイ時間に比例してスキップの時間が伸びていく</strong> という弱点があります。
大規模なゲームや、一度の起動中に繰り返し遊べるように作られたゲームでは、スキップ時間が非常に長くなってしまう場合があります。</p>
<p>この対策として、Akashic Engine は「スナップショット」という機能を提供しています。</p>
<blockquote>
<p>厳密には、スキップ処理はマルチプレイとは独立な動作です。
例えばニコニコ生放送で、ニコ生ゲームを遊んでいる最中の配信を見始めた時は、
そのゲームがシングルプレイであっても (最新フレームに追いつくために) スキップが発生します。
また過去のプレイのリプレイの再生中に、シークバーを操作して大きく時間をジャンプするような場合にも、
スキップが発生することがあります。</p>
</blockquote>
<h2><a name="snapshot"></a> スナップショット</h2>
<p>Akashic Engine において、ゲームの実行状態をシリアライズしたオブジェクトを <strong>スナップショット</strong> と呼びます。
ゲーム開発者は、ゲームのスナップショットを作成し、エンジンに保存を要求することができます。</p>
<p>エンジンは、ゲームプレイのある時点 (最新フレームなど) に追いつく必要がある場合、
まずその時点より前のもっとも近いスナップショットを探します。
スナップショットが見つからなければ、エンジンは単にゲーム開始からのすべての操作を早送りで消化 (スキップ) します。
もし見つかれば、スナップショットをゲームに渡して状態を復元させ、そこから目標の時点までスキップ処理を行います。
これによりスキップの時間を短縮することができます。</p>
<blockquote>
<p>このようにスナップショットは、ゲームのいわゆる「セーブデータ」とは異なることに注意してください。
たとえばプレイヤーがスナップショットを選んでロードするようなことはできません。
あくまでスキップ処理の時間を短縮するために、エンジンが自動的に検索して利用するために存在します。</p>
</blockquote>
<p>スナップショットを利用するには、次の二つが必要です:</p>
<ul>
<li>適時スナップショットを作成・保存する処理</li>
<li>ゲームがスナップショットつきで起動された時、スナップショットから状態を復元する処理</li>
</ul>
<h3><a name="save"></a> スナップショットの保存</h3>
<p>スナップショットの保存は、 <code>g.game.requestSaveSnapshot()</code> によって要求することができます。</p>
<p>詳細な仕様は後述しますが、このメソッドは主に以下の形で利用します。</p>
<pre><code class="language-typescript">g.game.requestSaveSnapshot(() =&gt; {
  const snapshot = {
    // ゲームの実行状態を表すデータ
  };
  return { snapshot: snapshot };
});</code></pre>
<p>すなわち <code>requestSaveSnapshot()</code> は引数として関数を取ります。
この関数は、 <code>requestSaveSnapshot()</code> を呼び出したフレームの終了時に引数なしで呼び出されます。</p>
<p>関数の戻り値として、 <code>snapshot</code> プロパティを持つオブジェクトを返してください。
このプロパティの値がスナップショットとして保存されます。
このプロパティの値は JSON として妥当な値でなければなりません。</p>
<h3><a name="restore"></a> スナップショットからの復元</h3>
<p>一度でもスナップショットを保存する場合、 <strong>スナップショットからの復元</strong> 処理を実装する必要があります。</p>
<p>スナップショットが利用される場合、まず現在のゲームの実行状態が破棄されます。
その後通常のゲーム開始時と同じように、 main スクリプト (のエクスポートした関数) が呼び出されます。
ただしこの時、第一引数の <code>snapshot</code> プロパティにスナップショットが渡されます。
その値は、同じゲームが過去に <code>g.game.requestSaveSnapshot()</code> で保存させた値のいずれかです。</p>
<p>スナップショットからの復元処理とは、文字通り渡されたスナップショットから、保存時点のゲーム状態を再現することです。</p>
<p>以下の例は、画面中央付近の数字をインクリメントしていくだけの非常に単純なゲームです。</p>
<pre><code class="language-js">// script/main.js (mainスクリプト)

function main() {
  const scene = new g.Scene({ game: g.game });
  scene.onLoad.add(() =&gt; {
    g.game.vars.value = 0;

    const font = new g.DynamicFont({
      game: g.game,
      fontFamily: &quot;sans-serif&quot;,
      size: 15
    });

    const label = new g.Label({
      scene: scene,
      font: font,
      fontSize: 15,
      text: &quot;&quot; + g.game.vars.value,
      x: g.game.width / 2,
      y: g.game.height / 2
    });
    label.onUpdate.add(() =&gt; {
      label.text = &quot;&quot; + g.game.vars.value++;
      label.invalidate();
    });
    scene.append(label);
  });
  g.game.pushScene(scene);
}

module.exports = main;</code></pre>
<p>このゲームは、次のように変更することでスナップショットに対応させることができます。</p>
<pre><code class="language-js">// script/main.js (mainスクリプト)

function main(param) {
  // 引数 param に snapshot プロパティがあればそこから復元。
  // なければ通常のゲーム開始だが、ここでは「空オブジェクト ({}) からの復元」として一本化。
  const snapshot = param.snapshot || {};

  const scene = new g.Scene({ game: g.game });
  scene.onLoad.add(() =&gt; {
    // スナップショットからの復元なら保存されていた値、そうでなければ 0 で初期化。
    g.game.vars.value = snapshot.val || 0;

    const font = new g.DynamicFont({
      game: g.game,
      fontFamily: &quot;sans-serif&quot;,
      size: 15
    });

    const label = new g.Label({
      scene: scene,
      id: snapshot.labelId || undefined, // エンティティIDを復元していることに注意(後述)。
      font: font,
      fontSize: 15,
      text: &quot;&quot; + g.game.vars.value,
      x: g.game.width / 2,
      y: g.game.height / 2
    });
    label.onUpdate.add(() =&gt; {
      label.text = &quot;&quot; + g.game.vars.value++;
      label.invalidate();
    });
    scene.append(label);

    // 1 分 (60 * 1000 ms) おきにスナップショットを保存。
    scene.setInterval(() =&gt; {
      g.game.requestSaveSnapshot(() =&gt; {
        const snapshot = {
          val: g.game.vars.value,
          labelId: label.id
        };
        return { snapshot: snapshot };
      });
    }, 60 * 1000);
  });
  g.game.pushScene(scene);
}

module.exports = main;</code></pre>
<p><code>scene.setInterval()</code> で 1 分おきにスナップショットを作成、保存するようになっています。
このゲームの実行状態は画面中央の数字 (<code>g.game.vars.value</code> の値) だけなので、その値をスナップショットに含めています。
また <code>main()</code> の引数 <code>param</code> を受け取り、 <code>param.snapshot</code> を参照してゲームの実行状態を復元しています。
スナップショットが指定されない場合、従来と動作が変わっていないことに注意してください。</p>
<p>ただしここで、ラベルエンティティ <code>label</code> の <code>id</code> プロパティもスナップショットに含めている点に注意する必要があります。</p>
<p>すなわちゲームの実行状態には、通常暗黙に設定され、意識する必要もない「エンティティの ID」(後述) さえ含まれます。
このようにスナップショットは、シーンの状態からエンティティの ID ・
カメラの状態やプレイヤーの参加状態・スワイプ中ならその状態など、すべて何もかも保存・復元しなければなりません。
これは技術的には可能ですが、動作確認を含めて簡単に実装できるものではありません。</p>
<p>そこで一般には、 <strong>できるだけ内部状態を持たないタイミングを作り、そこでのみスナップショットを保存する</strong> ことを推奨します。</p>
<h2><a name="save-timing"></a> 保存のタイミング</h2>
<p>スナップショットの保存は、「内部状態がほとんどない」フレームで行うことを推奨します。</p>
<p>「内部状態がほとんどない」とは、次の全てを満たすような状況です。</p>
<ul>
<li>(非ローカルの) エンティティがない</li>
<li>シーンが一つだけである</li>
<li>タイマー待ち (<code>setInterval()</code> などで渡した関数の呼び出し待ち) がない</li>
<li>ゲームがひと段落した <strong>&quot;合間&quot;</strong> である</li>
</ul>
<p>例えば対戦ゲームであれば「対戦の決着がついて、メニュー画面に戻る直前」などが &quot;合間&quot; に該当するでしょう。
対戦中は「キャラクターの体力」「キャラクターの位置」「残り時間」「スコア」「アニメーションの再生状態」など、
ゲームによってさまざまな状態があり得ますが、 &quot;合間&quot; にはそれらがありません。
また画面に何も表示しなくても違和感を覚えられにくいはずです。
このようなタイミングでは、スナップショットの保存・復元は非常に単純になります。</p>
<p>極論、ゲームがその一種類の &quot;合間&quot; でしかスナップショットを保存しないのであれば、
保存する値は空オブジェクト (<code>{}</code>) だけにすることすらできます。
スナップショットからの復元処理は、単に「メニュー画面」を表示するだけの処理になるためです。
もちろん「ハイスコア」「戦績」など、対戦を通して持ち越す情報がある場合は、その値をスナップショットに含めてください。</p>
<h2><a name="pitfall-just-in-time"></a> 注意点: スナップショットを事前に生成しない</h2>
<p><strong>スナップショットは、 <code>requestSaveSnapshot()</code> に与えた関数 (コールバック) の中で生成してください</strong> 。</p>
<p>以下はこれに反するコード例です。</p>
<pre><code class="language-typescript">// NG: スナップショットを事前に生成している
const snapshot = {
  // ...
};
g.game.requestSaveSnapshot(() =&gt; {
  return { snapshot: snapshot };
});</code></pre>
<p>次のように、 <code>requestSaveSnapshot()</code> に与えた関数の中で生成してください。</p>
<pre><code class="language-typescript">// OK: スナップショットを保存直前に生成している
g.game.requestSaveSnapshot(() =&gt; {
  const snapshot = {
    // ...
  };
  return { snapshot: snapshot };
});</code></pre>
<p>これは Akashic Engine のゲームがフレーム単位で実行されることに起因しています。
スナップショットから復元した場合、処理は「スナップショットを保存したフレーム」の次のフレームから始まります。
そのためフレームの &quot;途中&quot; でスナップショットを保存することはできません。
スナップショットは「それを保存したフレーム」の終了時の状態を表す必要があります。</p>
<blockquote>
<p>そもそも <code>requestSaveSnapshot()</code> が、直接スナップショットを引数に取らないのも、
コールバックを (呼び出された瞬間ではなく) フレームの終了時に呼び出すのもこのためです。</p>
</blockquote>
<p><code>requestSaveSnapshot()</code> を呼び出す時、スナップショットを事前に生成してしまうと、「フレームの終了時」の状態と異なる可能性があります。
例えば次のようなコードが考えられます。</p>
<pre><code class="language-typescript">let score = 0;
scene.onPointDownCapture.add(() =&gt; {
  score++;
});

scne.onMessage.add(ev =&gt; {
  if (ev.data &amp;&amp; ev.data.type === &quot;SNAPSHOT&quot;) {
    // NG: スナップショットを事前に生成している
    const snapshot = { score: score };
    g.game.requestSaveSnapshot(() =&gt; {
      return { snapshot: snapshot };
    });
  }
});</code></pre>
<p>このコードは画面がクリックされるたびに <code>score</code> の値を増やしていき、
<code>data.type</code> が <code>&quot;SNAPSHOT&quot;</code> である <code>g.MessageEvent</code> を受信するたびにスナップショットを保存します。</p>
<p>このコードが、たまたま同一フレームで <code>g.MessaveEvent</code> と <code>g.PointDownEvent</code> を受信したとします。
<code>g.MessaveEvent</code> が先に処理された場合、その時点でスナップショットが生成されます。
しかしその後 <code>g.PointDownEvent</code> を処理するので <code>score</code> は 1 増えます。
そうなると、スナップショットに保存される <code>score</code> の値と、このフレームの終了時の <code>score</code> の値は 1 ずれてしまいます。</p>
<p>次のように <code>requestSaveSnapshot()</code> のコールバック内でスナップショットを生成すれば、この問題は起きません。
<code>g.MessaveEvent</code> によって更新された後の <code>score</code> の値がスナップショットに保存されます。</p>
<pre><code class="language-typescript">scne.onMessage.add(ev =&gt; {
  if (ev.data &amp;&amp; ev.data.type === &quot;SNAPSHOT&quot;) {
    g.game.requestSaveSnapshot(() =&gt; {
      const snapshot = { score: score };
      return { snapshot: snapshot };
    });
  }
});</code></pre>
<p>言い換えれば、<strong>スナップショットに保存する実行状態は、<code>requestSaveSnapshot()</code>
を呼び出す時点のものではなく、コールバックが呼び出された時点のものでなければなりません。</strong></p>
<p>もし <code>requestSaveSnapshot()</code> のコールバックが呼ばれた時点 (フレームの終了時) で、
スナップショットが生成できない・生成しにくい状態 (アニメーション中のエンティティがあるなど) になっていた場合は、 <code>null</code> を返してください。
この場合エンジンは何も保存しません。
(もちろんコンテンツはこのような状況を作らないことができるはずです。)</p>
<h2><a name="save-restore-wrap-up"></a> 保存と復元まとめ</h2>
<p>以上をまとめると、スナップショットの保存と復元では次の点が重要です。</p>
<ul>
<li><strong>保存</strong><ul>
<li><code>g.game.requestSaveSnapshot()</code> で保存する</li>
<li>保存は「内部状態がほぼない」フレームで行う</li>
<li>スナップショットは <code>requestSaveSnapshot()</code> に渡した関数の中で生成する</li>
<li>スナップショットには、そのフレームの終了時の状態を復元できるだけの内容を含める</li>
</ul>
</li>
<li><strong>復元</strong><ul>
<li>ゲーム起動時の引数にスナップショットが渡されたらそれを使って復元する</li>
<li>シーンを生成しその <code>onLoad</code> ハンドラが終わるまでの間に、保存時の状態を再現する</li>
</ul>
</li>
</ul>
<h2><a name="snapshot-debug"></a> スナップショットの動作確認</h2>
<p>スナップショットは、特定のフレームに「追いつく」必要がない限り利用されないので、動作確認のしにくい機能です。
akashic-cli@2.13.0 以降の akashic serve では、スナップショットの動作確認のためにいくつかの機能を提供しています。</p>
<ul>
<li>Playback ツール</li>
<li>クエリパラメータ</li>
</ul>
<h3><a name="playback-devtool"></a> Playback ツール</h3>
<p>Playback ツールは、 serve の画面右上のハンバーガーボタン (三本線のアイコン) をクリックした時に表示される開発者ツール (devtool) の一つです。</p>
<p><img src="/img/tutorial/cli-serve-playback-tool.png" alt="akashic-cli@2.13.0 の akashic serve の Playback ツールのスクリーンショット"></p>
<p>主に次のような機能があります。</p>
<ul>
<li>実行中のプレイで保存されたスナップショットの一覧表示</li>
<li>スナップショットでのゲームのリセット</li>
<li>スナップショットのダンプ</li>
</ul>
<p>スナップショット一覧の左側、三角形のボタン (再生ボタン) を押すと、そのスナップショットでゲームをリセットします。
それによってスナップショットを保存した時点に「ジャンプ」することができます。</p>
<p>一覧の右側 <code>console.log()</code> ボタンを押すと、対応するスナップショットの内容 (正確にはそれを含んだ「スタートポイント」と呼ばれるデータ) がコンソールに出力されます。</p>
<p>シークバーは、このインスタンスの現在のゲーム内時間を表しています。
serve の画面上部 (ツールバー) のシークバーと連動しています。
上の画像では、シークバーの濃い灰色のゲージが途中から始まっています。
ゲージの左端は、ゲームをリセットした時のゲーム内時間 (現在のゲーム実行がいつのスナップショットから始まったか) を表しています。</p>
<p><code>Pause active</code> ボタンを押すと、他ウィンドウを含めた全インスタンスの実行を一時停止することができます。
(serve の画面上部 (ツールバー) の同じアイコンのボタンと同一の機能です。)
通常、あるウィンドウでリプレイ再生を行っている間も、ゲーム全体は進行し続けています。
たとえば他のウィンドウは止まりません。
これはスナップショットの動作確認の上では不便なことが多いので、その場合には <code>Pause active</code> ボタンを利用してください。</p>
<p>その他細かな機能は実験中のものです。将来のバージョンで変化することがあります。</p>
<h3><a name="debug-query-param"></a> クエリパラメータ</h3>
<p>保存したスナップショットのフレームが (Playback ツールなどで) わかっている場合、クエリパラメータを指定することでページを開いた直後の実行状態を制御できます。</p>
<p>例えばポート 3300 で akashic serve を実行中、次の URL にアクセスすると、</p>
<pre><code class="language-http">http://localhost:3300/public/?mode=replay&amp;replayResetAge=1500&amp;replayTargetTime=180000</code></pre>
<p>以下の状態でウィンドウを開くことができます。</p>
<ul>
<li>akashic serve の現在のプレイを、リプレイモード (<code>mode=replay</code>) で開始し、</li>
<li>age 1500 のスナップショットでゲームをリセット (<code>replayResetAge=1500</code>) して、</li>
<li>シークバーを 3 分 0 秒 (180000 ミリ秒) 地点に動かし (<code>replayTargetTime=180000</code>) た状態</li>
</ul>
<p>以下のクエリパラメータがサポートされています。</p>
<table>
<thead>
<tr>
<th align="center">パラメータ名</th>
<th align="center">値</th>
<th align="center">デフォルト値</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>mode</code></td>
<td align="center"><code>replay</code> または <code>passive</code></td>
<td align="center"><code>passive</code></td>
<td align="left"><code>replay</code> の場合、リプレイモード(シークバーを操作して過去の状態を表示させている状態)で開始します。 <code>passive</code> (省略時) は最新フレームに追いつこうとする通常のモードで開始します。</td>
</tr>
<tr>
<td align="center"><code>replayResetAge</code></td>
<td align="center">整数値 (age)</td>
<td align="center">なし</td>
<td align="left"><code>mode=replay</code>の場合のみ有効。指定した場合、その age (ゲーム開始からの経過フレーム数) で保存されたスナップショット (またはその age 以前で最も近いもの) でゲーム状態をリセットして開始します。</td>
</tr>
<tr>
<td align="center"><code>replayTargetTime</code></td>
<td align="center">整数値 (ゲーム開始からのミリ秒の経過時刻)</td>
<td align="center"><code>0</code></td>
<td align="left"><code>mode=replay</code>の場合のみ有効。指定した場合、シークバーがその値の位置にシークされた状態で開始します。 <code>replayResetAge</code> を指定する場合、実質的に必須のパラメータです (指定しないとリセット時刻と関係なく時刻 0 に行ってしまうため)。</td>
</tr>
<tr>
<td align="center"><code>paused</code></td>
<td align="center"><code>true</code> または <code>false</code></td>
<td align="center"><code>false</code></td>
<td align="left"><code>true</code> の場合、一時停止状態で開始します。</td>
</tr>
</tbody></table>
<p>ただしクエリパラメータのキー名などは実験的なものです。URL 部分などを含め、今後のバージョンで変化する可能性があります。</p>
<p>またこれらの他にも、単純にマルチプレイでブラウザウィンドウ (インスタンス) を追加した時にも、スナップショットは利用されます。
追加されたウィンドウでは、最新のスナップショットから状態を復元してから実行を開始しようとするためです。</p>
<blockquote>
<p>どのスナップショットで開始しても、ゲームは同じ時刻に同じ状態にならなければなりません。
例えば <code>replayResetAge</code> の値だけが異なるウィンドウを複数開いた時、それらは全て同じ画面表示になる必要があります (ローカルエンティティを除き)。
もしそうでなければ、スナップショットの保存・復元処理に問題があるので、修正が必要です。
スナップショットの扱いに問題があると、特にプレイヤー間の実行状態がずれてしまい、マルチプレイが破綻します。</p>
</blockquote>
<h2><a name="request-save-snapshot"></a> 補足 1: g.game.requestSaveSnapshot() の仕様</h2>
<p>スナップショット保存を要求するメソッド <code>g.game.requestSaveSnapshot()</code> は、次のシグネチャを持ちます。</p>
<pre><code class="language-typescript">g.game.requestSaveSnapshot(fun: () =&gt; g.SnapshotSaveRequest | null, owner?: any): void</code></pre>
<p>引数 <code>fun</code> は関数でなければなりません。
<code>fun()</code> は <code>requestSaveSnapshot()</code> を呼び出したフレームの終了時に、引数なしで呼び出されます。
引数 <code>owner</code> は任意の値で、 <code>fun()</code> の呼び出し時に <code>this</code> として与えられます。</p>
<p><code>fun()</code> は戻り値として <code>null</code> または <code>g.SnapshotSaveRequest</code> を返さなければなりません。
<code>g.SnapshotSaveRequest</code> を返した場合、その値を元にスナップショットの保存要求が行われます。
<code>null</code> を返した場合、保存は行われません。</p>
<p><code>g.SnapshotSaveRequest</code> は、次のプロパティを持つオブジェクトです:</p>
<table>
<thead>
<tr>
<th align="center">プロパティ名</th>
<th align="center">型</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>snapshot</code></td>
<td align="center"><code>any</code></td>
<td align="left">スナップショットデータ。JSON として妥当な値である必要があります。</td>
</tr>
<tr>
<td align="center"><code>timestamp</code></td>
<td align="center"><code>number</code></td>
<td align="left">時刻。省略可能。通常、省略してください。この詳細は <code>g.TimestampEvent</code> (文書化されていない機能) と併せて文書化されます。</td>
</tr>
</tbody></table>
<p>マルチプレイの場合、<code>requestSaveSnapshot()</code> は (他の非ローカルな処理と同様に) 全インスタンスで呼び出してください。
ただし <code>fun()</code> はそのうちの一部のインスタンスでのみ呼び出されます。
なぜなら、同じプレイの同じフレームのスナップショットは一意なはずなので、マルチプレイであっても一箇所でしか保存する必要がないためです。
実装的にもスナップショットを保存できるプレイヤー (インスタンス) は限られています。
<code>requestSaveSnapshot()</code> は、実際にスナップショットを保存できるインスタンスでのみ <code>fun()</code> を呼び出し、それ以外の場合は何もしません。
このことから、スナップショットにはローカルな状態を保存することはできません。</p>
<blockquote>
<p>通常この「スナップショットの保存を実際に行うインスタンス」は、プレイの中で一つだけ存在します。
現在の akashic serve やニコ生ゲーム環境では、サーバサイドで動作する特殊なインスタンスが該当します。
自分がスナップショットの保存を行うインスタンスであるかどうかは、 <code>g.game.shouldSaveSnapshot()</code> で判定できます。
ただし通常この判定が必要になることはありません。(<code>requestSaveSnapshot()</code> が行うため)</p>
</blockquote>
<p>保存を要求したスナップショットがすべて保存されることは保証されません。
高すぎる頻度の保存や、大きすぎるスナップショットまたはその他の理由で、保存要求が無視されることがあります。
具体的な制限はサービス依存ですが、保存頻度に関しては、現在のところ目安として「1 分以上の間隔をあけて保存する」を推奨します。
スナップショットが一部または全部保存されていなかったとしても、スキップ時間が延びる以外の影響はありませんし、あってはいけません。</p>
<h2><a name="nontrivial-snapshot"></a> 補足 2: &quot;合間&quot; でないタイミングでのスナップショット</h2>
<p>前述のとおり、スナップショットはできる限り内部状態がないタイミングでの保存を推奨します。</p>
<blockquote>
<p>この推奨に従う限り、このページのここから先を読む必要はありません。</p>
</blockquote>
<p>そうでないタイミングで保存する場合、ゲーム実行状態の復元に必要な情報はすべて、
ゲーム開発者によって収集されスナップショットとしてまとめられる必要があります。
これには以下のような情報が含まれうるでしょう。</p>
<ul>
<li>その時点で存在するエンティティ</li>
<li>その時点で存在するシーン<ul>
<li>複数のシーンを作成しているならその全て</li>
</ul>
</li>
<li>ゲーム内データ<ul>
<li>キャラクターの残り HP など</li>
<li><code>g.Game#vars</code> に保持している値</li>
<li>アニメーションの再生状態</li>
</ul>
</li>
<li>作成した乱数生成器</li>
<li>作成したカメラと現在の <code>g.Game#focusingCamera</code> の値</li>
<li>プレイヤーの Join 状態</li>
</ul>
<p>Akashic Engine のいくつかのクラスは、ゲーム開発者向けにスナップショット作成・復元を補助する API を提供しています。</p>
<h3><a name="nontrivial-snapshot-entity"></a> エンティティとローカルエンティティ</h3>
<p>エンティティは、ID を含めて保存・復元される必要があります。</p>
<blockquote>
<p>エンティティ ID は、通常エンジンによって暗黙に設定される値で、
ポイントダウンイベントなどの対象エンティティの識別に使われています。
スナップショットからの復元時は、この値も明示的に指定して元の値を再現する必要があります。
というのも、ある ID を持つエンティティが、「スナップショットから復元したか否か」によって異なってしまうと、
「どの ID のエンティティを操作した」という情報の解釈がプレイヤーによって変わってしまい、マルチプレイが破綻するためです。</p>
</blockquote>
<p>位置やサイズなどの他プロパティと合わせて、ID (<code>g.E#id</code>) もスナップショットに加えてください。
<code>g.E</code> とその派生クラスは、スナップショットから復元時のために、
コンストラクタ引数 (<code>g.EParameterObject</code>) で <code>id</code> を指定できるようになっています。
指定すると、エンジンによって暗黙に生成された ID の代わりに、指定された値を利用します。</p>
<p>スナップショットからの復元時には、ID を指定して同じクラスのインスタンスを <code>new</code> した上で、
元と同じプロパティを設定することになります。</p>
<p>他方でローカルエンティティは、スナップショットに保存する必要がありません。
スナップショットはローカルエンティティの状態を保存できない(すべきでない)からです。
というのも、スナップショットは一つのプレイの一つのフレームにおいて一意です。
しかしローカルエンティティは、同じプレイの同じフレームにおいても
各デバイス (エンジンインスタンス) 上で異なる状態をとることができます。
この性質はスナップショットには保存できません。
ここまでスナップショットはゲームの実行状態を「完全に復元する必要がある」と書いていますが、
この点は例外であることに気をつけてください。</p>
<p>スナップショットはローカルエンティティの状態を保存・復元できません。これは Akashic の制限です。</p>
<h3><a name="nontrivial-snapshot-camera"></a> カメラ</h3>
<p>利用している場合、カメラ (<code>g.Camera</code>) も復元が必要です。</p>
<p>これには <code>g.Camera#serialize()</code> を利用することができます。 <code>serialize()</code> の戻り値をスナップショットに含めておき、
適切なクラス (現在は <code>g.Camera2D</code> のみです) の static メソッド <code>deserialize()</code> に渡すことでカメラを復元することができます。</p>
<p><code>g.Game#focusingCamera</code> の値も、保存するならば <code>id</code> で保持される必要があります。
ただしマルチプレイヤーゲームの <code>focusingCamera</code> の場合、その値はインスタンスごとに異なりうるでしょう。
その場合はローカルエンティティと同様、<code>g.game.focusingCamera</code> そのものの <code>id</code> を直接スナップショットに含めるべきではありません。</p>
<p>後述の「プレイヤーの状態」のデータとして各プレイヤーのカメラ ID も保時しておき、
復元時はプレイヤーに応じて <code>focusingCamera</code> を設定することになるでしょう。</p>
<h3><a name="nontrivial-snapshot-scene"></a> シーン</h3>
<p>シーン <code>g.Scene</code> の状態も、エンティティと同様に保存・復元される必要があります。
スナップショットからの復元時には、<code>g.Scene</code> (あるいはゲーム開発者の定義した派生クラス) を
<code>new</code> した上で、元と同じハンドラを設定することになります。</p>
<p>単純なケースでは、シーンの初期化は全て <code>g.Scene#onLoad</code> の処理の中に記述されているでしょう。
スナップショットからの復元時であっても、シーンは新規生成時と同じパスを通ることになります。
したがって他にシーンに持たせているゲーム内データがなければ、通常時と同じようにシーンを生成し初期化処理を記述すればよいはずです。</p>
<h3><a name="nontrivial-snapshot-randoms"></a> 乱数生成器</h3>
<p>エンジンのデフォルト乱数生成器 <code>g.Game#random</code> は、エンジンによって自動的に状態が保存・復元されます。
それ以外の乱数生成器をゲーム開発者が作成している場合は、自力で保存・復元を行ってください。</p>
<p>これを実現するため、乱数生成器 <code>g.RandomGenerator</code> は <code>serialize()</code> を提供しています。
この関数の戻り値をスナップショットに含めておき、
元のクラス(<code>g.XorshiftRandomGenerator</code> など)の static メソッド <code>deserialize()</code> に渡すことで乱数生成器を復元できます。</p>
<h3><a name="nontrivial-snapshot-join-state"></a> プレイヤーの Join 状態</h3>
<p>スナップショットからの復元時、その時点までに通知されていた <code>g.JoinEvent</code> や <code>g.LeaveEvent</code> が通知されなおすことはありません。
スナップショットには通知された結果として至った実行状態を直接保存し、またその状態を復元してください。</p>
<p><code>g.Game#onJoin</code>, <code>onLeave</code> を利用して Join したプレイヤーの情報を <code>g.Game#vars</code> に保持しているのであれば、
<code>vars</code> の内容をスナップショットに含めることでプレイヤーの参加状態も保存されることになります。</p>
<h3><a name="nontrivial-snapshot-game-vars"></a> g.Game#vars</h3>
<p>汎用のゲーム内データ保持領域として、エンジンは <code>g.Game#vars: any</code> を提供しています。
エンジンはこの値の内容に関知していないため、スナップショット保存上のサポートもありません。
必要なデータはゲーム開発者がスナップショットに保持する必要があります。</p>
<h3><a name="nontrivial-snapshot-game-external"></a> g.Game#external</h3>
<p>サービス依存の外部インターフェース <code>g.Game#external</code> も同様に、スナップショット保存上のサポートはありません。
<code>external</code> の各実装ごとに提供される方法がある場合はそれを利用してください。</p>
<div class="navi-center">
<a href="./release-multiplay.html">前 (マルチプレイゲームを公開する)</a>
 | <a href="../">目次</a>
 | -
</div>


			</div>
		</div>
	</section>
	<footer class="safearea--LR">
	<div class="responsive--width">

		<ul class="foot--creativecommons">
			<li class="foot--creativecommons--ban"><a href="http://creativecommons.org/licenses/by/2.1/jp/" target="_blank"><img alt="クリエイティブ・コモンズ・ライセンス" src="https://i.creativecommons.org/l/by/2.1/jp/80x15.png"></a></li>
			<li class="foot--creativecommons--txt">このサイトの画像は、一部を除き <a rel="license" href="http://creativecommons.org/licenses/by/2.1/jp/" target="_blank">クリエイティブ・コモンズ 表示 2.1 日本 ライセンス</a><br>の下に提供されています: <a href="/image-license.html">詳細</a></li>
		</ul>

		<ul class="foot--license">
			<li class="foot--license--akashic"><a href="https://akashic-games.github.io"></a></li>
			<li class="foot--license--dwango"><a href="http://dwango.co.jp" target="_blank">&copy; dwango</a></li>
		</ul>

	</div>
</footer>

</div>
<div class="page--top"></div>
<div class="window--dark"></div>

<script>
	// リサイズ時にコンテンツのリサイズができない状態なので暫定対応でコンテンツをリロードしている
	// TODO: リサイズ時にコンテンツも追従する仕組みを作成する
	window.addEventListener('resize', function() {
		var iframes = document.getElementsByClassName('akashic-content');
		var contents = Array.prototype.slice.call(iframes);
		contents.forEach(function(content) {
			content.contentWindow.location.reload(true);
		});
	});
</script>
</body>
</html>
